;(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var ref$, sort, names, unchars, words, unwords, path, EventEmitter, grasp, StdIn, bold, aliases, runCommand, argsRegex, run, slice$ = [].slice;
  ref$ = require('prelude-ls'), sort = ref$.sort, names = ref$.names, unchars = ref$.unchars, words = ref$.words, unwords = ref$.unwords;
  path = require('path');
  EventEmitter = require('events').EventEmitter;
  grasp = require('grasp');
  StdIn = (function(superclass){
    var prototype = extend$((import$(StdIn, superclass).displayName = 'StdIn', StdIn), superclass).prototype, constructor = StdIn;
    function StdIn(data){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.data = data != null
        ? data
        : [];
      this$.emitData = bind$(this$, 'emitData', prototype);
      this$.done = false;
      return this$;
    } function ctor$(){} ctor$.prototype = prototype;
    prototype.push = function(it){
      return this.data.push(it);
    };
    prototype.finish = function(){
      return this.done = true;
    };
    prototype.emitData = function(){
      if (this.data.length) {
        this.emit('data', this.data.shift());
      }
      if (!this.data.length && this.done) {
        clearInterval(this.interval);
        return this.emit('end');
      }
    };
    prototype.resume = function(){
      return this.interval = setInterval(this.emitData, 0);
    };
    prototype.setEncoding = function(){};
    return StdIn;
  }(EventEmitter));
  bold = function(it){
    return "[[b;;]" + it + "]";
  };
  aliases = {
    '..': ['cd', ['..']],
    '...': ['cd', ['../..']],
    '....': ['cd', ['../../..']],
    'l': ['ls', []]
  };
  runCommand = function(arg$, arg1$){
    var fs, process, term, callback, error, stdin, exit, command, args, mvCp, writeAppend, ref$, names, output, res$, i$, len$, name, target, targetPath, e, file, recursive, filename, $demoContainer, $term, cancel, save;
    fs = arg$.fs, process = arg$.process, term = arg$.term, callback = arg$.callback, error = arg$.error, stdin = arg$.stdin, exit = arg$.exit;
    command = arg1$[0], args = slice$.call(arg1$, 1);
    mvCp = function(cmd, args){
      var i$, sources, dest, destIsDir, e, len$, source, destPath;
      sources = 0 < (i$ = args.length - 1) ? slice$.call(args, 0, i$) : (i$ = 0, []), dest = args[i$];
      try {
        destIsDir = fs.lstatSync(dest).isDirectory();
      } catch (e$) {
        e = e$;
        destIsDir = false;
      }
      if (destIsDir) {
        for (i$ = 0, len$ = sources.length; i$ < len$; ++i$) {
          source = sources[i$];
          destPath = path.join(dest, path.basename(source));
          try {
            if (cmd === 'mv') {
              fs.mvSync(source, destPath);
            } else {
              fs.cpSync(source, destPath);
            }
          } catch (e$) {
            e = e$;
            error(cmd + ": " + e.message);
          }
        }
      } else {
        if (sources.length === 1) {
          source = sources[0];
          try {
            if (cmd === 'mv') {
              fs.mvSync(source, dest);
            } else {
              fs.cpSync(source, dest);
            }
          } catch (e$) {
            e = e$;
            error(cmd + ": " + e.message);
          }
        } else {
          error(cmd + ": target '" + dest + "' is not a directory");
        }
      }
    };
    writeAppend = function(cmd, args){
      var output;
      output = '';
      stdin.on('data', (function(it){
        return output += it;
      }));
      stdin.on('end', function(){
        var i$, ref$, len$, targetPath, e;
        for (i$ = 0, len$ = (ref$ = args).length; i$ < len$; ++i$) {
          targetPath = ref$[i$];
          try {
            fs[cmd + "FileSync"](targetPath, output);
          } catch (e$) {
            e = e$;
            error("Failed " + cmd + "ing to " + targetPath);
          }
        }
        return exit();
      });
      return stdin.resume();
    };
    if (command in aliases) {
      ref$ = aliases[command], command = ref$[0], args = ref$[1];
    }
    switch (command) {
    case 'grasp':
      grasp({
        args: unwords(args),
        error: error,
        callback: callback,
        exit: exit,
        stdin: stdin,
        fs: fs,
        console: {
          log: callback,
          warn: callback,
          error: callback,
          time: function(){},
          timeEnd: function(){}
        }
      });
      break;
    case 'clear':
      term.clear();
      break;
    case 'pwd':
      callback(process.cwd());
      break;
    case 'ls':
      names = fs.readdirSync(args[0] || '.');
      res$ = [];
      for (i$ = 0, len$ = (ref$ = sort(names)).length; i$ < len$; ++i$) {
        name = ref$[i$];
        if (fs.lstatSync(name).isDirectory()) {
          res$.push(bold(name));
        } else {
          res$.push(name);
        }
      }
      output = res$;
      callback(unwords(output));
      break;
    case 'cd':
      target = args[0] || '/';
      targetPath = target === '-'
        ? process.previousCwd()
        : path.resolve(process.cwd(), target);
      try {
        if (fs.lstatSync(targetPath).isDirectory()) {
          process.chdir(targetPath);
        } else {
          error("cd: " + targetPath + ": Not a directory");
        }
      } catch (e$) {
        e = e$;
        error("cd: " + targetPath + ": No such file or directory");
      }
      break;
    case 'mkdir':
      targetPath = args[0];
      try {
        fs.mkdirSync(targetPath);
      } catch (e$) {
        e = e$;
        error("mkdir: " + e.message);
      }
      break;
    case 'cat':
      output = [];
      for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
        file = args[i$];
        try {
          output.push(fs.readFileSync(file));
        } catch (e$) {
          e = e$;
          error("cat: " + e.message);
        }
      }
      callback(unchars(output).replace(/\n$/, ''));
      break;
    case 'echo':
      callback(unwords(args));
      break;
    case 'touch':
      try {
        fs.writeFileSync(args[0], '');
      } catch (e$) {
        e = e$;
        error("touch: " + e.message);
      }
      break;
    case 'rm':
      if (args[0] === '-r') {
        args.shift();
        recursive = true;
      } else {
        recursive = false;
      }
      for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
        target = args[i$];
        try {
          fs.unlinkSync(target, recursive);
        } catch (e$) {
          e = e$;
          error(e.message);
        }
      }
      break;
    case 'rmdir':
      for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
        target = args[i$];
        try {
          fs.rmdirSync(target);
        } catch (e$) {
          e = e$;
          error(e.message);
        }
      }
      break;
    case 'cp':
      mvCp('cp', args);
      break;
    case 'mv':
      mvCp('mv', args);
      break;
    case 'write':
      writeAppend('write', args);
      break;
    case 'append':
      writeAppend('append', args);
      break;
    case 'edit':
      filename = args[0];
      try {
        output = fs.readFileSync(filename);
      } catch (e$) {
        e = e$;
        output = '';
      }
      $demoContainer = $('#demo-container');
      $term = $('#demo-terminal');
      $term.hide();
      $demoContainer.append("<div class=\"edit-file\">\n  <textarea class=\"term\">" + output + "</textarea>\n  <div class=\"edit-buttons\">\n    <button type=\"button\" class=\"btn btn-primary action-save\">Save</button>\n    <button type=\"button\" class=\"btn btn-default action-cancel\">Cancel</button>\n  </div>\n</div>");
      $demoContainer.find('.edit-file textarea').focus();
      cancel = function(){
        $('.edit-file').remove();
        $term.show();
        $term.click();
        return exit();
      };
      save = function(){
        fs.writeFileSync(filename, $demoContainer.find('.edit-file textarea').val());
        $demoContainer.find('.edit-file').remove();
        $term.show();
        $term.click();
        return exit();
      };
      $demoContainer.find('.edit-file .action-cancel').click(cancel);
      $demoContainer.find('.edit-file .action-save').click(save);
      break;
    default:
      error("Invalid command: " + command + " " + unwords(args));
    }
    if (command !== 'grasp' && command !== 'edit' && command !== 'write') {
      exit();
    }
  };
  argsRegex = /'(?:[^']|\\')+'|"(?:[^"]|\\")+"|\||<|>>|>|;|[^\s\|<>;]+/g;
  run = function(options, args){
    var term, tokens, commands, sequence, tokensSoFar, token, i$, len$, lastI, stdin, j$, len1$, i, command, ref$, callback, exit, runCommandOptions;
    term = options.term;
    term.pause();
    args = args.trim();
    ga('send', 'event', 'demo', 'run', 'args', args);
    tokens = args.match(argsRegex);
    if (tokens[tokens.length - 1] !== ';') {
      tokens.push(';');
    }
    commands = [];
    sequence = [];
    tokensSoFar = [];
    while (tokens.length) {
      token = tokens.shift();
      switch (token) {
      case '|':
        sequence.push(tokensSoFar);
        tokensSoFar = [];
        break;
      case ';':
        if (tokensSoFar.length) {
          sequence.push(tokensSoFar);
        }
        commands.push(sequence);
        tokensSoFar = [];
        sequence = [];
        break;
      case '<':
        sequence.push(['cat', tokens.shift()]);
        break;
      case '>':
        sequence.push(tokensSoFar);
        tokensSoFar = [];
        sequence.push(['write', tokens.shift()]);
        break;
      case '>>':
        sequence.push(tokensSoFar);
        tokensSoFar = [];
        sequence.push(['append', tokens.shift()]);
        break;
      default:
        tokensSoFar.push(token);
      }
    }
    for (i$ = 0, len$ = commands.length; i$ < len$; ++i$) {
      sequence = commands[i$];
      lastI = sequence.length - 1;
      stdin = new StdIn;
      for (j$ = 0, len1$ = sequence.length; j$ < len1$; ++j$) {
        i = j$;
        command = sequence[j$];
        ref$ = i === lastI
          ? [stdin, options.callback, fn$]
          : (stdin = new StdIn, [stdin, fn1$, fn2$]), stdin = ref$[0], callback = ref$[1], exit = ref$[2];
        runCommandOptions = {
          fs: options.fs,
          process: options.process,
          term: options.term,
          callback: callback,
          error: options.error,
          stdin: stdin,
          exit: exit
        };
        runCommand(runCommandOptions, command);
      }
    }
    function fn$(){
      return term.resume();
    }
    function fn1$(it){
      return stdin.push(it);
    }
    function fn2$(){
      stdin.finish();
      return term.resume();
    }
  };
  module.exports = {
    run: run
  };
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
  function extend$(sub, sup){
    function fun(){} fun.prototype = (sub.superclass = sup).prototype;
    (sub.prototype = new fun).constructor = sub;
    if (typeof sup.extended == 'function') sup.extended(sub);
    return sub;
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);

},{"events":6,"grasp":14,"path":8,"prelude-ls":91}],2:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var path, FileSystem, Process, run, process, fs;
  path = require('path');
  window.process = {
    stdout: {}
  };
  FileSystem = require('./fs');
  Process = require('./process');
  run = require('./command').run;
  process = new Process;
  window.process = process;
  fs = new FileSystem(process);
  fs.writeFileSync('a.js', 'function g(x) {\n  if (x && f(x)) { return [1, 2]; }\n  doSomething();\n  while(x < 2) {\n    if (xs.length && ys.length) {\n      return xs[x] + ys[x];\n    }\n    x++;\n  }\n  if (x == 3 && list[x]) {\n    return list;\n  }\n}');
  fs.writeFileSync('b.js', 'function g(x, str) {\n  if (x == null) { return; }\n  if (x < 2) { return x + 2; }\n  switch (n) {\n    case 1:\n      f({x: str});\n      try {\n        zz(o);\n      } catch (e) {\n        return e;\n      }\n    case 2:\n      return \'>>\' + str.slice(2);\n  }\n  return f(z) + x;\n}');
  fs.writeFileSync('c.js', 'f(x < y, x == z);');
  $.terminal.ansi_colors.normal = {
    black: '#000',
    red: '#dc322f',
    green: '#859900',
    yellow: '#b58900',
    blue: '#268bd2',
    magenta: '#d33682',
    cyan: '#2aa198',
    white: '#839496'
  };
  $(function(){
    var $demo;
    $demo = $('#demo-terminal');
    return $demo.terminal(function(args, term){
      return run({
        callback: term.echo,
        error: term.error,
        term: term,
        fs: fs,
        process: process
      }, args);
    }, {
      greetings: '',
      enabled: false,
      keydown: function(e, term){
        var ref$;
        if (((ref$ = e.which || e.keyCode) === 67 || ref$ === 90) && e.ctrlKey) {
          return term.resume();
        }
      },
      prompt: function(it){
        return it(process.cwd() + '[[;#b58900;]$] ');
      }
    });
  });
}).call(this);

},{"./command":1,"./fs":3,"./process":4,"path":8}],3:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var ref$, keys, compact, Obj, path, FileSystem;
  ref$ = require('prelude-ls'), keys = ref$.keys, compact = ref$.compact, Obj = ref$.Obj;
  path = require('path');
  module.exports = FileSystem = (function(){
    FileSystem.displayName = 'FileSystem';
    var prototype = FileSystem.prototype, constructor = FileSystem;
    function FileSystem(process){
      this.process = process;
      this.fs = {
        type: 'directory',
        contents: {}
      };
    }
    prototype._getAtPath = function(targetPath){
      var current, parts, i$, len$, i, part, that;
      current = this.fs;
      parts = compact(targetPath.split('/'));
      for (i$ = 0, len$ = parts.length; i$ < len$; ++i$) {
        i = i$;
        part = parts[i$];
        if (current.type === 'directory') {
          if (that = current.contents[part]) {
            current = that;
            continue;
          }
        }
        throw new Error(targetPath + ": No such file or directory");
      }
      return current;
    };
    prototype.existsSync = function(targetPath){
      var e;
      try {
        this._getAtPath(targetPath);
        return true;
      } catch (e$) {
        e = e$;
        return false;
      }
    };
    prototype.readFileSync = function(targetPath){
      var absPath, node;
      absPath = path.resolve(this.process.cwd(), targetPath);
      node = this._getAtPath(absPath);
      if (node.type === 'directory') {
        throw new Error(absPath + " is directory");
      } else {
        return node.contents;
      }
    };
    prototype.writeFileSync = function(targetPath, data){
      var filename, parent;
      filename = path.basename(targetPath);
      parent = this._getAtPath(path.resolve(this.process.cwd(), targetPath, '..'));
      parent.contents[filename] = {
        type: 'file',
        contents: data
      };
    };
    prototype.appendFileSync = function(targetPath, data){
      var node;
      node = this._getAtPath(path.resolve(this.process.cwd(), targetPath));
      if (/\n$/.test(node.contents)) {
        node.contents += data;
      } else {
        node.contents += "\n" + data;
      }
    };
    prototype.mkdirSync = function(targetPath){
      var dirname, parent;
      dirname = path.basename(targetPath);
      parent = this._getAtPath(path.resolve(this.process.cwd(), targetPath, '..'));
      parent.contents[dirname] = {
        type: 'directory',
        contents: {}
      };
    };
    prototype.readdirSync = function(targetPath){
      var node;
      node = this._getAtPath(path.resolve(this.process.cwd(), targetPath));
      if (node.type === 'file') {
        throw new Error(targetPath + " is file");
      } else {
        return keys(node.contents);
      }
    };
    prototype.lstatSync = function(targetPath){
      var node;
      node = this._getAtPath(path.resolve(this.process.cwd(), targetPath));
      return {
        isDirectory: function(){
          return node.type === 'directory';
        },
        isFile: function(){
          return node.type === 'file';
        }
      };
    };
    prototype.cpSync = function(source, destination){
      var destName, sourceNode, destinationParent;
      destName = path.basename(destination);
      sourceNode = this._getAtPath(path.resolve(this.process.cwd(), source));
      destinationParent = this._getAtPath(path.resolve(this.process.cwd(), destination, '..'));
      return destinationParent.contents[destName] = sourceNode;
    };
    prototype.mvSync = function(source, destination){
      var basename, destName, sourceNode, parentNode, destinationParent;
      basename = path.basename(source);
      destName = path.basename(destination);
      sourceNode = this._getAtPath(path.resolve(this.process.cwd(), source));
      parentNode = this._getAtPath(path.resolve(this.process.cwd(), source, '..'));
      delete parentNode.contents[basename];
      destinationParent = this._getAtPath(path.resolve(this.process.cwd(), destination, '..'));
      return destinationParent.contents[destName] = sourceNode;
    };
    prototype.unlinkSync = function(targetPath, recursive){
      var targetName, resolvedPath, parentPath, parent, that;
      targetName = path.basename(targetPath);
      resolvedPath = path.resolve(this.process.cwd(), targetPath);
      parentPath = path.resolve(resolvedPath, '..');
      parent = this._getAtPath(parentPath);
      if ('/' === resolvedPath) {
        throw new Error('rm: cannot remove root directory');
      } else if (that = parent.contents[targetName]) {
        if (that.type === 'file' || recursive) {
          delete parent.contents[targetName];
        } else {
          throw new Error("rm: cannot remove '" + targetPath + "': Is a directory");
        }
      } else {
        throw new Error("rm: cannot remove '" + targetPath + "': No such file or directory");
      }
    };
    prototype.rmdirSync = function(targetPath){
      var targetName, resolvedPath, parent, that, target;
      targetName = path.basename(targetPath);
      resolvedPath = path.resolve(this.process.cwd(), targetPath, '..');
      parent = this._getAtPath(resolvedPath);
      if ('/' === path.resolve(resolvedPath, targetName)) {
        throw new Error('rmdir: cannot remove root directory');
      } else if (that = parent.contents[targetName]) {
        target = that;
        if (target.type === 'directory') {
          if (Obj.empty(target.contents)) {
            delete parent.contents[targetName];
          } else {
            throw new Error("rmdir: failed to remove '" + targetPath + "': Directory not empty");
          }
        } else {
          throw new Error("rmdir: cannot remove '" + targetPath + "': Not a directory");
        }
      } else {
        throw new Error("rmdir: cannot remove '" + targetPath + "': No such file or directory");
      }
    };
    return FileSystem;
  }());
}).call(this);

},{"path":8,"prelude-ls":91}],4:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var path, Process;
  path = require('path');
  module.exports = Process = (function(){
    Process.displayName = 'Process';
    var prototype = Process.prototype, constructor = Process;
    function Process(){
      this._cwd = '/';
    }
    prototype.cwd = function(){
      return this._cwd;
    };
    prototype.previousCwd = function(){
      return this._previousCwd;
    };
    prototype.chdir = function(dir){
      this._previousCwd = this._cwd;
      this._cwd = path.resolve(this._cwd, dir);
    };
    return Process;
  }());
}).call(this);

},{"path":8}],5:[function(require,module,exports){


//
// The shims in this file are not fully implemented shims for the ES5
// features, but do work for the particular usecases there is in
// the other modules.
//

var toString = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

// Array.isArray is supported in IE9
function isArray(xs) {
  return toString.call(xs) === '[object Array]';
}
exports.isArray = typeof Array.isArray === 'function' ? Array.isArray : isArray;

// Array.prototype.indexOf is supported in IE9
exports.indexOf = function indexOf(xs, x) {
  if (xs.indexOf) return xs.indexOf(x);
  for (var i = 0; i < xs.length; i++) {
    if (x === xs[i]) return i;
  }
  return -1;
};

// Array.prototype.filter is supported in IE9
exports.filter = function filter(xs, fn) {
  if (xs.filter) return xs.filter(fn);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    if (fn(xs[i], i, xs)) res.push(xs[i]);
  }
  return res;
};

// Array.prototype.forEach is supported in IE9
exports.forEach = function forEach(xs, fn, self) {
  if (xs.forEach) return xs.forEach(fn, self);
  for (var i = 0; i < xs.length; i++) {
    fn.call(self, xs[i], i, xs);
  }
};

// Array.prototype.map is supported in IE9
exports.map = function map(xs, fn) {
  if (xs.map) return xs.map(fn);
  var out = new Array(xs.length);
  for (var i = 0; i < xs.length; i++) {
    out[i] = fn(xs[i], i, xs);
  }
  return out;
};

// Array.prototype.reduce is supported in IE9
exports.reduce = function reduce(array, callback, opt_initialValue) {
  if (array.reduce) return array.reduce(callback, opt_initialValue);
  var value, isValueSet = false;

  if (2 < arguments.length) {
    value = opt_initialValue;
    isValueSet = true;
  }
  for (var i = 0, l = array.length; l > i; ++i) {
    if (array.hasOwnProperty(i)) {
      if (isValueSet) {
        value = callback(value, array[i], i, array);
      }
      else {
        value = array[i];
        isValueSet = true;
      }
    }
  }

  return value;
};

// String.prototype.substr - negative index don't work in IE8
if ('ab'.substr(-1) !== 'b') {
  exports.substr = function (str, start, length) {
    // did we get a negative start, calculate how much it is from the beginning of the string
    if (start < 0) start = str.length + start;

    // call the original function
    return str.substr(start, length);
  };
} else {
  exports.substr = function (str, start, length) {
    return str.substr(start, length);
  };
}

// String.prototype.trim is supported in IE9
exports.trim = function (str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
};

// Function.prototype.bind is supported in IE9
exports.bind = function () {
  var args = Array.prototype.slice.call(arguments);
  var fn = args.shift();
  if (fn.bind) return fn.bind.apply(fn, args);
  var self = args.shift();
  return function () {
    fn.apply(self, args.concat([Array.prototype.slice.call(arguments)]));
  };
};

// Object.create is supported in IE9
function create(prototype, properties) {
  var object;
  if (prototype === null) {
    object = { '__proto__' : null };
  }
  else {
    if (typeof prototype !== 'object') {
      throw new TypeError(
        'typeof prototype[' + (typeof prototype) + '] != \'object\''
      );
    }
    var Type = function () {};
    Type.prototype = prototype;
    object = new Type();
    object.__proto__ = prototype;
  }
  if (typeof properties !== 'undefined' && Object.defineProperties) {
    Object.defineProperties(object, properties);
  }
  return object;
}
exports.create = typeof Object.create === 'function' ? Object.create : create;

// Object.keys and Object.getOwnPropertyNames is supported in IE9 however
// they do show a description and number property on Error objects
function notObject(object) {
  return ((typeof object != "object" && typeof object != "function") || object === null);
}

function keysShim(object) {
  if (notObject(object)) {
    throw new TypeError("Object.keys called on a non-object");
  }

  var result = [];
  for (var name in object) {
    if (hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// getOwnPropertyNames is almost the same as Object.keys one key feature
//  is that it returns hidden properties, since that can't be implemented,
//  this feature gets reduced so it just shows the length property on arrays
function propertyShim(object) {
  if (notObject(object)) {
    throw new TypeError("Object.getOwnPropertyNames called on a non-object");
  }

  var result = keysShim(object);
  if (exports.isArray(object) && exports.indexOf(object, 'length') === -1) {
    result.push('length');
  }
  return result;
}

var keys = typeof Object.keys === 'function' ? Object.keys : keysShim;
var getOwnPropertyNames = typeof Object.getOwnPropertyNames === 'function' ?
  Object.getOwnPropertyNames : propertyShim;

if (new Error().hasOwnProperty('description')) {
  var ERROR_PROPERTY_FILTER = function (obj, array) {
    if (toString.call(obj) === '[object Error]') {
      array = exports.filter(array, function (name) {
        return name !== 'description' && name !== 'number' && name !== 'message';
      });
    }
    return array;
  };

  exports.keys = function (object) {
    return ERROR_PROPERTY_FILTER(object, keys(object));
  };
  exports.getOwnPropertyNames = function (object) {
    return ERROR_PROPERTY_FILTER(object, getOwnPropertyNames(object));
  };
} else {
  exports.keys = keys;
  exports.getOwnPropertyNames = getOwnPropertyNames;
}

// Object.getOwnPropertyDescriptor - supported in IE8 but only on dom elements
function valueObject(value, key) {
  return { value: value[key] };
}

if (typeof Object.getOwnPropertyDescriptor === 'function') {
  try {
    Object.getOwnPropertyDescriptor({'a': 1}, 'a');
    exports.getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  } catch (e) {
    // IE8 dom element issue - use a try catch and default to valueObject
    exports.getOwnPropertyDescriptor = function (value, key) {
      try {
        return Object.getOwnPropertyDescriptor(value, key);
      } catch (e) {
        return valueObject(value, key);
      }
    };
  }
} else {
  exports.getOwnPropertyDescriptor = valueObject;
}

},{}],6:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util');

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!util.isNumber(n) || n < 0)
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (util.isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        throw TypeError('Uncaught, unspecified "error" event.');
      }
      return false;
    }
  }

  handler = this._events[type];

  if (util.isUndefined(handler))
    return false;

  if (util.isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (util.isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!util.isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              util.isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (util.isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (util.isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!util.isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      console.trace();
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!util.isFunction(listener))
    throw TypeError('listener must be a function');

  function g() {
    this.removeListener(type, g);
    listener.apply(this, arguments);
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!util.isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (util.isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (util.isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (util.isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (util.isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (util.isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};
},{"util":10}],7:[function(require,module,exports){

// not implemented
// The reason for having an empty file and not throwing is to allow
// untraditional implementation of this module.

},{}],8:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util');
var shims = require('_shims');

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (!util.isString(path)) {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(shims.filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = shims.substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(shims.filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(shims.filter(paths, function(p, index) {
    if (!util.isString(p)) {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

},{"_shims":5,"util":10}],9:[function(require,module,exports){

exports.isatty = function () { return false; };

function ReadStream() {
  throw new Error('tty.ReadStream is not implemented');
}
exports.ReadStream = ReadStream;

function WriteStream() {
  throw new Error('tty.ReadStream is not implemented');
}
exports.WriteStream = WriteStream;

},{}],10:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var shims = require('_shims');

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  shims.forEach(array, function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = shims.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = shims.getOwnPropertyNames(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }

  shims.forEach(keys, function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = shims.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (shims.indexOf(ctx.seen, desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = shims.reduce(output, function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return shims.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) && objectToString(e) === '[object Error]';
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.binarySlice === 'function'
  ;
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = shims.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = shims.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

},{"_shims":5}],11:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var ref$, each, keys, difference, intersection, syntax, syntaxFlat, i$, category, nodeName, node, complexTypes, complexTypeMap, key, val, aliasMap, matchesMap, matchesAliasMap, literals, literalMap, attrMap, attrMapInverse, alias, name, primitiveAttributesSet, nonPrimitiveAttributesSet, that, nonPrimitiveAttributes, primitiveAttributes, eitherAttributes, primitiveOnlyAttributes;
  ref$ = require('prelude-ls'), each = ref$.each, keys = ref$.keys, difference = ref$.difference, intersection = ref$.intersection;
  syntax = {
    Misc: {
      Program: {
        alias: 'program',
        nodeArrays: ['body'],
        note: "The root node of a JavaScript program's AST."
      },
      Identifier: {
        alias: 'ident',
        primitives: ['name'],
        example: 'x'
      },
      Literal: {
        alias: 'literal',
        primitives: ['value'],
        example: ['true', '1', '"string"']
      },
      Property: {
        alias: 'prop',
        nodes: ['key', 'value'],
        primitives: ['kind'],
        syntax: '*key*: *value*',
        example: 'a: 1',
        note: 'An object expression (obj) has a list of properties, each being a property.'
      }
    },
    Statements: {
      EmptyStatement: {
        alias: 'empty',
        example: ';'
      },
      BlockStatement: {
        alias: 'block',
        nodeArrays: ['body'],
        syntax: '{\n  *statement_1*\n  *statement_2*\n  *...*\n  *statement_n*\n}',
        example: '{\n  x = 1;\n  f();\n  x++;\n}'
      },
      ExpressionStatement: {
        alias: 'exp-statement',
        nodes: ['expression'],
        syntax: '*expression*;',
        example: '2;',
        note: 'When an expression is used where a statement should be, it is wrapped in an expression statement.'
      },
      IfStatement: {
        alias: 'if',
        nodes: ['test', 'consequent', 'alternate'],
        syntax: 'if (*test*)\n  *consequent*\n[else\n  *alternate*]',
        example: ['if (even(x)) {\n  f(x);\n}', 'if (x === 2) {\n  x++;\n} else {\n  f(x);\n}']
      },
      LabeledStatement: {
        alias: 'label',
        nodes: ['label', 'body'],
        syntax: '*label*: *body*;',
        example: 'outer:\nfor (i = 0; i < xs.length; i++) {\n  for (j = 0; j < ys.length; j++) {\n    if (xs[i] === ys[j]) {\n      break outer;\n    }\n  }\n}'
      },
      BreakStatement: {
        alias: 'break',
        nodes: ['label'],
        syntax: 'break [*label*];',
        example: ['break;', 'break outer;']
      },
      ContinueStatement: {
        alias: 'continue',
        nodes: ['label'],
        syntax: 'continue [*label*];',
        example: ['continue;', 'continue outerLoop;']
      },
      WithStatement: {
        alias: 'with',
        nodes: ['object', 'body'],
        syntax: 'with (*object*)\n  *body*',
        example: 'with ({x: 42}) {\n  f(x);\n}'
      },
      SwitchStatement: {
        alias: 'switch',
        nodes: ['discriminant'],
        nodeArrays: ['cases'],
        syntax: 'switch (*discriminant*) {\n  *case_1*\n  *case_2*\n  *...*\n  *case_n*\n}',
        example: 'switch (num) {\n  case 1:\n    f(\'one\');\n    break;\n  case 2:\n    f(\'two\');\n    break;\n  default:\n    f(\'too many\');\n}'
      },
      ReturnStatement: {
        alias: 'return',
        nodes: ['argument'],
        syntax: 'return *argument*;',
        example: 'return f(2);'
      },
      ThrowStatement: {
        alias: 'throw',
        nodes: ['argument'],
        syntax: 'throw *argument*;',
        example: 'throw new Error("oops");'
      },
      TryStatement: {
        alias: 'try',
        nodes: ['block', 'handler', 'finalizer'],
        syntax: 'try\n  *block*\n[*handler*]\n[finally\n   *finalizer*]',
        example: 'try {\n  result = parse(input);\n} catch (error) {\n  console.error(error.message);\n  result = \'\';\n} finally {\n  g(result);\n}'
      },
      WhileStatement: {
        alias: 'while',
        nodes: ['test', 'body'],
        syntax: 'while (*test*)\n  *body*',
        example: 'while (x < 2) {\n  f(x);\n  x++;\n}'
      },
      DoWhileStatement: {
        alias: 'do-while',
        nodes: ['test', 'body'],
        syntax: 'do\n  *body*\nwhile (*test*);',
        example: 'do {\n  f(x);\n  x++;\n} while (x < 2);'
      },
      ForStatement: {
        alias: 'for',
        nodes: ['init', 'test', 'update', 'body'],
        syntax: 'for ([*init*]; [*test*]; [*update*])\n  *body*',
        example: 'for (var x = 0; x < 2; x++) {\n  f(x);\n}'
      },
      ForInStatement: {
        alias: 'for-in',
        nodes: ['left', 'right', 'body'],
        syntax: 'for (*left* in *right*)\n  *body*',
        example: 'for (prop in object) {\n  f(object[prop]);\n}'
      },
      DebuggerStatement: {
        alias: 'debugger',
        syntax: 'debugger;',
        example: 'debugger;'
      }
    },
    Declarations: {
      FunctionDeclaration: {
        alias: 'func-dec',
        nodes: ['id', 'body'],
        nodeArrays: ['params'],
        syntax: 'function *id*([*param_1*], [*param_2*], [..., *param_3*])\n  *body*',
        example: 'function f(x, y) {\n  return x * y;\n}',
        note: 'A function declaration contrasts with a function expression (func-exp).'
      },
      VariableDeclaration: {
        alias: 'var-decs',
        nodeArrays: ['declarations'],
        primitives: ['kind'],
        syntax: 'var *declaration_1*[, *declaration_2*, ..., *declaration_n*]',
        example: 'var x = 1, y = 2;',
        note: 'Each declaration is a variable declarator (var-dec).'
      },
      VariableDeclarator: {
        alias: 'var-dec',
        nodes: ['id', 'init'],
        syntax: '*id* = *init*',
        example: 'var x = 2'
      }
    },
    Expressions: {
      ThisExpression: {
        alias: 'this',
        example: 'this'
      },
      ArrayExpression: {
        alias: 'arr',
        nodeArrays: ['elements'],
        syntax: '[*element_0*, *element_1*, *...*, *element_n*]',
        example: ['[1, 2, 3]', '[]']
      },
      ObjectExpression: {
        alias: 'obj',
        nodeArrays: ['properties'],
        syntax: '{\n  *property_1*,\n  *property_2*,\n  *...*,\n  *property_n*\n}',
        example: ['{a: 1, b: 2}', '{}']
      },
      FunctionExpression: {
        alias: 'func-exp',
        nodes: ['id', 'body'],
        nodeArrays: ['params'],
        syntax: 'function [*id*]([*param_1*], [*param_2*], [..., *param_3*])\n  *body*',
        example: 'var f = function (x, y) {\n  return x * y;\n}',
        note: 'A function expression contrasts with a function declaration (func-dec).'
      },
      SequenceExpression: {
        alias: 'seq',
        nodeArrays: ['expressions'],
        syntax: '*expression_1*, *expression_2*, *...*, *expression_n*',
        example: 'a, b, c'
      },
      UnaryExpression: {
        alias: 'unary',
        nodes: ['argument'],
        primitive: ['operator', 'prefix'],
        syntax: '*operator**argument*',
        example: ['+x', 'typeof x']
      },
      BinaryExpression: {
        alias: 'bi',
        nodes: ['left', 'right'],
        primitives: ['operator'],
        syntax: '*left* *operator* *right*',
        example: 'x === z'
      },
      AssignmentExpression: {
        alias: 'assign',
        nodes: ['left', 'right'],
        primitives: ['operator'],
        syntax: '*left* *operator* *right*',
        example: '(y = 2)'
      },
      UpdateExpression: {
        alias: 'update',
        nodes: ['argument'],
        primitives: ['operator', 'prefix'],
        syntax: '*argument**operator*\n\n*or, if prefix*\n\n*operator**argument*',
        example: ['++x', 'x--']
      },
      LogicalExpression: {
        alias: 'logic',
        nodes: ['left', 'right'],
        primitives: ['operator'],
        syntax: '*left* *operator* *right*',
        example: 'x && y'
      },
      ConditionalExpression: {
        alias: 'cond',
        nodes: ['test', 'consequent', 'alternate'],
        syntax: '*test* ? *consequent* : *alternate*',
        example: 'x % 2 ? "odd" : "even"'
      },
      NewExpression: {
        alias: 'new',
        nodes: ['callee'],
        nodeArrays: ['arguments'],
        syntax: 'new *callee*(*argument_1*, *argument_2*, *...*, *argument_n*)',
        example: 'new Date(2011, 11, 11)'
      },
      CallExpression: {
        alias: 'call',
        nodes: ['callee'],
        nodeArrays: ['arguments'],
        syntax: '*callee*(*argument_1*, *argument_2*, *...*, *argument_n*)',
        example: 'f(1,2,3)'
      },
      MemberExpression: {
        alias: 'member',
        nodes: ['object', 'property'],
        primitives: ['computed'],
        syntax: '*object*.*property*',
        example: 'Math.PI'
      }
    },
    Clauses: {
      SwitchCase: {
        alias: 'switch-case',
        nodes: ['test'],
        nodeArrays: ['consequent'],
        syntax: 'case *test* | default :\n  *consequent*',
        example: ['case 1:\n  z = \'one\';\n  break;', 'default:\n  z = \'two\'']
      },
      CatchClause: {
        alias: 'catch',
        nodes: ['param', 'body'],
        syntax: 'catch (*param*)\n  *body*',
        example: 'catch (e) {\n  console.error(e.message);\n}'
      }
    }
  };
  syntaxFlat = {};
  for (i$ in syntax) {
    category = syntax[i$];
    for (nodeName in category) {
      node = category[nodeName];
      syntaxFlat[nodeName] = node;
    }
  }
  complexTypes = {
    iife: 'ImmediatelyInvokedFunctionExpression'
  };
  complexTypeMap = {};
  for (key in complexTypes) {
    val = complexTypes[key];
    complexTypeMap[key] = val;
    complexTypeMap[val] = val;
  }
  aliasMap = {};
  for (nodeName in syntaxFlat) {
    node = syntaxFlat[nodeName];
    aliasMap[node.alias] = nodeName;
  }
  matchesMap = {
    Statement: keys(syntax.Statements),
    Declaration: keys(syntax.Declarations),
    Expression: keys(syntax.Expressions),
    Clause: keys(syntax.Clauses),
    BiOp: ['BinaryExpression', 'LogicalExpression', 'AssignmentExpression'],
    Function: ['FunctionDeclaration', 'FunctionExpression'],
    ForLoop: ['ForStatement', 'ForInStatement'],
    WhileLoop: ['DoWhileStatement', 'WhileStatement'],
    Loop: ['ForStatement', 'ForInStatement', 'DoWhileStatement', 'WhileStatement']
  };
  matchesAliasMap = {
    statement: 'Statement',
    dec: 'Declaration',
    exp: 'Expression',
    clause: 'Clause',
    biop: 'BiOp',
    func: 'Function',
    'for-loop': 'ForLoop',
    'while-loop': 'WhileLoop',
    loop: 'Loop'
  };
  literals = {
    'null': 'Null',
    bool: 'Boolean',
    num: 'Number',
    str: 'String',
    regex: 'RegExp'
  };
  literalMap = {};
  for (key in literals) {
    val = literals[key];
    literalMap[key] = val;
    literalMap[val] = val;
  }
  attrMap = {
    exp: 'expression',
    exps: 'expressions',
    then: 'consequent',
    alt: 'alternate',
    'else': 'alternate',
    op: 'operator',
    l: 'left',
    r: 'right',
    arg: 'argument',
    args: 'arguments',
    els: 'elements',
    val: 'value',
    obj: 'object',
    prop: 'property',
    props: 'properties',
    decs: 'declarations'
  };
  attrMapInverse = {};
  for (alias in attrMap) {
    name = attrMap[alias];
    attrMapInverse[name] == null && (attrMapInverse[name] = []);
    attrMapInverse[name].push(alias);
  }
  primitiveAttributesSet = {};
  nonPrimitiveAttributesSet = {};
  for (nodeName in syntaxFlat) {
    node = syntaxFlat[nodeName];
    if (that = node.primitives) {
      each(fn$, that);
    }
    if (that = node.nodes) {
      each(fn1$, that);
    }
    if (that = node.nodeArrays) {
      each(fn2$, that);
    }
  }
  nonPrimitiveAttributes = keys(nonPrimitiveAttributesSet);
  primitiveAttributes = keys(primitiveAttributesSet);
  eitherAttributes = intersection(primitiveAttributes, nonPrimitiveAttributes);
  primitiveOnlyAttributes = difference(primitiveAttributes, nonPrimitiveAttributes);
  module.exports = {
    syntax: syntax,
    syntaxFlat: syntaxFlat,
    complexTypeMap: complexTypeMap,
    aliasMap: aliasMap,
    matchesMap: matchesMap,
    matchesAliasMap: matchesAliasMap,
    literalMap: literalMap,
    attrMap: attrMap,
    attrMapInverse: attrMapInverse,
    primitiveOnlyAttributes: primitiveOnlyAttributes,
    eitherAttributes: eitherAttributes
  };
  function fn$(it){
    return primitiveAttributesSet[it] = true;
  }
  function fn1$(it){
    return nonPrimitiveAttributesSet[it] = true;
  }
  function fn2$(it){
    return nonPrimitiveAttributesSet[it] = true;
  }
}).call(this);

},{"prelude-ls":91}],12:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var ref$, id, compact, unlines, min, max;
  ref$ = require('prelude-ls'), id = ref$.id, compact = ref$.compact, unlines = ref$.unlines, min = ref$.min, max = ref$.max;
  module.exports = {
    formatResult: formatResult,
    formatName: formatName,
    formatCount: formatCount
  };
  function formatResult(name, inputLines, inputLinesLength, arg$, options, node){
    var color, bold, resStartLine, startLine, resEndLine, endLine, startCol, endCol, highlight, onlyMatch, outputLines, res$, i$, lineNum, line, start, middle, end, rest, cleanLines, multiline, outputString, displayStartLine, displayEndLine, locationString, separatorString, nameString;
    color = arg$.color, bold = arg$.bold;
    resStartLine = node.loc.start.line - 1;
    startLine = max(resStartLine - options.beforeContext, 0);
    resEndLine = node.loc.end.line - 1;
    endLine = min(resEndLine + options.afterContext, inputLinesLength - 1);
    startCol = node.loc.start.column;
    endCol = node.loc.end.column;
    highlight = function(){
      return color.red(bold.apply(this, arguments));
    };
    onlyMatch = options.onlyMatching;
    res$ = [];
    for (i$ = startLine; i$ <= endLine; ++i$) {
      lineNum = i$;
      line = inputLines[lineNum];
      if (lineNum < resStartLine || lineNum > resEndLine) {
        if (onlyMatch) {
          res$.push('');
        } else {
          res$.push(line);
        }
      } else if (lineNum === resStartLine && resStartLine === resEndLine) {
        start = onlyMatch
          ? ''
          : line.slice(0, startCol);
        middle = line.slice(startCol, endCol);
        end = onlyMatch
          ? ''
          : line.slice(endCol);
        res$.push(start + "" + highlight(middle) + end);
      } else if (resStartLine < lineNum && lineNum < resEndLine) {
        res$.push(highlight(line));
      } else if (lineNum === resStartLine) {
        start = onlyMatch
          ? ''
          : line.slice(0, startCol);
        rest = line.slice(startCol);
        res$.push(start + "" + highlight(rest));
      } else {
        end = onlyMatch
          ? ''
          : line.slice(endCol);
        rest = line.slice(0, endCol);
        res$.push(highlight(rest) + "" + end);
      }
    }
    outputLines = res$;
    cleanLines = (onlyMatch ? compact : id)(outputLines);
    multiline = cleanLines.length > 1;
    outputString = unlines(cleanLines);
    displayStartLine = node.loc.start.line;
    displayEndLine = node.loc.end.line;
    locationString = options.colNumber
      ? color.green((options.lineNumber ? displayStartLine + "," : '') + "" + startCol) + "" + color.cyan('-') + "" + color.green((options.lineNumber ? displayEndLine + "," : '') + "" + (endCol - 1))
      : options.lineNumber ? multiline
        ? displayStartLine === displayEndLine
          ? color.green(displayStartLine)
          : color.green(displayStartLine) + "" + color.green('-') + "" + color.green(displayEndLine)
        : color.green(displayStartLine) : '';
    separatorString = (multiline ? color.cyan((locationString.length ? ':' : '') + "(multiline)") : '') + "" + (locationString.length || multiline ? color.cyan(':') : '') + "" + (multiline ? '\n' : '');
    nameString = options.displayFilename ? formatName(color, name) + "" + color.cyan(':') : '';
    return nameString + "" + locationString + "" + separatorString + "" + outputString;
  }
  function formatName(color, name){
    return color.magenta(name);
  }
  function formatCount(color, count, name){
    return (name ? formatName(color, name) + "" + color.cyan(':') : '') + "" + count;
  }
}).call(this);

},{"prelude-ls":91}],13:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var ref$, map, flatten, join, lines, unlines, chars, unchars, syntax, syntaxFlat, aliasMap, attrMapInverse, matchesMap, matchesAliasMap, pad, options, generateSyntaxHelp, generateSyntaxHelpForNode, generateCategoryHelp, generateHelpForCategory;
  ref$ = require('prelude-ls'), map = ref$.map, flatten = ref$.flatten, join = ref$.join, lines = ref$.lines, unlines = ref$.unlines, chars = ref$.chars, unchars = ref$.unchars;
  ref$ = require('grasp-syntax-javascript'), syntax = ref$.syntax, syntaxFlat = ref$.syntaxFlat, aliasMap = ref$.aliasMap, attrMapInverse = ref$.attrMapInverse, matchesMap = ref$.matchesMap, matchesAliasMap = ref$.matchesAliasMap;
  pad = require('./text').pad;
  options = require('./options').options;
  generateSyntaxHelp = function(){
    var maxNameLen, syntaxInfo, res$, category, ref$, nodesInCat, lresult$, nodeName, ref1$, alias, nodes, ref2$, nodeArrays, primitives, getFieldStrings, fieldStrings, nameString, nameStringLen, syntaxInfoStrings, i$, len$, nodesInfo, nodeStrings, prepend, append;
    maxNameLen = 0;
    res$ = [];
    for (category in ref$ = syntax) {
      nodesInCat = ref$[category];
      lresult$ = [];
      for (nodeName in nodesInCat) {
        ref1$ = nodesInCat[nodeName], alias = ref1$.alias, nodes = (ref2$ = ref1$.nodes) != null
          ? ref2$
          : [], nodeArrays = (ref2$ = ref1$.nodeArrays) != null
          ? ref2$
          : [], primitives = (ref2$ = ref1$.primitives) != null
          ? ref2$
          : [];
        getFieldStrings = fn$;
        fieldStrings = getFieldStrings('', nodes).concat(getFieldStrings('%', nodeArrays), getFieldStrings('&', primitives));
        nameString = alias + " (" + nodeName + ")";
        nameStringLen = nameString.length;
        if (nameStringLen > maxNameLen) {
          maxNameLen = nameStringLen;
        }
        lresult$.push([nameString, fieldStrings.join(', ')]);
      }
      res$.push(lresult$);
    }
    syntaxInfo = res$;
    res$ = [];
    for (i$ = 0, len$ = syntaxInfo.length; i$ < len$; ++i$) {
      nodesInfo = syntaxInfo[i$];
      nodeStrings = map(fn1$, nodesInfo);
      res$.push("\n" + unlines(nodeStrings));
    }
    syntaxInfoStrings = res$;
    prepend = 'JavaScript abstract syntax help:\na list of possible node types, and their fields\n`--help node-name` for more information about a node\n`--help categories` for information about categories of nodes\n\nnode-name (FullOfficialName)   field1, field2 (alias), field3...\nfield  - this field contains another node\n%field - this field contains an array of other nodes\n&field - this field contains a primitive value, such as a boolean or a string\n-----------------------------';
    append = 'Based on the Mozilla Parser API <https://developer.mozilla.org/docs/SpiderMonkey/Parser_API>';
    return prepend + "" + unlines(syntaxInfoStrings) + "\n\n" + append;
    function fn$(type, fields){
      return map(function(it){
        var that;
        if (that = attrMapInverse[it]) {
          return type + "" + it + " (" + type + that.join(", " + type) + ")";
        } else {
          return type + "" + it;
        }
      }, fields);
    }
    function fn1$(it){
      return pad(it[0], maxNameLen) + "  " + it[1];
    }
  };
  generateSyntaxHelpForNode = function(nodeName){
    var ref$, alias, nodes, nodeArrays, primitives, syntax, example, note, nameStr, strs, res$, i$, len$, ref1$, type, fields, syntaxStr, exampleStr, examples, ex, line, noteStr;
    ref$ = syntaxFlat[nodeName], alias = ref$.alias, nodes = ref$.nodes, nodeArrays = ref$.nodeArrays, primitives = ref$.primitives, syntax = ref$.syntax, example = ref$.example, note = ref$.note;
    nameStr = alias + " (" + nodeName + ")";
    res$ = [];
    for (i$ = 0, len$ = (ref$ = [['node', nodes], ['node array', nodeArrays], ['primitive', primitives]]).length; i$ < len$; ++i$) {
      ref1$ = ref$[i$], type = ref1$[0], fields = ref1$[1];
      if (fields) {
        res$.push("\n" + type + " fields: " + map(fn$, fields).join(', '));
      }
    }
    strs = res$;
    syntaxStr = syntax ? "\nsyntax:\n" + unlines(map(function(it){
      return "  " + it;
    }, lines(syntax))) : '';
    exampleStr = example ? (examples = (function(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = [].concat(example)).length; i$ < len$; ++i$) {
        ex = ref$[i$];
        results$.push(unlines((fn$())));
      }
      return results$;
      function fn$(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = lines(ex)).length; i$ < len$; ++i$) {
          line = ref$[i$];
          results$.push("  " + line);
        }
        return results$;
      }
    }()), "\nexample" + (examples.length > 1 ? 's' : '') + ":\n" + unlines(examples)) : '';
    noteStr = note ? "\nnote: " + note : '';
    return nameStr + "\n" + repeatString$('=', nameStr.length) + unchars(strs) + syntaxStr + exampleStr + noteStr;
    function fn$(it){
      var that;
      if (that = attrMapInverse[it]) {
        return it + " (alias: " + that.join(', ') + ")";
      } else {
        return it;
      }
    }
  };
  generateCategoryHelp = function(){
    var categories, res$, alias, ref$, category, fullNodeNames, names, prepend, append;
    res$ = [];
    for (alias in ref$ = matchesAliasMap) {
      category = ref$[alias];
      fullNodeNames = matchesMap[category];
      names = map(fn$, fullNodeNames);
      res$.push(alias + " (" + category + "): " + names.join(', '));
    }
    categories = res$;
    prepend = 'Categories of node types:';
    append = '`--help syntax` for node information.\n`--help category-name` for further information about a category.';
    return prepend + "\n\n" + unlines(categories) + "\n\n" + append;
    function fn$(it){
      return syntaxFlat[it].alias;
    }
  };
  generateHelpForCategory = function(name){
    var invertedAliases, res$, key, ref$, value, alias, fullNodeNames, names, nameStr;
    res$ = {};
    for (key in ref$ = matchesAliasMap) {
      value = ref$[key];
      res$[value] = key;
    }
    invertedAliases = res$;
    alias = invertedAliases[name];
    fullNodeNames = matchesMap[name];
    names = map(function(it){
      return syntaxFlat[it].alias + " (" + it + ")";
    }, fullNodeNames);
    nameStr = alias + " (" + name + ")";
    return "A node type category.\n\n" + nameStr + "\n" + repeatString$('=', nameStr.length) + "\n" + unlines(names);
  };
  module.exports = function(generateHelp, generateHelpForOption, positional){
    var helpStrings, res$, i$, len$, arg, lresult$, that, dashes, optionName, j$, ref$, len1$, o, item, sep, name;
    if (positional.length) {
      res$ = [];
      for (i$ = 0, len$ = positional.length; i$ < len$; ++i$) {
        arg = positional[i$];
        lresult$ = [];
        if (arg === 'advanced') {
          lresult$.push(generateHelp({
            showHidden: true
          }));
        } else if (that = /^(--?)(\S+)/.exec(arg)) {
          dashes = that[1], optionName = that[2];
          if (dashes.length === 2) {
            lresult$.push(generateHelpForOption(optionName));
          } else {
            for (j$ = 0, len1$ = (ref$ = chars(optionName)).length; j$ < len1$; ++j$) {
              o = ref$[j$];
              lresult$.push(generateHelpForOption(o));
            }
          }
        } else if (arg === 'more') {
          lresult$.push(generateHelpForOption('help'));
        } else if (arg === 'verbose') {
          for (j$ = 0, len1$ = (ref$ = options).length; j$ < len1$; ++j$) {
            item = ref$[j$];
            if (that = item.heading) {
              sep = repeatString$('#', that.length + 4);
              lresult$.push(sep + "\n# " + that + " #\n" + sep);
            } else {
              lresult$.push(generateHelpForOption(item.option));
            }
          }
        } else if (arg === 'syntax') {
          lresult$.push(generateSyntaxHelp());
        } else if (arg === 'categories') {
          lresult$.push(generateCategoryHelp());
        } else {
          if (aliasMap[arg] || syntaxFlat[arg]) {
            name = aliasMap[arg] || arg;
            lresult$.push(generateSyntaxHelpForNode(name));
          } else if (matchesMap[arg] || matchesAliasMap[arg]) {
            name = matchesAliasMap[arg] || arg;
            lresult$.push(generateHelpForCategory(name));
          } else {
            lresult$.push("No such help option: " + arg + ".");
          }
        }
        res$.push(lresult$);
      }
      helpStrings = res$;
      return join('\n\n')(
      flatten(
      helpStrings));
    } else {
      return generateHelp();
    }
  };
  function repeatString$(str, n){
    for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
    return r;
  }
}).call(this);

},{"./options":15,"./text":17,"grasp-syntax-javascript":11,"prelude-ls":91}],14:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var path, clc, acorn, squery, equery, async, ref$, min, sortWith, lines, chars, split, join, map, Obj, format, formatResult, formatName, formatCount, replace, getOptions, help, _console, VERSION, run, getQueryEngine, slice$ = [].slice, toString$ = {}.toString;
  path = require('path');
  clc = require('cli-color');
  acorn = require('acorn');
  squery = require('grasp-squery');
  equery = require('grasp-equery');
  async = require('async');
  ref$ = require('prelude-ls'), min = ref$.min, sortWith = ref$.sortWith, lines = ref$.lines, chars = ref$.chars, split = ref$.split, join = ref$.join, map = ref$.map, Obj = ref$.Obj;
  format = require('./format'), formatResult = format.formatResult, formatName = format.formatName, formatCount = format.formatCount;
  replace = require('./replace').replace;
  getOptions = require('./options').getOptions;
  help = require('./help');
  _console = console;
  VERSION = '0.2.0';
  run = function(arg$){
    var ref$, args, error, ref1$, callback, exit, data, stdin, fs, input, console, options, positional, generateHelp, generateHelpForOption, e, debug, versionString, getHelp, helpString, queryEngine, parser, parserOptions, that, selector, targets, targetsLen, replacement, isDir, color, bold, textFormatFuncs, resultsData, resultsFormat, callCallback, out, parsedSelector, resultsSortFunc, search, processResults, getToMap, end, extTestRegex, testExt, targetPaths, searchTarget, cwd;
    ref$ = arg$ != null
      ? arg$
      : {}, args = ref$.args, error = (ref1$ = ref$.error) != null
      ? ref1$
      : function(it){
        throw new Error(it);
      }, callback = (ref1$ = ref$.callback) != null
      ? ref1$
      : function(){}, exit = (ref1$ = ref$.exit) != null
      ? ref1$
      : function(){}, data = (ref1$ = ref$.data) != null ? ref1$ : false, stdin = ref$.stdin, fs = (ref1$ = ref$.fs) != null
      ? ref1$
      : require('fs'), input = ref$.input, console = (ref1$ = ref$.console) != null ? ref1$ : _console;
    if (args == null) {
      error('Error: Must specify arguments.');
      exit(2);
      return;
    }
    try {
      ref$ = getOptions(args, VERSION), options = ref$.options, positional = ref$.positional, generateHelp = ref$.generateHelp, generateHelpForOption = ref$.generateHelpForOption;
    } catch (e$) {
      e = e$;
      error(e.message);
      exit(2);
      return;
    }
    debug = options.debug;
    if (debug) {
      console.time('everything');
      console.log('options:');
      console.log(options);
    }
    if (options.version) {
      versionString = "grasp v" + VERSION;
      callback(versionString);
      exit(0, versionString);
      return;
    }
    getHelp = function(positional){
      positional == null && (positional = []);
      return help(generateHelp, generateHelpForOption, positional);
    };
    if (options.help) {
      helpString = getHelp(positional);
      callback(helpString);
      exit(0, helpString);
      return;
    }
    queryEngine = options.engine
      ? require(options.engine)
      : options.squery
        ? squery
        : options.equery ? equery : squery;
    ref$ = (function(){
      switch (options.parser[0]) {
      case 'acorn':
        return [acorn, options.parser[1]];
      default:
        return [require(options.parser[0]), options.parser[1]];
      }
    }()), parser = ref$[0], parserOptions = ref$[1];
    options.context == null && (options.context = (ref$ = options.NUM) != null ? ref$ : 0);
    options.beforeContext == null && (options.beforeContext = options.context);
    options.afterContext == null && (options.afterContext = options.context);
    if (that = options.file) {
      try {
        selector = fs.readFileSync(that, 'utf8');
      } catch (e$) {
        e = e$;
        error("Error: No such file '" + options.file + "'.");
        exit(2);
        return;
      }
      targets = positional;
    } else {
      selector = positional[0];
      targets = slice$.call(positional, 1);
    }
    if (!targets.length) {
      targets = options.recursive
        ? ['.']
        : ['-'];
    }
    targetsLen = targets.length;
    if (that = options.replace) {
      replacement = that;
    } else if (that = options.replaceFile) {
      try {
        replacement = fs.readFileSync(that, 'utf8').replace(/([\s\S]*)\n$/, '$1');
      } catch (e$) {
        e = e$;
        error("Error: No such file '" + options.replaceFile + "'.");
        exit(2);
        return;
      }
    }
    if (selector == null) {
      error('Error: No selector specified.');
      helpString = getHelp();
      callback(helpString);
      exit(2, helpString);
      return;
    }
    if ((that = options.filename) != null) {
      options.displayFilename = that;
    } else if (targetsLen > 1) {
      options.displayFilename = true;
    } else {
      try {
        isDir = targets[0] === '-'
          ? false
          : fs.lstatSync(targets[0]).isDirectory();
        if (isDir && !options.recursive) {
          console.warn("'" + targets[0] + "' is a directory. Use '-r, --recursive' to recursively search directories.");
        }
        options.displayFilename = isDir;
      } catch (e$) {
        e = e$;
        error("Error: No such file or directory '" + targets[0] + "'.");
        exit(2);
        return;
      }
    }
    color = Obj.map(function(it){
      if (options.color) {
        return it;
      } else {
        return function(it){
          return it + "";
        };
      }
    }, {
      green: clc.green,
      cyan: clc.cyan,
      magenta: clc.magenta,
      red: clc.red
    });
    bold = clc.bold;
    textFormatFuncs = {
      color: color,
      bold: bold
    };
    resultsData = [];
    resultsFormat = 'default';
    callCallback = !options.quiet && !options.json && !options.to && !options.inPlace;
    out = function(it){
      resultsData.push(it);
      if (callCallback) {
        callback(it);
      }
    };
    if (debug) {
      console.time('parse-selector');
    }
    parsedSelector = queryEngine.parse(selector);
    if (debug) {
      console.timeEnd('parse-selector');
      console.log('parsed-selector:');
      console.log(JSON.stringify(parsedSelector));
    }
    resultsSortFunc = function(a, b){
      var aStart, bStart, lineDiff;
      aStart = a.loc.start;
      bStart = b.loc.start;
      lineDiff = aStart.line - bStart.line;
      if (lineDiff === 0) {
        return aStart.column - bStart.column;
      } else {
        return lineDiff;
      }
    };
    search = function(name, input){
      var cleanInput, parsedInput, e, results, resultsLen, count, that, sortedResults, slicedResults, replaced, inputLines, inputLinesLength, i$, len$, result;
      if (debug) {
        console.time("search-total:" + name);
      }
      cleanInput = input.replace(/^#!.*\n/, '');
      try {
        if (debug) {
          console.time("parse-input:" + name);
        }
        parsedInput = parser.parse(cleanInput, parserOptions);
        if (debug) {
          console.timeEnd("parse-input:" + name);
        }
      } catch (e$) {
        e = e$;
        throw new Error("Error: Could not parse JavaScript from '" + name + "'. " + e.message);
      }
      if (debug) {
        console.time("query:" + name);
      }
      results = queryEngine.queryParsed(parsedSelector, parsedInput);
      if (debug) {
        console.timeEnd("query:" + name);
      }
      resultsLen = results.length;
      count = (that = options.maxCount) != null ? min(that, resultsLen) : resultsLen;
      sortedResults = sortWith(resultsSortFunc, results);
      slicedResults = slice$.call(sortedResults, 0, count);
      if (replacement != null) {
        try {
          replaced = replace(replacement, cleanInput, slicedResults, queryEngine);
          if (options.to || options.inPlace) {
            resultsFormat = 'pairs';
            out([name, replaced]);
          } else {
            out(replaced);
          }
        } catch (e$) {
          e = e$;
          console.error(name + ": Error during replacement. " + e.message + ".");
        }
      } else if (options.count) {
        if (options.displayFilename) {
          if (options.json || data) {
            resultsFormat = 'pairs';
            out([name, count]);
          } else {
            out(formatCount(color, count, name));
          }
        } else {
          out(options.json || data
            ? count
            : formatCount(color, count));
        }
      } else if (options.filesWithoutMatch || options.filesWithMatches) {
        if (options.filesWithMatches && count || options.filesWithoutMatch && !count) {
          out(options.json || data
            ? name
            : formatName(color, name));
        }
      } else {
        if (options.json || data) {
          if (options.displayFilename) {
            resultsFormat = 'pairs';
            out([name, slicedResults]);
          } else {
            resultsFormat = 'lists';
            out(slicedResults);
          }
        } else {
          inputLines = lines(cleanInput);
          inputLinesLength = cleanInput.length;
          for (i$ = 0, len$ = slicedResults.length; i$ < len$; ++i$) {
            result = slicedResults[i$];
            out(formatResult(name, inputLines, inputLinesLength, textFormatFuncs, options, result));
          }
        }
      }
      if (debug) {
        console.timeEnd("search-total:" + name);
      }
    };
    processResults = function(){
      if (resultsData.length) {
        if (resultsFormat === 'pairs') {
          return Obj.pairsToObj(resultsData);
        } else if (resultsFormat === 'lists') {
          if (targetsLen === 1) {
            return resultsData[0];
          } else {
            return resultsData;
          }
        } else {
          return resultsData;
        }
      } else {
        return [];
      }
    };
    getToMap = function(inputPaths){
      var mapping, i$, len$, inputPath;
      if (options.inPlace) {
        return Obj.listsToObj(inputPaths, inputPaths);
      } else if (toString$.call(options.to).slice(8, -1) === 'Object') {
        return options.to;
      } else {
        mapping = {};
        for (i$ = 0, len$ = inputPaths.length; i$ < len$; ++i$) {
          inputPath = inputPaths[i$];
          mapping[inputPath] = options.to.replace(/%/, path.basename(inputPath, path.extname(inputPath)));
        }
        return mapping;
      }
    };
    end = function(inputPaths){
      var exitCode, processedResults, toMap, inputPath, contents, targetPath, jsonString;
      exitCode = resultsData.length ? 0 : 1;
      processedResults = processResults();
      if (replacement && options.to || options.inPlace) {
        toMap = getToMap(inputPaths);
        for (inputPath in processedResults) {
          contents = processedResults[inputPath];
          targetPath = toMap[inputPath];
          if (targetPath === '-') {
            callback(contents);
          } else {
            if (targetPath) {
              fs.writeFileSync(targetPath, contents);
            }
          }
        }
      } else if (options.json) {
        jsonString = JSON.stringify(processedResults);
        callback(jsonString);
      }
      if (debug) {
        console.timeEnd('everything');
      }
      return exit(exitCode, options.json ? jsonString : processedResults);
    };
    extTestRegex = RegExp('(?:' + options.extensions.join('|') + ')$');
    testExt = function(filename){
      return filename.match(extTestRegex);
    };
    targetPaths = [];
    searchTarget = function(basePath, upPath){
      return function(target, done){
        var output, targetPath, stat, fileContents, displayPath, e;
        try {
          if (target === '-') {
            if (!stdin) {
              throw new Error('Error: stdin not defined.');
            }
            targetPaths.push('-');
            output = '';
            stdin.setEncoding('utf-8');
            stdin.on('data', (function(it){
              return output += it;
            }));
            stdin.on('end', function(){
              var e;
              try {
                search('(standard input)', output);
              } catch (e$) {
                e = e$;
                console.error(e.message);
              }
              return done();
            });
            stdin.resume();
          } else {
            targetPath = path.resolve(upPath, target);
            stat = fs.lstatSync(targetPath);
            if (stat.isDirectory() && options.recursive) {
              async.eachSeries(fs.readdirSync(targetPath), searchTarget(basePath, targetPath), function(){
                return done();
              });
            } else if (stat.isFile() && testExt(target)) {
              fileContents = fs.readFileSync(targetPath, 'utf8');
              displayPath = path.relative(basePath, targetPath);
              targetPaths.push(displayPath);
              search(displayPath, fileContents);
              done();
            } else {
              done();
            }
          }
        } catch (e$) {
          e = e$;
          console.error(e.message);
          done();
        }
      };
    };
    if (input) {
      search('(input)', input);
      return end(['-']);
    } else {
      cwd = process.cwd();
      async.eachSeries(targets, searchTarget(cwd, cwd), function(){
        return end(targetPaths);
      });
    }
  };
  getQueryEngine = function(it){
    return {
      squery: 'grasp-squery',
      equery: 'grasp-equery'
    }[it] || it;
  };
  run.VERSION = VERSION;
  run.search = curry$(function(engine, selector, input){
    return run({
      args: {
        _: [selector],
        engine: getQueryEngine(engine)
      },
      input: input,
      data: true,
      exit: function(arg$, results){
        return results;
      }
    });
  });
  run.replace = curry$(function(engine, selector, replacement, input){
    return run({
      args: {
        _: [selector],
        engine: getQueryEngine(engine),
        replace: replacement
      },
      input: input,
      exit: function(arg$, results){
        return results;
      }
    });
  });
  module.exports = run;
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);

},{"./format":12,"./help":13,"./options":15,"./replace":16,"acorn":18,"async":19,"cli-color":22,"fs":7,"grasp-equery":67,"grasp-squery":71,"path":8,"prelude-ls":91}],15:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var optionator, options, getOptions;
  optionator = require('optionator');
  options = [
    {
      heading: 'Miscellaneous'
    }, {
      option: 'help',
      alias: 'h',
      type: 'Boolean',
      description: "display this help and exit '--help more' for more help info",
      longDescription: '`--help` displays help for options\n`-h` may be used at any time in place of `--help`\n`--help more` displays this help\n`--help --option-name` displays further help for that option\nfor example: `--help --help` would display this information\n`--help verbose` displays the same help as `--help --option-name`, but for all options\n`--help syntax` displays information about JavaScript\'s syntax\n`--help node-name` displays further information about a JavaScript node\nfor example: `--help if` displays more information about an if statement\n`--help categories` displays information about node type categories\n`--help category-name` displays further information about a node type category\n`--help advanced` displays help for all options, including those hidden by default',
      example: ['--help', '--help --replace', '--help -R', '--help syntax'],
      restPositional: true
    }, {
      option: 'version',
      alias: 'v',
      type: 'Boolean',
      description: 'print version information and exit'
    }, {
      option: 'debug',
      alias: 'd',
      type: 'Boolean',
      description: 'output debug information'
    }, {
      option: 'extensions',
      alias: 'x',
      type: '[String]',
      description: 'comma separated list of acceptable file extensions',
      longDescription: "A comma separated list of acceptable file extensions. Use a dot `.` for any extension.",
      example: ['--extensions js,json', '--extensions .'],
      'default': 'js'
    }, {
      option: 'recursive',
      alias: 'r',
      type: 'Boolean',
      description: 'recursively search directories',
      longDescription: "Recursively search directories. If files or paths are left out, then `.` is assumed."
    }, {
      option: 'parser',
      alias: 'p',
      type: '(path::String, options::Maybe Object)',
      description: 'require path for parser, using options when calling parse',
      longDescription: 'Sets the parser and options for the parser. Argument value is a tuple, with the first item being the require path, and the second an optional object with options for the parser when calling its parse function.',
      'default': '(acorn, {locations: true})',
      hidden: true,
      example: '--parser "(./path/to/esprima, {loc: true})"'
    }, {
      heading: 'Replacement'
    }, {
      option: 'replace',
      alias: 'R',
      type: 'replacement::String',
      description: "replace each match with replacement, use `--help --replace` for more info",
      longDescription: 'Each node that is matched will be replaced with the text that you input. There are a couple of special cases:\nThe text `{{}}` will be replaced with the source of the matched node.\n`{{selector}}` will be replaced with the first result of querying the matched node with the selector. If you used equery to get the results, then the replacement selector will be parsed as equery.\nSince positional arguments may appear anywhere, you can place the `--replace replacement` after the selector if you wish, eg. `selector --replace replacement file.js`.\nBy default, the result of using `--replace` will be to print out the results - if you wish to create new file(s) you can check out the `--to` option, or if you wish to edit the input file(s) in place, take a look at the `--in-place` option.',
      example: ['--replace foo', "--replace 'f({{}})'", "--replace 'while ({{.test}}) {\\n{{.then call}};\\n}'"]
    }, {
      option: 'replace-file',
      alias: 'F',
      type: 'file::String',
      description: 'replace each match with contents of file',
      example: '--replace-file path/to/file'
    }, {
      option: 'to',
      alias: 't',
      type: 'Object | String',
      description: "write replaced output to file(s), `--help --to` for more info",
      longDescription: 'If an object, the keys are the paths to the input files, and the values are the corresponding output paths.\nIf a string, then the output is written to the path specified. The special character `%` is expanded to the current input file\'s filename.',
      example: ['--to "{input.js: output.js, path/to/input2.js: path/to/output2.js}"', '--to "output/%.js"']
    }, {
      option: 'in-place',
      alias: 'i',
      type: 'Boolean',
      description: "overwrite input files with replaced output"
    }, {
      heading: 'Selector interpretation'
    }, {
      option: 'engine',
      alias: 'g',
      type: 'path::String',
      description: 'require path for query engine',
      longDescription: "The require path for the query engine. The query engine must have `parse(selector) -> parsedSelector`, `queryParsed(parsedSelector, ast) -> results`, and `query(selector, ast) -> results` functions exposed.",
      hidden: true,
      example: '--engine path/to/engine'
    }, {
      option: 'squery',
      alias: 's',
      type: 'Boolean',
      description: "use squery - selector query - css style selectors"
    }, {
      option: 'equery',
      alias: 'e',
      type: 'Boolean',
      description: "use equery - example query - use code example with wildcards",
      longDescription: "Use equery - example query - instead of the default squery. Use by typing in an example of the code you want (formatting is irrelevant), with optional wildcards. It is less powerful, but may be easier to use for simpler tasks, than squery. For more information, use `--help equery`."
    }, {
      option: 'file',
      alias: 'f',
      type: 'file::String',
      description: 'obtain selector from file',
      example: '--file path/to/selector-file'
    }, {
      heading: 'Output control'
    }, {
      option: 'max-count',
      alias: 'm',
      type: 'n::Int',
      description: 'stop after n matches',
      example: '--max-count 2'
    }, {
      option: 'line-number',
      alias: 'n',
      type: 'Boolean',
      'default': 'true',
      description: 'print line number with output lines'
    }, {
      option: 'col-number',
      alias: 'b',
      type: 'Boolean',
      description: 'print column number with output lines'
    }, {
      option: 'filename',
      alias: 'H',
      type: 'Boolean',
      description: 'print the file name for each match (opposite: `--no-filename`)'
    }, {
      option: 'only-matching',
      alias: 'o',
      type: 'Boolean',
      description: 'show only the matching part of the line(s)'
    }, {
      option: 'quiet',
      alias: ['q', 'silent'],
      type: 'Boolean',
      description: 'suppress all normal output'
    }, {
      option: 'files-without-match',
      alias: 'W',
      type: 'Boolean',
      description: 'print only names of files containing no match'
    }, {
      option: 'files-with-matches',
      alias: 'w',
      type: 'Boolean',
      description: 'print only names of files containing matches'
    }, {
      option: 'count',
      alias: 'c',
      type: 'Boolean',
      description: 'print only a count of matches per file'
    }, {
      option: 'color',
      alias: ['O', 'colour'],
      type: 'Boolean',
      'default': 'true',
      description: 'use color to highlight matches'
    }, {
      option: 'json',
      alias: 'j',
      type: 'Boolean',
      description: 'JSON output for matches',
      longDescription: 'Prints out JSON for the output instead of formatted results. This will print out the node data as JSON, instead of the formatted text.'
    }, {
      heading: 'Context control'
    }, {
      option: 'before-context',
      alias: 'B',
      type: 'n::Int',
      description: 'print n lines of leading context',
      example: ['--before-context 3', '-B 3']
    }, {
      option: 'after-context',
      alias: 'A',
      type: 'n::Int',
      description: 'print n lines of trailing context',
      example: ['--after-context 2', '-A 2']
    }, {
      option: 'context',
      alias: 'C',
      type: 'n::Int',
      description: 'print n lines of output context',
      example: ['--context 1', '-C 1']
    }, {
      option: 'NUM',
      type: 'Int',
      description: 'same as --context NUM',
      example: '-3'
    }
  ];
  getOptions = function(input, VERSION){
    var ref$, parse, generateHelp, generateHelpForOption, result;
    ref$ = optionator({
      prepend: 'Usage: grasp [option]... [selector] [file]...\n\nSearch (or --replace) for selector in file(s) or standard input.\nFor more help \'--help more\', \'--help --option-name\', \'--help syntax\'\nExample: grasp --context 2 \'if.test bi[op="<"]\' file.js file2.js',
      append: "Version " + VERSION + "\n<http://graspjs.com/>",
      mutuallyExclusive: [['replace', 'replace-file']],
      options: options
    }), parse = ref$.parse, generateHelp = ref$.generateHelp, generateHelpForOption = ref$.generateHelpForOption;
    result = parse(input);
    return {
      options: result,
      positional: result._,
      generateHelp: generateHelp,
      generateHelpForOption: generateHelpForOption
    };
  };
  module.exports = {
    options: options,
    getOptions: getOptions
  };
}).call(this);

},{"optionator":75}],16:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var ref$, lines, unlines, filter, getRaw, argsRegex, filterRegex, replacer, processReplacement, replace, slice$ = [].slice;
  ref$ = require('prelude-ls'), lines = ref$.lines, unlines = ref$.unlines, filter = ref$.filter;
  getRaw = function(input, node){
    var raw, that;
    raw = (that = node.raw)
      ? that
      : node.start != null
        ? input.slice(node.start, node.end)
        : node.key != null && node.value != null ? input.slice(node.key.start, node.value.end) : '';
    return (node.rawPrepend || '') + "" + raw + (node.rawAppend || '');
  };
  argsRegex = /'((?:\\'|[^'])*)'|"((?:\\"|[^"])*)"|(\\.)|(\S+)/g;
  filterRegex = /\s+\|\s+([-a-zA-Z]+)((?:\s+(?:'(?:\\'|[^'])*'|"(?:\\"|[^"])*"|[^\|\s]+))*)/;
  replacer = function(input, node, queryEngine){
    return function(arg$, replacementArg){
      var ref$, selector, filters, that, origResults, e, results, rawPrepend, rawAppend, join, filterName, argsStr, args, pre, post, i$, len$, arg, result, n, len, rawResults, res$;
      ref$ = replacementArg.trim().split(filterRegex), selector = ref$[0], filters = slice$.call(ref$, 1);
      if (that = (ref$ = node._named) != null ? ref$[selector] : void 8) {
        origResults = [].concat(that);
      } else {
        try {
          origResults = queryEngine.query(selector, node);
        } catch (e$) {
          e = e$;
          origResults = queryEngine.query(replacementArg, node);
          filters = [];
        }
      }
      if (origResults.length) {
        results = origResults;
        rawPrepend = '';
        rawAppend = '';
        join = null;
        while (filters.length) {
          filterName = filters.shift();
          argsStr = filters.shift().trim();
          argsStr += filters.shift();
          args = [];
          if (argsStr) {
            while (that = argsRegex.exec(argsStr)) {
              args.push(filter(fn$, that)[1].replace(/\\(.)/g, '$1'));
            }
            argsRegex.lastIndex = 0;
          }
          if ((filterName === 'prepend' || filterName === 'before' || filterName === 'after' || filterName === 'prepend' || filterName === 'append' || filterName === 'wrap' || filterName === 'nth' || filterName === 'nth-last' || filterName === 'slice' || filterName === 'each') && !args.length) {
            throw new Error("No arguments supplied for '" + filterName + "' filter");
          }
          switch (filterName) {
          case 'join':
            join = args.length ? args[0] : '';
            break;
          case 'before':
            rawPrepend = args[0] + "" + rawPrepend;
            break;
          case 'after':
            rawAppend += args[0];
            break;
          case 'wrap':
            ref$ = args.length === 1 ? [args[0], args[0]] : args, pre = ref$[0], post = ref$[1];
            rawPrepend = pre + "" + rawPrepend;
            rawAppend += post;
            break;
          case 'prepend':
            for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
              arg = args[i$];
              results.unshift({
                type: 'Raw',
                raw: arg
              });
            }
            break;
          case 'append':
            for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
              arg = args[i$];
              results.push({
                type: 'Raw',
                raw: arg
              });
            }
            break;
          case 'each':
            if (args.length < 2) {
              throw new Error("No arguments supplied for 'each " + args[0] + "'");
            }
            switch (args[0]) {
            case 'before':
              for (i$ = 0, len$ = results.length; i$ < len$; ++i$) {
                result = results[i$];
                result.rawPrepend = args[1] + "" + (result.rawPrepend || '');
              }
              break;
            case 'after':
              for (i$ = 0, len$ = results.length; i$ < len$; ++i$) {
                result = results[i$];
                result.rawAppend = (result.rawAppend || '') + "" + args[1];
              }
              break;
            case 'wrap':
              ref$ = args.length === 2
                ? [args[1], args[1]]
                : [args[1], args[2]], pre = ref$[0], post = ref$[1];
              for (i$ = 0, len$ = results.length; i$ < len$; ++i$) {
                result = results[i$];
                result.rawPrepend = pre + "" + (result.rawPrepend || '');
                result.rawAppend = (result.rawAppend || '') + "" + post;
              }
              break;
            default:
              throw new Error("'" + args[0] + "' is not supported by 'each'");
            }
            break;
          case 'nth':
            n = +args[0];
            results = results.slice(n, n + 1);
            break;
          case 'nth-last':
            n = results.length - +args[0] - 1;
            results = results.slice(n, n + 1);
            break;
          case 'first':
          case 'head':
            results = results.slice(0, 1);
            break;
          case 'tail':
            results = results.slice(1);
            break;
          case 'last':
            len = results.length;
            results = results.slice(len - 1, len);
            break;
          case 'initial':
            results = results.slice(0, results.length - 1);
            break;
          case 'slice':
            results = [].slice.apply(results, args);
            break;
          case 'reverse':
            results.reverse();
            break;
          default:
            throw new Error("Invalid filter: " + filterName + (argsStr ? " " + argsStr : ''));
          }
        }
        res$ = [];
        for (i$ = 0, len$ = results.length; i$ < len$; ++i$) {
          result = results[i$];
          res$.push(getRaw(input, result));
        }
        rawResults = res$;
        return rawPrepend + "" + (join != null
          ? rawResults.join(join)
          : rawResults[0]) + rawAppend;
      } else {
        return '';
      }
      function fn$(it){
        return it != null;
      }
    };
  };
  processReplacement = function(replacement, input, node, queryEngine){
    return replacement.replace(/\\n/g, '\n').replace(/{{}}/g, getRaw(input, node)).replace(/{{((?:[^}]|}[^}])+)}}/g, replacer(input, node, queryEngine));
  };
  replace = function(replacement, input, nodes, queryEngine){
    var inputLines, colOffset, lineOffset, lastLine, prevNode, i$, len$, node, ref$, start, end, startLineNum, endLineNum, numberOfLines, startCol, endCol, replaceLines, startLine, endLine, startContext, endContext, replaceLast, endLen;
    inputLines = lines(input);
    colOffset = 0;
    lineOffset = 0;
    lastLine = null;
    prevNode = {
      end: 0
    };
    for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
      node = nodes[i$];
      if (node.start < prevNode.end) {
        continue;
      }
      ref$ = node.loc, start = ref$.start, end = ref$.end;
      startLineNum = start.line - 1 + lineOffset;
      endLineNum = end.line - 1 + lineOffset;
      numberOfLines = endLineNum - startLineNum + 1;
      colOffset = lastLine === startLineNum ? colOffset : 0;
      startCol = start.column + colOffset;
      endCol = end.column + (startLineNum === endLineNum ? colOffset : 0);
      replaceLines = lines(processReplacement(replacement, input, node, queryEngine));
      startLine = inputLines[startLineNum];
      endLine = inputLines[endLineNum];
      startContext = startLine.slice(0, startCol);
      endContext = endLine.slice(endCol);
      replaceLines[0] = startContext + "" + replaceLines[0];
      replaceLast = replaceLines[replaceLines.length - 1];
      endLen = replaceLast.length;
      replaceLines[replaceLines.length - 1] = replaceLast + "" + endContext;
      inputLines.splice.apply(inputLines, [startLineNum, numberOfLines].concat(slice$.call(replaceLines)));
      lineOffset += replaceLines.length - numberOfLines;
      colOffset = endLen - endCol;
      lastLine = endLineNum + lineOffset;
      prevNode = node;
    }
    return unlines(inputLines).replace(/\n$/, '');
  };
  module.exports = {
    replace: replace
  };
}).call(this);

},{"prelude-ls":91}],17:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var pad;
  pad = function(str, num){
    var len, padAmount;
    len = str.length;
    padAmount = num - len;
    return str + "" + repeatString$(' ', padAmount > 0 ? padAmount : 0);
  };
  module.exports = {
    pad: pad
  };
  function repeatString$(str, n){
    for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
    return r;
  }
}).call(this);

},{}],18:[function(require,module,exports){
// Acorn is a tiny, fast JavaScript parser written in JavaScript.
//
// Acorn was written by Marijn Haverbeke and released under an MIT
// license. The Unicode regexps (for identifiers and whitespace) were
// taken from [Esprima](http://esprima.org) by Ariya Hidayat.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/marijnh/acorn.git
//
// Please use the [github bug tracker][ghbt] to report issues.
//
// [ghbt]: https://github.com/marijnh/acorn/issues
//
// This file defines the main parser interface. The library also comes
// with a [error-tolerant parser][dammit] and an
// [abstract syntax tree walker][walk], defined in other files.
//
// [dammit]: acorn_loose.js
// [walk]: util/walk.js

(function(root, mod) {
  if (typeof exports == "object" && typeof module == "object") return mod(exports); // CommonJS
  if (typeof define == "function" && define.amd) return define(["exports"], mod); // AMD
  mod(root.acorn || (root.acorn = {})); // Plain browser env
})(this, function(exports) {
  "use strict";

  exports.version = "0.4.1";

  // The main exported interface (under `self.acorn` when in the
  // browser) is a `parse` function that takes a code string and
  // returns an abstract syntax tree as specified by [Mozilla parser
  // API][api], with the caveat that the SpiderMonkey-specific syntax
  // (`let`, `yield`, inline XML, etc) is not recognized.
  //
  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

  var options, input, inputLen, sourceFile;

  exports.parse = function(inpt, opts) {
    input = String(inpt); inputLen = input.length;
    setOptions(opts);
    initTokenState();
    return parseTopLevel(options.program);
  };

  // A second optional argument can be given to further configure
  // the parser process. These options are recognized:

  var defaultOptions = exports.defaultOptions = {
    // `ecmaVersion` indicates the ECMAScript version to parse. Must
    // be either 3 or 5. This
    // influences support for strict mode, the set of reserved words, and
    // support for getters and setter.
    ecmaVersion: 5,
    // Turn on `strictSemicolons` to prevent the parser from doing
    // automatic semicolon insertion.
    strictSemicolons: false,
    // When `allowTrailingCommas` is false, the parser will not allow
    // trailing commas in array and object literals.
    allowTrailingCommas: true,
    // By default, reserved words are not enforced. Enable
    // `forbidReserved` to enforce them.
    forbidReserved: false,
    // When `locations` is on, `loc` properties holding objects with
    // `start` and `end` properties in `{line, column}` form (with
    // line being 1-based and column 0-based) will be attached to the
    // nodes.
    locations: false,
    // A function can be passed as `onComment` option, which will
    // cause Acorn to call that function with `(block, text, start,
    // end)` parameters whenever a comment is skipped. `block` is a
    // boolean indicating whether this is a block (`/* */`) comment,
    // `text` is the content of the comment, and `start` and `end` are
    // character offsets that denote the start and end of the comment.
    // When the `locations` option is on, two more parameters are
    // passed, the full `{line, column}` locations of the start and
    // end of the comments.
    onComment: null,
    // Nodes have their start and end characters offsets recorded in
    // `start` and `end` properties (directly on the node, rather than
    // the `loc` object, which holds line/column data. To also add a
    // [semi-standardized][range] `range` property holding a `[start,
    // end]` array with the same numbers, set the `ranges` option to
    // `true`.
    //
    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
    ranges: false,
    // It is possible to parse multiple files into a single AST by
    // passing the tree produced by parsing the first file as
    // `program` option in subsequent parses. This will add the
    // toplevel forms of the parsed file to the `Program` (top) node
    // of an existing parse tree.
    program: null,
    // When `location` is on, you can pass this to record the source
    // file in every node's `loc` object.
    sourceFile: null,
    // This value, if given, is stored in every node, whether
    // `location` is on or off.
    directSourceFile: null
  };

  function setOptions(opts) {
    options = opts || {};
    for (var opt in defaultOptions) if (!Object.prototype.hasOwnProperty.call(options, opt))
      options[opt] = defaultOptions[opt];
    sourceFile = options.sourceFile || null;
  }

  // The `getLineInfo` function is mostly useful when the
  // `locations` option is off (for performance reasons) and you
  // want to find the line/column position for a given character
  // offset. `input` should be the code string that the offset refers
  // into.

  var getLineInfo = exports.getLineInfo = function(input, offset) {
    for (var line = 1, cur = 0;;) {
      lineBreak.lastIndex = cur;
      var match = lineBreak.exec(input);
      if (match && match.index < offset) {
        ++line;
        cur = match.index + match[0].length;
      } else break;
    }
    return {line: line, column: offset - cur};
  };

  // Acorn is organized as a tokenizer and a recursive-descent parser.
  // The `tokenize` export provides an interface to the tokenizer.
  // Because the tokenizer is optimized for being efficiently used by
  // the Acorn parser itself, this interface is somewhat crude and not
  // very modular. Performing another parse or call to `tokenize` will
  // reset the internal state, and invalidate existing tokenizers.

  exports.tokenize = function(inpt, opts) {
    input = String(inpt); inputLen = input.length;
    setOptions(opts);
    initTokenState();

    var t = {};
    function getToken(forceRegexp) {
      readToken(forceRegexp);
      t.start = tokStart; t.end = tokEnd;
      t.startLoc = tokStartLoc; t.endLoc = tokEndLoc;
      t.type = tokType; t.value = tokVal;
      return t;
    }
    getToken.jumpTo = function(pos, reAllowed) {
      tokPos = pos;
      if (options.locations) {
        tokCurLine = 1;
        tokLineStart = lineBreak.lastIndex = 0;
        var match;
        while ((match = lineBreak.exec(input)) && match.index < pos) {
          ++tokCurLine;
          tokLineStart = match.index + match[0].length;
        }
      }
      tokRegexpAllowed = reAllowed;
      skipSpace();
    };
    return getToken;
  };

  // State is kept in (closure-)global variables. We already saw the
  // `options`, `input`, and `inputLen` variables above.

  // The current position of the tokenizer in the input.

  var tokPos;

  // The start and end offsets of the current token.

  var tokStart, tokEnd;

  // When `options.locations` is true, these hold objects
  // containing the tokens start and end line/column pairs.

  var tokStartLoc, tokEndLoc;

  // The type and value of the current token. Token types are objects,
  // named by variables against which they can be compared, and
  // holding properties that describe them (indicating, for example,
  // the precedence of an infix operator, and the original name of a
  // keyword token). The kind of value that's held in `tokVal` depends
  // on the type of the token. For literals, it is the literal value,
  // for operators, the operator name, and so on.

  var tokType, tokVal;

  // Interal state for the tokenizer. To distinguish between division
  // operators and regular expressions, it remembers whether the last
  // token was one that is allowed to be followed by an expression.
  // (If it is, a slash is probably a regexp, if it isn't it's a
  // division operator. See the `parseStatement` function for a
  // caveat.)

  var tokRegexpAllowed;

  // When `options.locations` is true, these are used to keep
  // track of the current line, and know when a new line has been
  // entered.

  var tokCurLine, tokLineStart;

  // These store the position of the previous token, which is useful
  // when finishing a node and assigning its `end` position.

  var lastStart, lastEnd, lastEndLoc;

  // This is the parser's state. `inFunction` is used to reject
  // `return` statements outside of functions, `labels` to verify that
  // `break` and `continue` have somewhere to jump to, and `strict`
  // indicates whether strict mode is on.

  var inFunction, labels, strict;

  // This function is used to raise exceptions on parse errors. It
  // takes an offset integer (into the current `input`) to indicate
  // the location of the error, attaches the position to the end
  // of the error message, and then raises a `SyntaxError` with that
  // message.

  function raise(pos, message) {
    var loc = getLineInfo(input, pos);
    message += " (" + loc.line + ":" + loc.column + ")";
    var err = new SyntaxError(message);
    err.pos = pos; err.loc = loc; err.raisedAt = tokPos;
    throw err;
  }

  // Reused empty array added for node fields that are always empty.

  var empty = [];

  // ## Token types

  // The assignment of fine-grained, information-carrying type objects
  // allows the tokenizer to store the information it has about a
  // token in a way that is very cheap for the parser to look up.

  // All token type variables start with an underscore, to make them
  // easy to recognize.

  // These are the general types. The `type` property is only used to
  // make them recognizeable when debugging.

  var _num = {type: "num"}, _regexp = {type: "regexp"}, _string = {type: "string"};
  var _name = {type: "name"}, _eof = {type: "eof"};

  // Keyword tokens. The `keyword` property (also used in keyword-like
  // operators) indicates that the token originated from an
  // identifier-like word, which is used when parsing property names.
  //
  // The `beforeExpr` property is used to disambiguate between regular
  // expressions and divisions. It is set on all token types that can
  // be followed by an expression (thus, a slash after them would be a
  // regular expression).
  //
  // `isLoop` marks a keyword as starting a loop, which is important
  // to know when parsing a label, in order to allow or disallow
  // continue jumps to that label.

  var _break = {keyword: "break"}, _case = {keyword: "case", beforeExpr: true}, _catch = {keyword: "catch"};
  var _continue = {keyword: "continue"}, _debugger = {keyword: "debugger"}, _default = {keyword: "default"};
  var _do = {keyword: "do", isLoop: true}, _else = {keyword: "else", beforeExpr: true};
  var _finally = {keyword: "finally"}, _for = {keyword: "for", isLoop: true}, _function = {keyword: "function"};
  var _if = {keyword: "if"}, _return = {keyword: "return", beforeExpr: true}, _switch = {keyword: "switch"};
  var _throw = {keyword: "throw", beforeExpr: true}, _try = {keyword: "try"}, _var = {keyword: "var"};
  var _while = {keyword: "while", isLoop: true}, _with = {keyword: "with"}, _new = {keyword: "new", beforeExpr: true};
  var _this = {keyword: "this"};

  // The keywords that denote values.

  var _null = {keyword: "null", atomValue: null}, _true = {keyword: "true", atomValue: true};
  var _false = {keyword: "false", atomValue: false};

  // Some keywords are treated as regular operators. `in` sometimes
  // (when parsing `for`) needs to be tested against specifically, so
  // we assign a variable name to it for quick comparing.

  var _in = {keyword: "in", binop: 7, beforeExpr: true};

  // Map keyword names to token types.

  var keywordTypes = {"break": _break, "case": _case, "catch": _catch,
                      "continue": _continue, "debugger": _debugger, "default": _default,
                      "do": _do, "else": _else, "finally": _finally, "for": _for,
                      "function": _function, "if": _if, "return": _return, "switch": _switch,
                      "throw": _throw, "try": _try, "var": _var, "while": _while, "with": _with,
                      "null": _null, "true": _true, "false": _false, "new": _new, "in": _in,
                      "instanceof": {keyword: "instanceof", binop: 7, beforeExpr: true}, "this": _this,
                      "typeof": {keyword: "typeof", prefix: true, beforeExpr: true},
                      "void": {keyword: "void", prefix: true, beforeExpr: true},
                      "delete": {keyword: "delete", prefix: true, beforeExpr: true}};

  // Punctuation token types. Again, the `type` property is purely for debugging.

  var _bracketL = {type: "[", beforeExpr: true}, _bracketR = {type: "]"}, _braceL = {type: "{", beforeExpr: true};
  var _braceR = {type: "}"}, _parenL = {type: "(", beforeExpr: true}, _parenR = {type: ")"};
  var _comma = {type: ",", beforeExpr: true}, _semi = {type: ";", beforeExpr: true};
  var _colon = {type: ":", beforeExpr: true}, _dot = {type: "."}, _question = {type: "?", beforeExpr: true};

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator. `isUpdate` specifies that the node produced by
  // the operator should be of type UpdateExpression rather than
  // simply UnaryExpression (`++` and `--`).
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  var _slash = {binop: 10, beforeExpr: true}, _eq = {isAssign: true, beforeExpr: true};
  var _assign = {isAssign: true, beforeExpr: true};
  var _incDec = {postfix: true, prefix: true, isUpdate: true}, _prefix = {prefix: true, beforeExpr: true};
  var _logicalOR = {binop: 1, beforeExpr: true};
  var _logicalAND = {binop: 2, beforeExpr: true};
  var _bitwiseOR = {binop: 3, beforeExpr: true};
  var _bitwiseXOR = {binop: 4, beforeExpr: true};
  var _bitwiseAND = {binop: 5, beforeExpr: true};
  var _equality = {binop: 6, beforeExpr: true};
  var _relational = {binop: 7, beforeExpr: true};
  var _bitShift = {binop: 8, beforeExpr: true};
  var _plusMin = {binop: 9, prefix: true, beforeExpr: true};
  var _multiplyModulo = {binop: 10, beforeExpr: true};

  // Provide access to the token types for external users of the
  // tokenizer.

  exports.tokTypes = {bracketL: _bracketL, bracketR: _bracketR, braceL: _braceL, braceR: _braceR,
                      parenL: _parenL, parenR: _parenR, comma: _comma, semi: _semi, colon: _colon,
                      dot: _dot, question: _question, slash: _slash, eq: _eq, name: _name, eof: _eof,
                      num: _num, regexp: _regexp, string: _string};
  for (var kw in keywordTypes) exports.tokTypes["_" + kw] = keywordTypes[kw];

  // This is a trick taken from Esprima. It turns out that, on
  // non-Chrome browsers, to check whether a string is in a set, a
  // predicate containing a big ugly `switch` statement is faster than
  // a regular expression, and on Chrome the two are about on par.
  // This function uses `eval` (non-lexical) to produce such a
  // predicate from a space-separated string of words.
  //
  // It starts by sorting the words by length.

  function makePredicate(words) {
    words = words.split(" ");
    var f = "", cats = [];
    out: for (var i = 0; i < words.length; ++i) {
      for (var j = 0; j < cats.length; ++j)
        if (cats[j][0].length == words[i].length) {
          cats[j].push(words[i]);
          continue out;
        }
      cats.push([words[i]]);
    }
    function compareTo(arr) {
      if (arr.length == 1) return f += "return str === " + JSON.stringify(arr[0]) + ";";
      f += "switch(str){";
      for (var i = 0; i < arr.length; ++i) f += "case " + JSON.stringify(arr[i]) + ":";
      f += "return true}return false;";
    }

    // When there are more than three length categories, an outer
    // switch first dispatches on the lengths, to save on comparisons.

    if (cats.length > 3) {
      cats.sort(function(a, b) {return b.length - a.length;});
      f += "switch(str.length){";
      for (var i = 0; i < cats.length; ++i) {
        var cat = cats[i];
        f += "case " + cat[0].length + ":";
        compareTo(cat);
      }
      f += "}";

    // Otherwise, simply generate a flat `switch` statement.

    } else {
      compareTo(words);
    }
    return new Function("str", f);
  }

  // The ECMAScript 3 reserved word list.

  var isReservedWord3 = makePredicate("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile");

  // ECMAScript 5 reserved words.

  var isReservedWord5 = makePredicate("class enum extends super const export import");

  // The additional reserved words in strict mode.

  var isStrictReservedWord = makePredicate("implements interface let package private protected public static yield");

  // The forbidden variable names in strict mode.

  var isStrictBadIdWord = makePredicate("eval arguments");

  // And the keywords.

  var isKeyword = makePredicate("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this");

  // ## Character categories

  // Big ugly regular expressions that match characters in the
  // whitespace, identifier, and identifier-start categories. These
  // are only applied when a character is found to actually have a
  // code point above 128.

  var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
  var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
  var nonASCIIidentifierChars = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

  // Whether a single character denotes a newline.

  var newline = /[\n\r\u2028\u2029]/;

  // Matches a whole line break (where CRLF is considered a single
  // line break). Used to count lines.

  var lineBreak = /\r\n|[\n\r\u2028\u2029]/g;

  // Test whether a given character code starts an identifier.

  var isIdentifierStart = exports.isIdentifierStart = function(code) {
    if (code < 65) return code === 36;
    if (code < 91) return true;
    if (code < 97) return code === 95;
    if (code < 123)return true;
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  };

  // Test whether a given character is part of an identifier.

  var isIdentifierChar = exports.isIdentifierChar = function(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code < 91) return true;
    if (code < 97) return code === 95;
    if (code < 123)return true;
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  };

  // ## Tokenizer

  // These are used when `options.locations` is on, for the
  // `tokStartLoc` and `tokEndLoc` properties.

  function line_loc_t() {
    this.line = tokCurLine;
    this.column = tokPos - tokLineStart;
  }

  // Reset the token state. Used at the start of a parse.

  function initTokenState() {
    tokCurLine = 1;
    tokPos = tokLineStart = 0;
    tokRegexpAllowed = true;
    skipSpace();
  }

  // Called at the end of every token. Sets `tokEnd`, `tokVal`, and
  // `tokRegexpAllowed`, and skips the space after the token, so that
  // the next one's `tokStart` will point at the right position.

  function finishToken(type, val) {
    tokEnd = tokPos;
    if (options.locations) tokEndLoc = new line_loc_t;
    tokType = type;
    skipSpace();
    tokVal = val;
    tokRegexpAllowed = type.beforeExpr;
  }

  function skipBlockComment() {
    var startLoc = options.onComment && options.locations && new line_loc_t;
    var start = tokPos, end = input.indexOf("*/", tokPos += 2);
    if (end === -1) raise(tokPos - 2, "Unterminated comment");
    tokPos = end + 2;
    if (options.locations) {
      lineBreak.lastIndex = start;
      var match;
      while ((match = lineBreak.exec(input)) && match.index < tokPos) {
        ++tokCurLine;
        tokLineStart = match.index + match[0].length;
      }
    }
    if (options.onComment)
      options.onComment(true, input.slice(start + 2, end), start, tokPos,
                        startLoc, options.locations && new line_loc_t);
  }

  function skipLineComment() {
    var start = tokPos;
    var startLoc = options.onComment && options.locations && new line_loc_t;
    var ch = input.charCodeAt(tokPos+=2);
    while (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
      ++tokPos;
      ch = input.charCodeAt(tokPos);
    }
    if (options.onComment)
      options.onComment(false, input.slice(start + 2, tokPos), start, tokPos,
                        startLoc, options.locations && new line_loc_t);
  }

  // Called at the start of the parse and after every token. Skips
  // whitespace and comments, and.

  function skipSpace() {
    while (tokPos < inputLen) {
      var ch = input.charCodeAt(tokPos);
      if (ch === 32) { // ' '
        ++tokPos;
      } else if (ch === 13) {
        ++tokPos;
        var next = input.charCodeAt(tokPos);
        if (next === 10) {
          ++tokPos;
        }
        if (options.locations) {
          ++tokCurLine;
          tokLineStart = tokPos;
        }
      } else if (ch === 10 || ch === 8232 || ch === 8233) {
        ++tokPos;
        if (options.locations) {
          ++tokCurLine;
          tokLineStart = tokPos;
        }
      } else if (ch > 8 && ch < 14) {
        ++tokPos;
      } else if (ch === 47) { // '/'
        var next = input.charCodeAt(tokPos + 1);
        if (next === 42) { // '*'
          skipBlockComment();
        } else if (next === 47) { // '/'
          skipLineComment();
        } else break;
      } else if (ch === 160) { // '\xa0'
        ++tokPos;
      } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
        ++tokPos;
      } else {
        break;
      }
    }
  }

  // ### Token reading

  // This is the function that is called to fetch the next token. It
  // is somewhat obscure, because it works in character codes rather
  // than characters, and because operator parsing has been inlined
  // into it.
  //
  // All in the name of speed.
  //
  // The `forceRegexp` parameter is used in the one case where the
  // `tokRegexpAllowed` trick does not work. See `parseStatement`.

  function readToken_dot() {
    var next = input.charCodeAt(tokPos + 1);
    if (next >= 48 && next <= 57) return readNumber(true);
    ++tokPos;
    return finishToken(_dot);
  }

  function readToken_slash() { // '/'
    var next = input.charCodeAt(tokPos + 1);
    if (tokRegexpAllowed) {++tokPos; return readRegexp();}
    if (next === 61) return finishOp(_assign, 2);
    return finishOp(_slash, 1);
  }

  function readToken_mult_modulo() { // '%*'
    var next = input.charCodeAt(tokPos + 1);
    if (next === 61) return finishOp(_assign, 2);
    return finishOp(_multiplyModulo, 1);
  }

  function readToken_pipe_amp(code) { // '|&'
    var next = input.charCodeAt(tokPos + 1);
    if (next === code) return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);
    if (next === 61) return finishOp(_assign, 2);
    return finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);
  }

  function readToken_caret() { // '^'
    var next = input.charCodeAt(tokPos + 1);
    if (next === 61) return finishOp(_assign, 2);
    return finishOp(_bitwiseXOR, 1);
  }

  function readToken_plus_min(code) { // '+-'
    var next = input.charCodeAt(tokPos + 1);
    if (next === code) {
      if (next == 45 && input.charCodeAt(tokPos + 2) == 62 &&
          newline.test(input.slice(lastEnd, tokPos))) {
        // A `-->` line comment
        tokPos += 3;
        skipLineComment();
        skipSpace();
        return readToken();
      }
      return finishOp(_incDec, 2);
    }
    if (next === 61) return finishOp(_assign, 2);
    return finishOp(_plusMin, 1);
  }

  function readToken_lt_gt(code) { // '<>'
    var next = input.charCodeAt(tokPos + 1);
    var size = 1;
    if (next === code) {
      size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;
      if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);
      return finishOp(_bitShift, size);
    }
    if (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 &&
        input.charCodeAt(tokPos + 3) == 45) {
      // `<!--`, an XML-style comment that should be interpreted as a line comment
      tokPos += 4;
      skipLineComment();
      skipSpace();
      return readToken();
    }
    if (next === 61)
      size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;
    return finishOp(_relational, size);
  }

  function readToken_eq_excl(code) { // '=!'
    var next = input.charCodeAt(tokPos + 1);
    if (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);
    return finishOp(code === 61 ? _eq : _prefix, 1);
  }

  function getTokenFromCode(code) {
    switch(code) {
      // The interpretation of a dot depends on whether it is followed
      // by a digit.
    case 46: // '.'
      return readToken_dot();

      // Punctuation tokens.
    case 40: ++tokPos; return finishToken(_parenL);
    case 41: ++tokPos; return finishToken(_parenR);
    case 59: ++tokPos; return finishToken(_semi);
    case 44: ++tokPos; return finishToken(_comma);
    case 91: ++tokPos; return finishToken(_bracketL);
    case 93: ++tokPos; return finishToken(_bracketR);
    case 123: ++tokPos; return finishToken(_braceL);
    case 125: ++tokPos; return finishToken(_braceR);
    case 58: ++tokPos; return finishToken(_colon);
    case 63: ++tokPos; return finishToken(_question);

      // '0x' is a hexadecimal number.
    case 48: // '0'
      var next = input.charCodeAt(tokPos + 1);
      if (next === 120 || next === 88) return readHexNumber();
      // Anything else beginning with a digit is an integer, octal
      // number, or float.
    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
      return readNumber(false);

      // Quotes produce strings.
    case 34: case 39: // '"', "'"
      return readString(code);

    // Operators are parsed inline in tiny state machines. '=' (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.

    case 47: // '/'
      return readToken_slash(code);

    case 37: case 42: // '%*'
      return readToken_mult_modulo();

    case 124: case 38: // '|&'
      return readToken_pipe_amp(code);

    case 94: // '^'
      return readToken_caret();

    case 43: case 45: // '+-'
      return readToken_plus_min(code);

    case 60: case 62: // '<>'
      return readToken_lt_gt(code);

    case 61: case 33: // '=!'
      return readToken_eq_excl(code);

    case 126: // '~'
      return finishOp(_prefix, 1);
    }

    return false;
  }

  function readToken(forceRegexp) {
    if (!forceRegexp) tokStart = tokPos;
    else tokPos = tokStart + 1;
    if (options.locations) tokStartLoc = new line_loc_t;
    if (forceRegexp) return readRegexp();
    if (tokPos >= inputLen) return finishToken(_eof);

    var code = input.charCodeAt(tokPos);
    // Identifier or keyword. '\uXXXX' sequences are allowed in
    // identifiers, so '\' also dispatches to that.
    if (isIdentifierStart(code) || code === 92 /* '\' */) return readWord();

    var tok = getTokenFromCode(code);

    if (tok === false) {
      // If we are here, we either found a non-ASCII identifier
      // character, or something that's entirely disallowed.
      var ch = String.fromCharCode(code);
      if (ch === "\\" || nonASCIIidentifierStart.test(ch)) return readWord();
      raise(tokPos, "Unexpected character '" + ch + "'");
    }
    return tok;
  }

  function finishOp(type, size) {
    var str = input.slice(tokPos, tokPos + size);
    tokPos += size;
    finishToken(type, str);
  }

  // Parse a regular expression. Some context-awareness is necessary,
  // since a '/' inside a '[]' set does not end the expression.

  function readRegexp() {
    var content = "", escaped, inClass, start = tokPos;
    for (;;) {
      if (tokPos >= inputLen) raise(start, "Unterminated regular expression");
      var ch = input.charAt(tokPos);
      if (newline.test(ch)) raise(start, "Unterminated regular expression");
      if (!escaped) {
        if (ch === "[") inClass = true;
        else if (ch === "]" && inClass) inClass = false;
        else if (ch === "/" && !inClass) break;
        escaped = ch === "\\";
      } else escaped = false;
      ++tokPos;
    }
    var content = input.slice(start, tokPos);
    ++tokPos;
    // Need to use `readWord1` because '\uXXXX' sequences are allowed
    // here (don't ask).
    var mods = readWord1();
    if (mods && !/^[gmsiy]*$/.test(mods)) raise(start, "Invalid regexp flag");
    return finishToken(_regexp, new RegExp(content, mods));
  }

  // Read an integer in the given radix. Return null if zero digits
  // were read, the integer value otherwise. When `len` is given, this
  // will return `null` unless the integer has exactly `len` digits.

  function readInt(radix, len) {
    var start = tokPos, total = 0;
    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
      var code = input.charCodeAt(tokPos), val;
      if (code >= 97) val = code - 97 + 10; // a
      else if (code >= 65) val = code - 65 + 10; // A
      else if (code >= 48 && code <= 57) val = code - 48; // 0-9
      else val = Infinity;
      if (val >= radix) break;
      ++tokPos;
      total = total * radix + val;
    }
    if (tokPos === start || len != null && tokPos - start !== len) return null;

    return total;
  }

  function readHexNumber() {
    tokPos += 2; // 0x
    var val = readInt(16);
    if (val == null) raise(tokStart + 2, "Expected hexadecimal number");
    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");
    return finishToken(_num, val);
  }

  // Read an integer, octal integer, or floating-point number.

  function readNumber(startsWithDot) {
    var start = tokPos, isFloat = false, octal = input.charCodeAt(tokPos) === 48;
    if (!startsWithDot && readInt(10) === null) raise(start, "Invalid number");
    if (input.charCodeAt(tokPos) === 46) {
      ++tokPos;
      readInt(10);
      isFloat = true;
    }
    var next = input.charCodeAt(tokPos);
    if (next === 69 || next === 101) { // 'eE'
      next = input.charCodeAt(++tokPos);
      if (next === 43 || next === 45) ++tokPos; // '+-'
      if (readInt(10) === null) raise(start, "Invalid number");
      isFloat = true;
    }
    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");

    var str = input.slice(start, tokPos), val;
    if (isFloat) val = parseFloat(str);
    else if (!octal || str.length === 1) val = parseInt(str, 10);
    else if (/[89]/.test(str) || strict) raise(start, "Invalid number");
    else val = parseInt(str, 8);
    return finishToken(_num, val);
  }

  // Read a string value, interpreting backslash-escapes.

  function readString(quote) {
    tokPos++;
    var out = "";
    for (;;) {
      if (tokPos >= inputLen) raise(tokStart, "Unterminated string constant");
      var ch = input.charCodeAt(tokPos);
      if (ch === quote) {
        ++tokPos;
        return finishToken(_string, out);
      }
      if (ch === 92) { // '\'
        ch = input.charCodeAt(++tokPos);
        var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));
        if (octal) octal = octal[0];
        while (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);
        if (octal === "0") octal = null;
        ++tokPos;
        if (octal) {
          if (strict) raise(tokPos - 2, "Octal literal in strict mode");
          out += String.fromCharCode(parseInt(octal, 8));
          tokPos += octal.length - 1;
        } else {
          switch (ch) {
          case 110: out += "\n"; break; // 'n' -> '\n'
          case 114: out += "\r"; break; // 'r' -> '\r'
          case 120: out += String.fromCharCode(readHexChar(2)); break; // 'x'
          case 117: out += String.fromCharCode(readHexChar(4)); break; // 'u'
          case 85: out += String.fromCharCode(readHexChar(8)); break; // 'U'
          case 116: out += "\t"; break; // 't' -> '\t'
          case 98: out += "\b"; break; // 'b' -> '\b'
          case 118: out += "\u000b"; break; // 'v' -> '\u000b'
          case 102: out += "\f"; break; // 'f' -> '\f'
          case 48: out += "\0"; break; // 0 -> '\0'
          case 13: if (input.charCodeAt(tokPos) === 10) ++tokPos; // '\r\n'
          case 10: // ' \n'
            if (options.locations) { tokLineStart = tokPos; ++tokCurLine; }
            break;
          default: out += String.fromCharCode(ch); break;
          }
        }
      } else {
        if (ch === 13 || ch === 10 || ch === 8232 || ch === 8233) raise(tokStart, "Unterminated string constant");
        out += String.fromCharCode(ch); // '\'
        ++tokPos;
      }
    }
  }

  // Used to read character escape sequences ('\x', '\u', '\U').

  function readHexChar(len) {
    var n = readInt(16, len);
    if (n === null) raise(tokStart, "Bad character escape sequence");
    return n;
  }

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.

  var containsEsc;

  // Read an identifier, and return it as a string. Sets `containsEsc`
  // to whether the word contained a '\u' escape.
  //
  // Only builds up the word character-by-character when it actually
  // containeds an escape, as a micro-optimization.

  function readWord1() {
    containsEsc = false;
    var word, first = true, start = tokPos;
    for (;;) {
      var ch = input.charCodeAt(tokPos);
      if (isIdentifierChar(ch)) {
        if (containsEsc) word += input.charAt(tokPos);
        ++tokPos;
      } else if (ch === 92) { // "\"
        if (!containsEsc) word = input.slice(start, tokPos);
        containsEsc = true;
        if (input.charCodeAt(++tokPos) != 117) // "u"
          raise(tokPos, "Expecting Unicode escape sequence \\uXXXX");
        ++tokPos;
        var esc = readHexChar(4);
        var escStr = String.fromCharCode(esc);
        if (!escStr) raise(tokPos - 1, "Invalid Unicode escape");
        if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc)))
          raise(tokPos - 4, "Invalid Unicode escape");
        word += escStr;
      } else {
        break;
      }
      first = false;
    }
    return containsEsc ? word : input.slice(start, tokPos);
  }

  // Read an identifier or keyword token. Will check for reserved
  // words when necessary.

  function readWord() {
    var word = readWord1();
    var type = _name;
    if (!containsEsc) {
      if (isKeyword(word)) type = keywordTypes[word];
      else if (options.forbidReserved &&
               (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(word) ||
               strict && isStrictReservedWord(word))
        raise(tokStart, "The keyword '" + word + "' is reserved");
    }
    return finishToken(type, word);
  }

  // ## Parser

  // A recursive descent parser operates by defining functions for all
  // syntactic elements, and recursively calling those, each function
  // advancing the input stream and returning an AST node. Precedence
  // of constructs (for example, the fact that `!x[1]` means `!(x[1])`
  // instead of `(!x)[1]` is handled by the fact that the parser
  // function that parses unary prefix operators is called first, and
  // in turn calls the function that parses `[]` subscripts  that
  // way, it'll receive the node for `x[1]` already parsed, and wraps
  // *that* in the unary operator node.
  //
  // Acorn uses an [operator precedence parser][opp] to handle binary
  // operator precedence, because it is much more compact than using
  // the technique outlined above, which uses different, nesting
  // functions to specify precedence, for all of the ten binary
  // precedence levels that JavaScript defines.
  //
  // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

  // ### Parser utilities

  // Continue to the next token.

  function next() {
    lastStart = tokStart;
    lastEnd = tokEnd;
    lastEndLoc = tokEndLoc;
    readToken();
  }

  // Enter strict mode. Re-reads the next token to please pedantic
  // tests ("use strict"; 010; -- should fail).

  function setStrict(strct) {
    strict = strct;
    tokPos = lastEnd;
    if (options.locations) {
      while (tokPos < tokLineStart) {
        tokLineStart = input.lastIndexOf("\n", tokLineStart - 2) + 1;
        --tokCurLine;
      }
    }
    skipSpace();
    readToken();
  }

  // Start an AST node, attaching a start offset.

  function node_t() {
    this.type = null;
    this.start = tokStart;
    this.end = null;
  }

  function node_loc_t() {
    this.start = tokStartLoc;
    this.end = null;
    if (sourceFile !== null) this.source = sourceFile;
  }

  function startNode() {
    var node = new node_t();
    if (options.locations)
      node.loc = new node_loc_t();
    if (options.directSourceFile)
      node.sourceFile = options.directSourceFile;
    if (options.ranges)
      node.range = [tokStart, 0];
    return node;
  }

  // Start a node whose start offset information should be based on
  // the start of another node. For example, a binary operator node is
  // only started after its left-hand side has already been parsed.

  function startNodeFrom(other) {
    var node = new node_t();
    node.start = other.start;
    if (options.locations) {
      node.loc = new node_loc_t();
      node.loc.start = other.loc.start;
    }
    if (options.ranges)
      node.range = [other.range[0], 0];

    return node;
  }

  // Finish an AST node, adding `type` and `end` properties.

  function finishNode(node, type) {
    node.type = type;
    node.end = lastEnd;
    if (options.locations)
      node.loc.end = lastEndLoc;
    if (options.ranges)
      node.range[1] = lastEnd;
    return node;
  }

  // Test whether a statement node is the string literal `"use strict"`.

  function isUseStrict(stmt) {
    return options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" &&
      stmt.expression.type === "Literal" && stmt.expression.value === "use strict";
  }

  // Predicate that tests whether the next token is of the given
  // type, and if yes, consumes it as a side effect.

  function eat(type) {
    if (tokType === type) {
      next();
      return true;
    }
  }

  // Test whether a semicolon can be inserted at the current position.

  function canInsertSemicolon() {
    return !options.strictSemicolons &&
      (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));
  }

  // Consume a semicolon, or, failing that, see if we are allowed to
  // pretend that there is a semicolon at this position.

  function semicolon() {
    if (!eat(_semi) && !canInsertSemicolon()) unexpected();
  }

  // Expect a token of a given type. If found, consume it, otherwise,
  // raise an unexpected token error.

  function expect(type) {
    if (tokType === type) next();
    else unexpected();
  }

  // Raise an unexpected token error.

  function unexpected() {
    raise(tokStart, "Unexpected token");
  }

  // Verify that a node is an lval  something that can be assigned
  // to.

  function checkLVal(expr) {
    if (expr.type !== "Identifier" && expr.type !== "MemberExpression")
      raise(expr.start, "Assigning to rvalue");
    if (strict && expr.type === "Identifier" && isStrictBadIdWord(expr.name))
      raise(expr.start, "Assigning to " + expr.name + " in strict mode");
  }

  // ### Statement parsing

  // Parse a program. Initializes the parser, reads any number of
  // statements, and wraps them in a Program node.  Optionally takes a
  // `program` argument.  If present, the statements will be appended
  // to its body instead of creating a new node.

  function parseTopLevel(program) {
    lastStart = lastEnd = tokPos;
    if (options.locations) lastEndLoc = new line_loc_t;
    inFunction = strict = null;
    labels = [];
    readToken();

    var node = program || startNode(), first = true;
    if (!program) node.body = [];
    while (tokType !== _eof) {
      var stmt = parseStatement();
      node.body.push(stmt);
      if (first && isUseStrict(stmt)) setStrict(true);
      first = false;
    }
    return finishNode(node, "Program");
  }

  var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

  // Parse a single statement.
  //
  // If expecting a statement and finding a slash operator, parse a
  // regular expression literal. This is to handle cases like
  // `if (foo) /blah/.exec(foo);`, where looking at the previous token
  // does not help.

  function parseStatement() {
    if (tokType === _slash || tokType === _assign && tokVal == "/=")
      readToken(true);

    var starttype = tokType, node = startNode();

    // Most types of statements are recognized by the keyword they
    // start with. Many are trivial to parse, some require a bit of
    // complexity.

    switch (starttype) {
    case _break: case _continue:
      next();
      var isBreak = starttype === _break;
      if (eat(_semi) || canInsertSemicolon()) node.label = null;
      else if (tokType !== _name) unexpected();
      else {
        node.label = parseIdent();
        semicolon();
      }

      // Verify that there is an actual destination to break or
      // continue to.
      for (var i = 0; i < labels.length; ++i) {
        var lab = labels[i];
        if (node.label == null || lab.name === node.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
          if (node.label && isBreak) break;
        }
      }
      if (i === labels.length) raise(node.start, "Unsyntactic " + starttype.keyword);
      return finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");

    case _debugger:
      next();
      semicolon();
      return finishNode(node, "DebuggerStatement");

    case _do:
      next();
      labels.push(loopLabel);
      node.body = parseStatement();
      labels.pop();
      expect(_while);
      node.test = parseParenExpression();
      semicolon();
      return finishNode(node, "DoWhileStatement");

      // Disambiguating between a `for` and a `for`/`in` loop is
      // non-trivial. Basically, we have to parse the init `var`
      // statement or expression, disallowing the `in` operator (see
      // the second parameter to `parseExpression`), and then check
      // whether the next token is `in`. When there is no init part
      // (semicolon immediately after the opening parenthesis), it is
      // a regular `for` loop.

    case _for:
      next();
      labels.push(loopLabel);
      expect(_parenL);
      if (tokType === _semi) return parseFor(node, null);
      if (tokType === _var) {
        var init = startNode();
        next();
        parseVar(init, true);
        finishNode(init, "VariableDeclaration");
        if (init.declarations.length === 1 && eat(_in))
          return parseForIn(node, init);
        return parseFor(node, init);
      }
      var init = parseExpression(false, true);
      if (eat(_in)) {checkLVal(init); return parseForIn(node, init);}
      return parseFor(node, init);

    case _function:
      next();
      return parseFunction(node, true);

    case _if:
      next();
      node.test = parseParenExpression();
      node.consequent = parseStatement();
      node.alternate = eat(_else) ? parseStatement() : null;
      return finishNode(node, "IfStatement");

    case _return:
      if (!inFunction) raise(tokStart, "'return' outside of function");
      next();

      // In `return` (and `break`/`continue`), the keywords with
      // optional arguments, we eagerly look for a semicolon or the
      // possibility to insert one.

      if (eat(_semi) || canInsertSemicolon()) node.argument = null;
      else { node.argument = parseExpression(); semicolon(); }
      return finishNode(node, "ReturnStatement");

    case _switch:
      next();
      node.discriminant = parseParenExpression();
      node.cases = [];
      expect(_braceL);
      labels.push(switchLabel);

      // Statements under must be grouped (by label) in SwitchCase
      // nodes. `cur` is used to keep the node that we are currently
      // adding statements to.

      for (var cur, sawDefault; tokType != _braceR;) {
        if (tokType === _case || tokType === _default) {
          var isCase = tokType === _case;
          if (cur) finishNode(cur, "SwitchCase");
          node.cases.push(cur = startNode());
          cur.consequent = [];
          next();
          if (isCase) cur.test = parseExpression();
          else {
            if (sawDefault) raise(lastStart, "Multiple default clauses"); sawDefault = true;
            cur.test = null;
          }
          expect(_colon);
        } else {
          if (!cur) unexpected();
          cur.consequent.push(parseStatement());
        }
      }
      if (cur) finishNode(cur, "SwitchCase");
      next(); // Closing brace
      labels.pop();
      return finishNode(node, "SwitchStatement");

    case _throw:
      next();
      if (newline.test(input.slice(lastEnd, tokStart)))
        raise(lastEnd, "Illegal newline after throw");
      node.argument = parseExpression();
      semicolon();
      return finishNode(node, "ThrowStatement");

    case _try:
      next();
      node.block = parseBlock();
      node.handler = null;
      if (tokType === _catch) {
        var clause = startNode();
        next();
        expect(_parenL);
        clause.param = parseIdent();
        if (strict && isStrictBadIdWord(clause.param.name))
          raise(clause.param.start, "Binding " + clause.param.name + " in strict mode");
        expect(_parenR);
        clause.guard = null;
        clause.body = parseBlock();
        node.handler = finishNode(clause, "CatchClause");
      }
      node.guardedHandlers = empty;
      node.finalizer = eat(_finally) ? parseBlock() : null;
      if (!node.handler && !node.finalizer)
        raise(node.start, "Missing catch or finally clause");
      return finishNode(node, "TryStatement");

    case _var:
      next();
      parseVar(node);
      semicolon();
      return finishNode(node, "VariableDeclaration");

    case _while:
      next();
      node.test = parseParenExpression();
      labels.push(loopLabel);
      node.body = parseStatement();
      labels.pop();
      return finishNode(node, "WhileStatement");

    case _with:
      if (strict) raise(tokStart, "'with' in strict mode");
      next();
      node.object = parseParenExpression();
      node.body = parseStatement();
      return finishNode(node, "WithStatement");

    case _braceL:
      return parseBlock();

    case _semi:
      next();
      return finishNode(node, "EmptyStatement");

      // If the statement does not start with a statement keyword or a
      // brace, it's an ExpressionStatement or LabeledStatement. We
      // simply start parsing an expression, and afterwards, if the
      // next token is a colon and the expression was a simple
      // Identifier node, we switch to interpreting it as a label.

    default:
      var maybeName = tokVal, expr = parseExpression();
      if (starttype === _name && expr.type === "Identifier" && eat(_colon)) {
        for (var i = 0; i < labels.length; ++i)
          if (labels[i].name === maybeName) raise(expr.start, "Label '" + maybeName + "' is already declared");
        var kind = tokType.isLoop ? "loop" : tokType === _switch ? "switch" : null;
        labels.push({name: maybeName, kind: kind});
        node.body = parseStatement();
        labels.pop();
        node.label = expr;
        return finishNode(node, "LabeledStatement");
      } else {
        node.expression = expr;
        semicolon();
        return finishNode(node, "ExpressionStatement");
      }
    }
  }

  // Used for constructs like `switch` and `if` that insist on
  // parentheses around their expression.

  function parseParenExpression() {
    expect(_parenL);
    var val = parseExpression();
    expect(_parenR);
    return val;
  }

  // Parse a semicolon-enclosed block of statements, handling `"use
  // strict"` declarations when `allowStrict` is true (used for
  // function bodies).

  function parseBlock(allowStrict) {
    var node = startNode(), first = true, strict = false, oldStrict;
    node.body = [];
    expect(_braceL);
    while (!eat(_braceR)) {
      var stmt = parseStatement();
      node.body.push(stmt);
      if (first && allowStrict && isUseStrict(stmt)) {
        oldStrict = strict;
        setStrict(strict = true);
      }
      first = false;
    }
    if (strict && !oldStrict) setStrict(false);
    return finishNode(node, "BlockStatement");
  }

  // Parse a regular `for` loop. The disambiguation code in
  // `parseStatement` will already have parsed the init statement or
  // expression.

  function parseFor(node, init) {
    node.init = init;
    expect(_semi);
    node.test = tokType === _semi ? null : parseExpression();
    expect(_semi);
    node.update = tokType === _parenR ? null : parseExpression();
    expect(_parenR);
    node.body = parseStatement();
    labels.pop();
    return finishNode(node, "ForStatement");
  }

  // Parse a `for`/`in` loop.

  function parseForIn(node, init) {
    node.left = init;
    node.right = parseExpression();
    expect(_parenR);
    node.body = parseStatement();
    labels.pop();
    return finishNode(node, "ForInStatement");
  }

  // Parse a list of variable declarations.

  function parseVar(node, noIn) {
    node.declarations = [];
    node.kind = "var";
    for (;;) {
      var decl = startNode();
      decl.id = parseIdent();
      if (strict && isStrictBadIdWord(decl.id.name))
        raise(decl.id.start, "Binding " + decl.id.name + " in strict mode");
      decl.init = eat(_eq) ? parseExpression(true, noIn) : null;
      node.declarations.push(finishNode(decl, "VariableDeclarator"));
      if (!eat(_comma)) break;
    }
    return node;
  }

  // ### Expression parsing

  // These nest, from the most general expression type at the top to
  // 'atomic', nondivisible expression types at the bottom. Most of
  // the functions will simply let the function(s) below them parse,
  // and, *if* the syntactic construct they handle is present, wrap
  // the AST node that the inner parser gave them in another node.

  // Parse a full expression. The arguments are used to forbid comma
  // sequences (in argument lists, array literals, or object literals)
  // or the `in` operator (in for loops initalization expressions).

  function parseExpression(noComma, noIn) {
    var expr = parseMaybeAssign(noIn);
    if (!noComma && tokType === _comma) {
      var node = startNodeFrom(expr);
      node.expressions = [expr];
      while (eat(_comma)) node.expressions.push(parseMaybeAssign(noIn));
      return finishNode(node, "SequenceExpression");
    }
    return expr;
  }

  // Parse an assignment expression. This includes applications of
  // operators like `+=`.

  function parseMaybeAssign(noIn) {
    var left = parseMaybeConditional(noIn);
    if (tokType.isAssign) {
      var node = startNodeFrom(left);
      node.operator = tokVal;
      node.left = left;
      next();
      node.right = parseMaybeAssign(noIn);
      checkLVal(left);
      return finishNode(node, "AssignmentExpression");
    }
    return left;
  }

  // Parse a ternary conditional (`?:`) operator.

  function parseMaybeConditional(noIn) {
    var expr = parseExprOps(noIn);
    if (eat(_question)) {
      var node = startNodeFrom(expr);
      node.test = expr;
      node.consequent = parseExpression(true);
      expect(_colon);
      node.alternate = parseExpression(true, noIn);
      return finishNode(node, "ConditionalExpression");
    }
    return expr;
  }

  // Start the precedence parser.

  function parseExprOps(noIn) {
    return parseExprOp(parseMaybeUnary(), -1, noIn);
  }

  // Parse binary operators with the operator precedence parsing
  // algorithm. `left` is the left-hand side of the operator.
  // `minPrec` provides context that allows the function to stop and
  // defer further parser to one of its callers when it encounters an
  // operator that has a lower precedence than the set it is parsing.

  function parseExprOp(left, minPrec, noIn) {
    var prec = tokType.binop;
    if (prec != null && (!noIn || tokType !== _in)) {
      if (prec > minPrec) {
        var node = startNodeFrom(left);
        node.left = left;
        node.operator = tokVal;
        var op = tokType;
        next();
        node.right = parseExprOp(parseMaybeUnary(), prec, noIn);
        var exprNode = finishNode(node, (op === _logicalOR || op === _logicalAND) ? "LogicalExpression" : "BinaryExpression");
        return parseExprOp(exprNode, minPrec, noIn);
      }
    }
    return left;
  }

  // Parse unary operators, both prefix and postfix.

  function parseMaybeUnary() {
    if (tokType.prefix) {
      var node = startNode(), update = tokType.isUpdate;
      node.operator = tokVal;
      node.prefix = true;
      tokRegexpAllowed = true;
      next();
      node.argument = parseMaybeUnary();
      if (update) checkLVal(node.argument);
      else if (strict && node.operator === "delete" &&
               node.argument.type === "Identifier")
        raise(node.start, "Deleting local variable in strict mode");
      return finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
    }
    var expr = parseExprSubscripts();
    while (tokType.postfix && !canInsertSemicolon()) {
      var node = startNodeFrom(expr);
      node.operator = tokVal;
      node.prefix = false;
      node.argument = expr;
      checkLVal(expr);
      next();
      expr = finishNode(node, "UpdateExpression");
    }
    return expr;
  }

  // Parse call, dot, and `[]`-subscript expressions.

  function parseExprSubscripts() {
    return parseSubscripts(parseExprAtom());
  }

  function parseSubscripts(base, noCalls) {
    if (eat(_dot)) {
      var node = startNodeFrom(base);
      node.object = base;
      node.property = parseIdent(true);
      node.computed = false;
      return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
    } else if (eat(_bracketL)) {
      var node = startNodeFrom(base);
      node.object = base;
      node.property = parseExpression();
      node.computed = true;
      expect(_bracketR);
      return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
    } else if (!noCalls && eat(_parenL)) {
      var node = startNodeFrom(base);
      node.callee = base;
      node.arguments = parseExprList(_parenR, false);
      return parseSubscripts(finishNode(node, "CallExpression"), noCalls);
    } else return base;
  }

  // Parse an atomic expression  either a single token that is an
  // expression, an expression started by a keyword like `function` or
  // `new`, or an expression wrapped in punctuation like `()`, `[]`,
  // or `{}`.

  function parseExprAtom() {
    switch (tokType) {
    case _this:
      var node = startNode();
      next();
      return finishNode(node, "ThisExpression");
    case _name:
      return parseIdent();
    case _num: case _string: case _regexp:
      var node = startNode();
      node.value = tokVal;
      node.raw = input.slice(tokStart, tokEnd);
      next();
      return finishNode(node, "Literal");

    case _null: case _true: case _false:
      var node = startNode();
      node.value = tokType.atomValue;
      node.raw = tokType.keyword;
      next();
      return finishNode(node, "Literal");

    case _parenL:
      var tokStartLoc1 = tokStartLoc, tokStart1 = tokStart;
      next();
      var val = parseExpression();
      val.start = tokStart1;
      val.end = tokEnd;
      if (options.locations) {
        val.loc.start = tokStartLoc1;
        val.loc.end = tokEndLoc;
      }
      if (options.ranges)
        val.range = [tokStart1, tokEnd];
      expect(_parenR);
      return val;

    case _bracketL:
      var node = startNode();
      next();
      node.elements = parseExprList(_bracketR, true, true);
      return finishNode(node, "ArrayExpression");

    case _braceL:
      return parseObj();

    case _function:
      var node = startNode();
      next();
      return parseFunction(node, false);

    case _new:
      return parseNew();

    default:
      unexpected();
    }
  }

  // New's precedence is slightly tricky. It must allow its argument
  // to be a `[]` or dot subscript expression, but not a call  at
  // least, not without wrapping it in parentheses. Thus, it uses the

  function parseNew() {
    var node = startNode();
    next();
    node.callee = parseSubscripts(parseExprAtom(), true);
    if (eat(_parenL)) node.arguments = parseExprList(_parenR, false);
    else node.arguments = empty;
    return finishNode(node, "NewExpression");
  }

  // Parse an object literal.

  function parseObj() {
    var node = startNode(), first = true, sawGetSet = false;
    node.properties = [];
    next();
    while (!eat(_braceR)) {
      if (!first) {
        expect(_comma);
        if (options.allowTrailingCommas && eat(_braceR)) break;
      } else first = false;

      var prop = {key: parsePropertyName()}, isGetSet = false, kind;
      if (eat(_colon)) {
        prop.value = parseExpression(true);
        kind = prop.kind = "init";
      } else if (options.ecmaVersion >= 5 && prop.key.type === "Identifier" &&
                 (prop.key.name === "get" || prop.key.name === "set")) {
        isGetSet = sawGetSet = true;
        kind = prop.kind = prop.key.name;
        prop.key = parsePropertyName();
        if (tokType !== _parenL) unexpected();
        prop.value = parseFunction(startNode(), false);
      } else unexpected();

      // getters and setters are not allowed to clash  either with
      // each other or with an init property  and in strict mode,
      // init properties are also not allowed to be repeated.

      if (prop.key.type === "Identifier" && (strict || sawGetSet)) {
        for (var i = 0; i < node.properties.length; ++i) {
          var other = node.properties[i];
          if (other.key.name === prop.key.name) {
            var conflict = kind == other.kind || isGetSet && other.kind === "init" ||
              kind === "init" && (other.kind === "get" || other.kind === "set");
            if (conflict && !strict && kind === "init" && other.kind === "init") conflict = false;
            if (conflict) raise(prop.key.start, "Redefinition of property");
          }
        }
      }
      node.properties.push(prop);
    }
    return finishNode(node, "ObjectExpression");
  }

  function parsePropertyName() {
    if (tokType === _num || tokType === _string) return parseExprAtom();
    return parseIdent(true);
  }

  // Parse a function declaration or literal (depending on the
  // `isStatement` parameter).

  function parseFunction(node, isStatement) {
    if (tokType === _name) node.id = parseIdent();
    else if (isStatement) unexpected();
    else node.id = null;
    node.params = [];
    var first = true;
    expect(_parenL);
    while (!eat(_parenR)) {
      if (!first) expect(_comma); else first = false;
      node.params.push(parseIdent());
    }

    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldInFunc = inFunction, oldLabels = labels;
    inFunction = true; labels = [];
    node.body = parseBlock(true);
    inFunction = oldInFunc; labels = oldLabels;

    // If this is a strict mode function, verify that argument names
    // are not repeated, and it does not try to bind the words `eval`
    // or `arguments`.
    if (strict || node.body.body.length && isUseStrict(node.body.body[0])) {
      for (var i = node.id ? -1 : 0; i < node.params.length; ++i) {
        var id = i < 0 ? node.id : node.params[i];
        if (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name))
          raise(id.start, "Defining '" + id.name + "' in strict mode");
        if (i >= 0) for (var j = 0; j < i; ++j) if (id.name === node.params[j].name)
          raise(id.start, "Argument name clash in strict mode");
      }
    }

    return finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
  }

  // Parses a comma-separated list of expressions, and returns them as
  // an array. `close` is the token type that ends the list, and
  // `allowEmpty` can be turned on to allow subsequent commas with
  // nothing in between them to be parsed as `null` (which is needed
  // for array literals).

  function parseExprList(close, allowTrailingComma, allowEmpty) {
    var elts = [], first = true;
    while (!eat(close)) {
      if (!first) {
        expect(_comma);
        if (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;
      } else first = false;

      if (allowEmpty && tokType === _comma) elts.push(null);
      else elts.push(parseExpression(true));
    }
    return elts;
  }

  // Parse the next token as an identifier. If `liberal` is true (used
  // when parsing properties), it will also convert keywords into
  // identifiers.

  function parseIdent(liberal) {
    var node = startNode();
    node.name = tokType === _name ? tokVal : (liberal && !options.forbidReserved && tokType.keyword) || unexpected();
    tokRegexpAllowed = false;
    next();
    return finishNode(node, "Identifier");
  }

});

},{}],19:[function(require,module,exports){
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = setImmediate;
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                }
            }));
        });
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (err, v) {
                results[x.index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        if (!keys.length) {
            return callback(null);
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (_keys(results).length === keys.length) {
                callback(null, results);
                callback = function () {};
            }
        });

        _each(keys, function (k) {
            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor !== Array) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (test()) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (!test()) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if(data.constructor !== Array) {
              data = [data];
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            }
        };
        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
                if(data.constructor !== Array) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain) cargo.drain();
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                callback.apply(null, memo[key]);
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.compose = function (/* functions... */) {
        var fns = Array.prototype.reverse.call(arguments);
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // AMD / RequireJS
    if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // Node.js
    else if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

},{}],20:[function(require,module,exports){
'use strict';

module.exports = [
	"000000", "800000", "008000", "808000", "000080", "800080", "008080", "c0c0c0",
	"808080", "ff0000", "00ff00", "ffff00", "0000ff", "ff00ff", "00ffff", "ffffff",

	"000000", "00005f", "000087", "0000af", "0000d7", "0000ff",
	"005f00", "005f5f", "005f87", "005faf", "005fd7", "005fff",
	"008700", "00875f", "008787", "0087af", "0087d7", "0087ff",
	"00af00", "00af5f", "00af87", "00afaf", "00afd7", "00afff",
	"00d700", "00d75f", "00d787", "00d7af", "00d7d7", "00d7ff",
	"00ff00", "00ff5f", "00ff87", "00ffaf", "00ffd7", "00ffff",

	"5f0000", "5f005f", "5f0087", "5f00af", "5f00d7", "5f00ff",
	"5f5f00", "5f5f5f", "5f5f87", "5f5faf", "5f5fd7", "5f5fff",
	"5f8700", "5f875f", "5f8787", "5f87af", "5f87d7", "5f87ff",
	"5faf00", "5faf5f", "5faf87", "5fafaf", "5fafd7", "5fafff",
	"5fd700", "5fd75f", "5fd787", "5fd7af", "5fd7d7", "5fd7ff",
	"5fff00", "5fff5f", "5fff87", "5fffaf", "5fffd7", "5fffff",

	"870000", "87005f", "870087", "8700af", "8700d7", "8700ff",
	"875f00", "875f5f", "875f87", "875faf", "875fd7", "875fff",
	"878700", "87875f", "878787", "8787af", "8787d7", "8787ff",
	"87af00", "87af5f", "87af87", "87afaf", "87afd7", "87afff",
	"87d700", "87d75f", "87d787", "87d7af", "87d7d7", "87d7ff",
	"87ff00", "87ff5f", "87ff87", "87ffaf", "87ffd7", "87ffff",

	"af0000", "af005f", "af0087", "af00af", "af00d7", "af00ff",
	"af5f00", "af5f5f", "af5f87", "af5faf", "af5fd7", "af5fff",
	"af8700", "af875f", "af8787", "af87af", "af87d7", "af87ff",
	"afaf00", "afaf5f", "afaf87", "afafaf", "afafd7", "afafff",
	"afd700", "afd75f", "afd787", "afd7af", "afd7d7", "afd7ff",
	"afff00", "afff5f", "afff87", "afffaf", "afffd7", "afffff",

	"d70000", "d7005f", "d70087", "d700af", "d700d7", "d700ff",
	"d75f00", "d75f5f", "d75f87", "d75faf", "d75fd7", "d75fff",
	"d78700", "d7875f", "d78787", "d787af", "d787d7", "d787ff",
	"d7af00", "d7af5f", "d7af87", "d7afaf", "d7afd7", "d7afff",
	"d7d700", "d7d75f", "d7d787", "d7d7af", "d7d7d7", "d7d7ff",
	"d7ff00", "d7ff5f", "d7ff87", "d7ffaf", "d7ffd7", "d7ffff",

	"ff0000", "ff005f", "ff0087", "ff00af", "ff00d7", "ff00ff",
	"ff5f00", "ff5f5f", "ff5f87", "ff5faf", "ff5fd7", "ff5fff",
	"ff8700", "ff875f", "ff8787", "ff87af", "ff87d7", "ff87ff",
	"ffaf00", "ffaf5f", "ffaf87", "ffafaf", "ffafd7", "ffafff",
	"ffd700", "ffd75f", "ffd787", "ffd7af", "ffd7d7", "ffd7ff",
	"ffff00", "ffff5f", "ffff87", "ffffaf", "ffffd7", "ffffff",

	"080808", "121212", "1c1c1c", "262626", "303030", "3a3a3a",
	"444444", "4e4e4e", "585858", "626262", "6c6c6c", "767676",
	"808080", "8a8a8a", "949494", "9e9e9e", "a8a8a8", "b2b2b2",
	"bcbcbc", "c6c6c6", "d0d0d0", "dadada", "e4e4e4", "eeeeee"
];

},{}],21:[function(require,module,exports){
'use strict';

var push = Array.prototype.push, reduce = Array.prototype.reduce, abs = Math.abs
  , colors, match, result, i;

colors = require('./_xterm-colors').map(function (color) {
	return {
		r: parseInt(color.slice(0, 2), 16),
		g: parseInt(color.slice(2, 4), 16),
		b: parseInt(color.slice(4), 16)
	};
});

match = colors.slice(0, 16);

module.exports = result = [];

i = 0;
while (i < 8) {
	result.push(30 + i++);
}
i = 0;
while (i < 8) {
	result.push(90 + i++);
}
push.apply(result, colors.slice(16).map(function (data) {
	var index, diff = Infinity;
	match.every(function (match, i) {
		var ndiff = reduce.call('rgb', function (diff, channel) {
			return (diff += abs(match[channel] - data[channel]));
		}, 0);
		if (ndiff < diff) {
			index = i;
			diff = ndiff;
		}
		return ndiff;
	});
	return result[index];
}));

},{"./_xterm-colors":20}],22:[function(require,module,exports){
'use strict';

var d       = require('es5-ext/lib/Object/descriptor')
  , extend  = require('es5-ext/lib/Object/extend')
  , map     = require('es5-ext/lib/Object/map')
  , reduce  = require('es5-ext/lib/Object/reduce')
  , repeat  = require('es5-ext/lib/String/prototype/repeat')
  , memoize = require('memoizee')
  , tty     = require('tty')

  , join = Array.prototype.join, defineProperty = Object.defineProperty
  , defineProperties = Object.defineProperties, abs = Math.abs
  , floor = Math.floor, max = Math.max, min = Math.min

  , mods, proto, getFn, getMove, xtermMatch
  , up, down, right, left, getHeight, memoized;

mods = extend({
	// Style
	bold:      { _bold: [1, 22] },
	italic:    { _italic: [3, 23] },
	underline: { _underline: [4, 24] },
	blink:     { _blink: [5, 25] },
	inverse:   { _inverse: [7, 27] },
	strike:    { _strike: [9, 29] }
},

	// Color
	['black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white']
		.reduce(function (obj, color, index) {
		// foreground
		obj[color] = { _fg: [30 + index, 39] };
		obj[color + 'Bright'] = { _fg: [90 + index, 39] };

		// background
		obj['bg' + color[0].toUpperCase() + color.slice(1)] =
			{ _bg: [40 + index, 49] };
		obj['bg' + color[0].toUpperCase() + color.slice(1) + 'Bright'] =
			{ _bg: [100 + index, 49] };

		return obj;
	}, {}));

// Some use cli-color as: console.log(clc.red('Error!'));
// Which is inefficient as on each call it configures new clc object
// with memoization we reuse once created object
memoized = memoize(function (scope, mod) {
	return defineProperty(getFn(), '_cliColorData',
		d(extend({}, scope._cliColorData, mod)));
});

proto = Object.create(Function.prototype, extend(map(mods, function (mod) {
	return d.gs(function () { return memoized(this, mod); });
}), {
	// xterm (255) color
	xterm: d(memoize(function (code) {
		code = isNaN(code) ? 255 : min(max(code, 0), 255);
		return defineProperty(getFn(), '_cliColorData',
			d(extend({}, this._cliColorData, {
				_fg: [xtermMatch ? xtermMatch[code] : ('38;5;' + code), 39]
			})));
	}, { method: 'xterm' })),
	bgXterm: d(memoize(function (code) {
		code = isNaN(code) ? 255 : min(max(code, 0), 255);
		return defineProperty(getFn(), '_cliColorData',
			d(extend({}, this._cliColorData, {
				_bg: [xtermMatch ? (xtermMatch[code] + 10) : ('48;5;' + code), 49]
			})));
	}, { method: 'bgXterm' }))
}));

if (process.platform === 'win32') {
	xtermMatch = require('./_xterm-match');
}

getFn = function () {
	var fn = function (/*msg*/) {
		var data = fn._cliColorData, close = '';
		return reduce(data, function (str, mod) {
			close = '\x1b[' + mod[1] + 'm' + close;
			return str + '\x1b[' + mod[0] + 'm';
		}, '', true) + join.call(arguments, ' ') + close;
	};
	fn.__proto__ = proto;
	return fn;
};

getMove = function (control) {
	return function (num) {
		num = isNaN(num) ? 0 : max(floor(num), 0);
		return num ? ('\x1b[' + num + control) : '';
	};
};

module.exports = defineProperties(getFn(), {
	width: d.gs(process.stdout.getWindowSize ? function () {
		return process.stdout.getWindowSize()[0];
	} : function () {
		return tty.getWindowSize ? tty.getWindowSize()[1] : 0;
	}),
	height: d.gs(getHeight = process.stdout.getWindowSize ? function () {
		return process.stdout.getWindowSize()[1];
	} : function () {
		return tty.getWindowSize ? tty.getWindowSize()[0] : 0;
	}),
	reset: d.gs(function () {
		return repeat.call('\n', getHeight() - 1) + '\x1bc';
	}),
	up: d(up = getMove('A')),
	down: d(down = getMove('B')),
	right: d(right = getMove('C')),
	left: d(left = getMove('D')),
	move: d(function (x, y) {
		x = isNaN(x) ? 0 : floor(x);
		y = isNaN(y) ? 0 : floor(y);
		return ((x > 0) ? right(x) : left(-x)) + ((y > 0) ? down(y) : up(-y));
	}),
	moveTo: d(function (x, y) {
		x = isNaN(x) ? 1 : (max(floor(x), 0) + 1);
		y = isNaN(y) ? 1 : (max(floor(y), 0) + 1);
		return '\x1b[' + y + ';' + x + 'H';
	}),
	bol: d(function (n/*, erase*/) {
		var dir;
		n = isNaN(n) ? 0 : Number(n);
		dir = (n >= 0) ? 'E' : 'F';
		n = floor(abs(n));
		return arguments[1] ?
				(((!n || (dir === 'F')) ? '\x1b[0E\x1bK' : '') +
					repeat.call('\x1b[1' + dir + '\x1b[K', n)) : '\x1b[' + n + dir;
	}),
	beep: d('\x07'),
	xtermSupported: d(!xtermMatch),
	_cliColorData: d({})
});

},{"./_xterm-match":21,"es5-ext/lib/Object/descriptor":36,"es5-ext/lib/Object/extend":37,"es5-ext/lib/Object/map":43,"es5-ext/lib/Object/reduce":44,"es5-ext/lib/String/prototype/repeat":49,"memoizee":59,"tty":9}],23:[function(require,module,exports){
'use strict';

var isArguments   = require('../Function/is-arguments')

  , isArray = Array.isArray, slice = Array.prototype.slice;

module.exports = function (obj) {
	if (isArray(obj)) {
		return obj;
	} else if (isArguments(obj)) {
		return (obj.length === 1) ? [obj[0]] : Array.apply(null, obj);
	} else {
		return slice.call(obj);
	}
};

},{"../Function/is-arguments":28}],24:[function(require,module,exports){
'use strict';

var numIsNaN = require('../../Number/is-nan')
  , ois      = require('../../Object/is')
  , value    = require('../../Object/valid-value')

  , indexOf = Array.prototype.indexOf;

module.exports = function (searchElement/*, fromIndex*/) {
	var i;
	if (!numIsNaN(searchElement) && (searchElement !== 0)) {
		return indexOf.apply(this, arguments);
	}

	for (i = (arguments[1] >>> 0); i < (value(this).length >>> 0); ++i) {
		if (this.hasOwnProperty(i) && ois(searchElement, this[i])) {
			return i;
		}
	}
	return -1;
};

},{"../../Number/is-nan":30,"../../Object/is":42,"../../Object/valid-value":46}],25:[function(require,module,exports){
'use strict';

var value = require('../../Object/valid-value');

module.exports = function () {
	var i, l;
	if (!(l = (value(this).length >>> 0))) {
		return null;
	}
	i = l - 1;
	while (!this.hasOwnProperty(i)) {
		if (--i === -1) {
			return null;
		}
	}
	return i;
};

},{"../../Object/valid-value":46}],26:[function(require,module,exports){
'use strict';

var lastIndex = require('./last-index');

module.exports = function () {
	var i;
	if ((i = lastIndex.call(this)) !== null) {
		return this[i];
	}
	return undefined;
};

},{"./last-index":25}],27:[function(require,module,exports){
'use strict';

var d      = require('../Object/descriptor')
  , extend = require('../Object/extend')

  , captureStackTrace = Error.captureStackTrace
  , CustomError;

CustomError = module.exports = function CustomError(message, code/*, ext*/) {
	var ext = arguments[2];
	if (ext != null) extend(this, ext);
	this.message = String(message);
	if (code != null) this.code = String(code);
	if (captureStackTrace) captureStackTrace(this, CustomError);
};

CustomError.prototype = Object.create(Error.prototype, {
	constructor: d(CustomError),
	name: d('CustomError')
});

},{"../Object/descriptor":36,"../Object/extend":37}],28:[function(require,module,exports){
'use strict';

var toString = Object.prototype.toString

  , id = toString.call((function () { return arguments; }()));

module.exports = function (x) {
	return toString.call(x) === id;
};

},{}],29:[function(require,module,exports){
'use strict';

module.exports = function (value) {
	value = Number(value);
	if (isNaN(value) || (value === 0)) {
		return value;
	}
	return (value > 0) ? 1 : -1;
};

},{}],30:[function(require,module,exports){
'use strict';

module.exports = function (value) {
	return (value !== value); //jslint: skip
};

},{}],31:[function(require,module,exports){
'use strict';

var toString = Object.prototype.toString

  , id = toString.call(1);

module.exports = function (x) {
	return ((typeof x === 'number') ||
		((x instanceof Number) ||
			((typeof x === 'object') && (toString.call(x) === id))));
};

},{}],32:[function(require,module,exports){
'use strict';

var sign = require('../Math/sign')

  , abs = Math.abs, floor = Math.floor;

module.exports = function (value) {
	if (isNaN(value)) {
		return 0;
	}
	value = Number(value);
	if ((value === 0) || !isFinite(value)) {
		return value;
	}

	return sign(value) * floor(abs(value));
};

},{"../Math/sign":29}],33:[function(require,module,exports){
'use strict';

var toInt = require('./to-int')

  , max = Math.max;

module.exports = function (value) { return max(0, toInt(value)); };

},{"./to-int":32}],34:[function(require,module,exports){
// Internal method, used by iteration functions.
// Calls a function for each key-value pair found in object
// Optionally takes compareFn to iterate object in specific order

'use strict';

var isCallable = require('./is-callable')
  , callable   = require('./valid-callable')
  , value      = require('./valid-value')

  , call = Function.prototype.call, keys = Object.keys;

module.exports = function (method) {
	return function (obj, cb/*, thisArg, compareFn*/) {
		var list, thisArg = arguments[2], compareFn = arguments[3];
		obj = Object(value(obj));
		callable(cb);

		list = keys(obj);
		if (compareFn) {
			list.sort(isCallable(compareFn) ? compareFn.bind(obj) : undefined);
		}
		return list[method](function (key, index) {
			return call.call(cb, thisArg, obj[key], key, obj, index);
		});
	};
};

},{"./is-callable":39,"./valid-callable":45,"./valid-value":46}],35:[function(require,module,exports){
'use strict';

var isPlainObject = require('./is-plain-object')
  , forEach       = require('./for-each')
  , extend        = require('./extend')
  , value         = require('./valid-value')

  , recursive;

recursive = function (to, from, cloned) {
	forEach(from, function (value, key) {
		var index;
		if (isPlainObject(value)) {
			if ((index = cloned[0].indexOf(value)) === -1) {
				cloned[0].push(value);
				cloned[1].push(to[key] = extend({}, value));
				recursive(to[key], value, cloned);
			} else {
				to[key] = cloned[1][index];
			}
		}
	}, from);
};

module.exports = function (obj/*, deep*/) {
	var copy;
	if ((copy = Object(value(obj))) === obj) {
		copy = extend({}, obj);
		if (arguments[1]) {
			recursive(copy, obj, [[obj], [copy]]);
		}
	}
	return copy;
};

},{"./extend":37,"./for-each":38,"./is-plain-object":41,"./valid-value":46}],36:[function(require,module,exports){
'use strict';

var isCallable = require('./is-callable')
  , callable   = require('./valid-callable')
  , validValue = require('./valid-value')
  , copy       = require('./copy')
  , map        = require('./map')
  , isString   = require('../String/is-string')
  , contains   = require('../String/prototype/contains')

  , bind = Function.prototype.bind
  , defineProperty = Object.defineProperty
  , d;

d = module.exports = function (dscr, value) {
	var c, e, w;
	if (arguments.length < 2) {
		value = dscr;
		dscr = null;
	}
	if (dscr == null) {
		c = w = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
		w = contains.call(dscr, 'w');
	}

	return { value: value, configurable: c, enumerable: e, writable: w };
};

d.gs = function (dscr, get, set) {
	var c, e;
	if (isCallable(dscr)) {
		set = (get == null) ? undefined : callable(get);
		get = dscr;
		dscr = null;
	} else {
		get = (get == null) ? undefined : callable(get);
		set = (set == null) ? undefined : callable(set);
	}
	if (dscr == null) {
		c = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
	}

	return { get: get, set: set, configurable: c, enumerable: e };
};

d.binder = function self(name, dv) {
	var value, dgs;
	if (!isString(name)) {
		return map(name, function (dv, name) { return self(name, dv); });
	}
	value = validValue(dv) && callable(dv.value);
	dgs = copy(dv);
	delete dgs.writable;
	delete dgs.value;
	dgs.get = function () {
		dv.value = bind.call(value, this);
		defineProperty(this, name, dv);
		return this[name];
	};
	return dgs;
};

},{"../String/is-string":47,"../String/prototype/contains":48,"./copy":35,"./is-callable":39,"./map":43,"./valid-callable":45,"./valid-value":46}],37:[function(require,module,exports){
'use strict';

var value = require('./valid-value')

  , forEach = Array.prototype.forEach, slice = Array.prototype.slice
  , keys = Object.keys

  , extend;

extend = function (src) {
	keys(Object(src)).forEach(function (key) {
		this[key] = src[key];
	}, this);
};

module.exports = function (dest/*, src*/) {
	forEach.call(arguments, value);
	slice.call(arguments, 1).forEach(extend, dest);
	return dest;
};

},{"./valid-value":46}],38:[function(require,module,exports){
'use strict';

module.exports = require('./_iterate')('forEach');

},{"./_iterate":34}],39:[function(require,module,exports){
// Inspired by: http://www.davidflanagan.com/2009/08/typeof-isfuncti.html

'use strict';

var forEach = Array.prototype.forEach.bind([]);

module.exports = function (obj) {
	var type;
	if (!obj) {
		return false;
	}
	type = typeof obj;
	if (type === 'function') {
		return true;
	}
	if (type !== 'object') {
		return false;
	}

	try {
		forEach(obj);
		return true;
	} catch (e) {
		if (e instanceof TypeError) {
			return false;
		}
		throw e;
	}
};

},{}],40:[function(require,module,exports){
'use strict';

var value = require('./valid-value');

module.exports = function (obj) {
	var i;
	value(obj);
	for (i in obj) { //jslint: skip
		if (obj.propertyIsEnumerable(i)) return false;
	}
	return true;
};

},{"./valid-value":46}],41:[function(require,module,exports){
'use strict';

var getPrototypeOf = Object.getPrototypeOf, prototype = Object.prototype
  , toString = prototype.toString

  , id = {}.toString();

module.exports = function (value) {
	var proto;
	if (!value || (typeof value !== 'object') || (toString.call(value) !== id)) {
		return false;
	}
	proto = getPrototypeOf(value);
	return (proto === prototype) || (getPrototypeOf(proto) === null);
};

},{}],42:[function(require,module,exports){
// Implementation credits go to:
// http://wiki.ecmascript.org/doku.php?id=harmony:egal

'use strict';

module.exports = function (x, y) {
	return (x === y) ?
			((x !== 0) || ((1 / x) === (1 / y))) :
			((x !== x) && (y !== y)); //jslint: skip
};

},{}],43:[function(require,module,exports){
'use strict';

var callable = require('./valid-callable')
  , forEach  = require('./for-each')

  , call = Function.prototype.call;

module.exports = function (obj, cb/*, thisArg*/) {
	var o = {}, thisArg = arguments[2];
	callable(cb);
	forEach(obj, function (value, key, obj, index) {
		o[key] = call.call(cb, thisArg, value, key, obj, index);
	});
	return o;
};

},{"./for-each":38,"./valid-callable":45}],44:[function(require,module,exports){
'use strict';

var isCallable = require('./is-callable')
  , callable   = require('./valid-callable')
  , value      = require('./valid-value')

  , call = Function.prototype.call, keys = Object.keys;

module.exports = exports = function self(obj, cb/*, initial, compareFn*/) {
	var list, fn, initial, compareFn, initialized;
	value(obj) && callable(cb);

	obj = Object(obj);
	initial = arguments[2];
	compareFn = arguments[3];

	list = keys(obj);
	if (compareFn) {
		list.sort(isCallable(compareFn) ? compareFn.bind(obj) : undefined);
	}

	fn = function (value, key, index) {
		if (initialized) {
			return call.call(cb, undefined, value, obj[key], key, obj, index);
		} else {
			initialized = true;
			return call.call(cb, undefined, obj[value], obj[key], key, obj, index,
				value);
		}
	};

	if ((arguments.length < 3) || (initial === self.NO_INITIAL)) {
		return list.reduce(fn);
	} else {
		initialized = true;
		return list.reduce(fn, initial);
	}
};
exports.NO_INITIAL = {};

},{"./is-callable":39,"./valid-callable":45,"./valid-value":46}],45:[function(require,module,exports){
'use strict';

var isCallable = require('./is-callable');

module.exports = function (fn) {
	if (!isCallable(fn)) {
		throw new TypeError(fn + " is not a function");
	}
	return fn;
};

},{"./is-callable":39}],46:[function(require,module,exports){
'use strict';

module.exports = function (value) {
	if (value == null) {
		throw new TypeError("Cannot use null or undefined");
	}
	return value;
};

},{}],47:[function(require,module,exports){
'use strict';

var toString = Object.prototype.toString

  , id = toString.call('');

module.exports = function (x) {
	return (typeof x === 'string') || (x && (typeof x === 'object') &&
		((x instanceof String) || (toString.call(x) === id))) || false;
};

},{}],48:[function(require,module,exports){
'use strict';

var indexOf = String.prototype.indexOf;

module.exports = function (searchString/*, position*/) {
	return indexOf.call(this, searchString, arguments[1]) > -1;
};

},{}],49:[function(require,module,exports){
// Not rocket science but taken from:
// http://closure-library.googlecode.com/svn/trunk/closure/goog/string/string.js

'use strict';

var value  = require('../../Object/valid-value')
  , toUint = require('../../Number/to-uint');

module.exports = function (n) {
	return new Array((isNaN(n) ? 1 : toUint(n)) + 1).join(String(value(this)));
};

},{"../../Number/to-uint":33,"../../Object/valid-value":46}],50:[function(require,module,exports){
'use strict';

module.exports = new Function("return this")();

},{}],51:[function(require,module,exports){
// To be used internally, memoize factory

'use strict';

var callable = require('es5-ext/lib/Object/valid-callable')
  , forEach  = require('es5-ext/lib/Object/for-each')
  , ee       = require('event-emitter/lib/core')

  , ext;

module.exports = exports = function (core) {
	return function self(fn/*, options */) {
		var options, length, get, clear, conf;

		callable(fn);
		if (fn.memoized) {
			// Do not memoize already memoized function
			return fn;
		}

		options = Object(arguments[1]);
		conf = ee({ memoize: self, fn: fn });

		// Normalize length
		if (isNaN(options.length)) {
			length = fn.length;
			// Special case
			if (options.async && ext.async) {
				--length;
			}
		} else {
			length = (options.length === false) ? false : (options.length >>> 0);
		}

		core(conf, length);

		forEach(ext, function (fn, name) {
			if (fn.force) {
				fn(conf, options);
			} else if (options[name]) {
				fn(options[name], conf, options);
			}
		});

		fn = conf.fn;
		get = conf.get;
		clear = conf.clear;

		conf.memoized.clear = function () { clear(get(arguments)); };
		conf.memoized.clearAll = function () {
			conf.emit('purgeall');
			conf.clearAll();
		};
		conf.memoized.memoized = true;
		conf.emit('ready');
		return conf.memoized;
	};
};
ext = exports.ext = {};

},{"es5-ext/lib/Object/for-each":38,"es5-ext/lib/Object/valid-callable":45,"event-emitter/lib/core":63}],52:[function(require,module,exports){
// Support for asynchronous functions

'use strict';

var toArray     = require('es5-ext/lib/Array/from')
  , last        = require('es5-ext/lib/Array/prototype/last')
  , isArguments = require('es5-ext/lib/Function/is-arguments')
  , forEach     = require('es5-ext/lib/Object/for-each')
  , isCallable  = require('es5-ext/lib/Object/is-callable')
  , nextTick    = require('next-tick')

  , isArray = Array.isArray, slice = Array.prototype.slice
  , apply = Function.prototype.apply;

require('../_base').ext.async = function (ignore, conf) {
	var cache, purge;

	cache = conf.async = {};

	(function (org) {
		var value, cb, initContext, initArgs, fn, resolver;

		conf.on('init', function (id) {
			value.id = id;
			cache[id] = cb ? [cb] : [];
		});

		conf.on('hit', function (id, syncArgs, syncCtx) {
			if (!cb) {
				return;
			}

			if (isArray(cache[id])) {
				cache[id].push(cb);
			} else {
				nextTick(function (cb, id, ctx, args) {
					if (cache[id]) {
						conf.emit('hitasync', id, syncArgs, syncCtx);
						apply.call(cb, this.context, this);
					} else {
						// Purged in a meantime, we shouldn't rely on cached value, recall
						fn.apply(ctx, args);
					}
				}.bind(cache[id], cb, id, initContext, initArgs));
				initContext = initArgs = null;
			}
		});
		conf.fn = function () {
			var args, asyncArgs;
			args = arguments;
			asyncArgs = toArray(args);
			asyncArgs.push(value = function self(err) {
				var i, cb, waiting, res;
				if (self.id == null) {
					// Shouldn't happen, means async callback was called sync way
					nextTick(apply.bind(self, this, arguments));
					return;
				}
				waiting = cache[self.id];
				if (conf.cache.hasOwnProperty(self.id)) {
					if (err) {
						delete cache[self.id];
						conf.clear(self.id);
					} else {
						arguments.context = this;
						cache[self.id] = arguments;
						conf.emit('initasync', self.id, waiting.length);
					}
				} else {
					delete cache[self.id];
				}
				for (i = 0; (cb = waiting[i]); ++i) {
					res = apply.call(cb, this, arguments);
				}
				return res;
			});
			return apply.call(org, this, asyncArgs);
		};

		fn = conf.memoized;
		resolver = function (args) {
			cb = last.call(args);
			if (isCallable(cb)) {
				return slice.call(args, 0, -1);
			} else {
				cb = null;
				return args;
			}
		};
		conf.memoized = function () {
			return fn.apply(initContext = this, initArgs = resolver(arguments));
		};
		forEach(fn, function (value, name) {
			conf.memoized[name] = function () {
				return fn[name].apply(this, resolver(arguments));
			};
		});

	}(conf.fn));

	conf.on('purge', purge = function (id) {
		// If false, we don't have value yet, so we assume that intention is not
		// to memoize this call. After value is obtained we don't cache it but
		// gracefully pass to callback
		if (isArguments(cache[id])) {
			conf.emit('purgeasync', id);
			delete cache[id];
		}
	});

	conf.on('purgeall', function () {
		forEach(conf.async, function (value, id) { purge(id); });
	});
};

},{"../_base":51,"es5-ext/lib/Array/from":23,"es5-ext/lib/Array/prototype/last":26,"es5-ext/lib/Function/is-arguments":28,"es5-ext/lib/Object/for-each":38,"es5-ext/lib/Object/is-callable":39,"next-tick":65}],53:[function(require,module,exports){
// Call dispose callback on each cache purge

'use strict';

var callable = require('es5-ext/lib/Object/valid-callable')
  , forEach  = require('es5-ext/lib/Object/for-each')
  , ext      = require('../_base').ext

  , slice = Array.prototype.slice;

ext.dispose = function (dispose, conf, options) {
	var clear, async;

	callable(dispose);

	async = (options.async && ext.async);
	conf.on('purge' + (async ? 'async' : ''), clear =  async ? function (id) {
		var value = conf.async[id];
		delete conf.cache[id];
		dispose.apply(conf.memoized['_memoize:context_'], slice.call(value, 1));
	} : function (id) {
		var value = conf.cache[id];
		delete conf.cache[id];
		dispose.call(conf.memoized['_memoize:context_'], value);
	});

	if (!async) {
		conf.on('purgeall', function () {
			forEach(conf.cache, function (value, id) { clear(id); });
		});
	}
};

},{"../_base":51,"es5-ext/lib/Object/for-each":38,"es5-ext/lib/Object/valid-callable":45}],54:[function(require,module,exports){
// Timeout cached values

'use strict';

var isNumber = require('es5-ext/lib/Number/is-number')
  , forEach  = require('es5-ext/lib/Object/for-each')
  , nextTick = require('next-tick')
  , ext      = require('../_base').ext

  , max = Math.max, min = Math.min;

ext.maxAge = function (maxAge, conf, options) {
	var cache, async, preFetchAge, preFetchCache;

	maxAge = maxAge >>> 0;
	if (!maxAge) {
		return;
	}

	cache = {};
	async = options.async && ext.async;
	conf.on('init' + (async ? 'async' : ''), function (id) {
		cache[id] = setTimeout(function () { conf.clear(id); }, maxAge);
		if (preFetchCache) {
			preFetchCache[id] = setTimeout(function () { delete preFetchCache[id]; },
				preFetchAge);
		}
	});
	conf.on('purge' + (async ? 'async' : ''), function (id) {
		clearTimeout(cache[id]);
		if (preFetchCache && preFetchCache[id]) {
			clearTimeout(preFetchCache[id]);
			delete preFetchCache[id];
		}
		delete cache[id];
	});

	if (options.preFetch) {
		if (isNumber(options.preFetch)) {
			preFetchAge = max(min(Number(options.preFetch), 1), 0);
		} else {
			preFetchAge = 0.333;
		}
		if (preFetchAge) {
			preFetchCache = {};
			preFetchAge = (1 - preFetchAge) * maxAge;
			conf.on('hit' + (async ? 'async' : ''), function (id, args, ctx) {
				if (!preFetchCache[id]) {
					preFetchCache[id] = true;
					nextTick(function () {
						if (preFetchCache[id] === true) {
							delete preFetchCache[id];
							conf.clear(id);
							conf.memoized.apply(ctx, args);
						}
					});
				}
			});
		}
	}

	if (!async) {
		conf.on('purgeall', function () {
			forEach(cache, function (id) {
				clearTimeout(id);
			});
			cache = {};
			if (preFetchCache) {
				forEach(preFetchCache, function (id) {
					clearTimeout(id);
				});
				preFetchCache = {};
			}
		});
	}
};

},{"../_base":51,"es5-ext/lib/Number/is-number":31,"es5-ext/lib/Object/for-each":38,"next-tick":65}],55:[function(require,module,exports){
// Limit cache size, LRU (least recently used) algorithm.

'use strict';

var ext = require('../_base').ext;

ext.max = function (max, conf, options) {
	var index, base, size, queue, map, async;

	max = max >>> 0;
	if (!max) {
		return;
	}

	index = -1;
	base = size = 0;
	queue = {};
	map = {};
	async = options.async && ext.async;

	conf.on('init' + (async ? 'async' : ''), function (id) {
		queue[++index] = id;
		map[id] = index;
		++size;
		if (size > max) {
			conf.clear(queue[base]);
		}
	});

	conf.on('hit' + (async ? 'async' : ''), function (id) {
		var oldIndex = map[id];
		queue[++index] = id;
		map[id] = index;
		delete queue[oldIndex];
		if (base === oldIndex) {
			while (!queue.hasOwnProperty(++base)) continue; //jslint: skip
		}
	});

	conf.on('purge' + (async ? 'async' : ''), function (id) {
		var oldIndex = map[id];
		delete queue[oldIndex];
		--size;
		if (base === oldIndex) {
			if (!size) {
				index = -1;
				base = 0;
			} else {
				while (!queue.hasOwnProperty(++base)) continue; //jslint: skip
			}
		}
	});

	if (!async) {
		conf.on('purgeall', function () {
			index = -1;
			base = size = 0;
			queue = {};
			map = {};
		});
	}
};

},{"../_base":51}],56:[function(require,module,exports){
// Memoized methods factory

'use strict';

var d        = require('es5-ext/lib/Object/descriptor')
  , global   = require('es5-ext/lib/global')
  , extend   = require('es5-ext/lib/Object/extend')
  , isString = require('es5-ext/lib/String/is-string')

  , create = Object.create, defineProperty = Object.defineProperty;

require('../_base').ext.method = function (method, conf, options) {
	if (isString(options.method)) {
		method = { name: String(options.method),
			descriptor: { configurable: true, writable: true } };
	} else {
		method = options.method;
		method.name = String(method.name);
		method.descriptor = (method.descriptor == null) ?
				{ configurable: true, writable: true } : Object(method.descriptor);
	}
	options = create(options);
	options.method = undefined;

	(function (fn) {
		conf.memoized = function () {
			var memoized;
			if (this && (this !== global)) {
				memoized = method.descriptor.value =
					conf.memoize(conf.fn.bind(this), options);
				defineProperty(this, method.name, method.descriptor);
				defineProperty(memoized, '_memoize:context_', d(this));
				return memoized.apply(this, arguments);
			}
			return fn.apply(this, arguments);
		};
		extend(conf.memoized, fn);
	}(conf.memoized));
};

},{"../_base":51,"es5-ext/lib/Object/descriptor":36,"es5-ext/lib/Object/extend":37,"es5-ext/lib/String/is-string":47,"es5-ext/lib/global":50}],57:[function(require,module,exports){
// Reference counter, useful for garbage collector like functionality

'use strict';

var ext = require('../_base').ext;

ext.refCounter = function (ignore, conf, options) {
	var cache, async;

	cache = {};
	async = options.async && ext.async;

	conf.on('init' + (async ? 'async' : ''), async ? function (id, length) {
		cache[id] = length;
	} : function (id) { cache[id] = 1; });
	conf.on('hit' + (async ? 'async' : ''), function (id) { ++cache[id]; });
	conf.on('purge' + (async ? 'async' : ''), function (id) {
		delete cache[id];
	});
	if (!async) {
		conf.on('purgeall', function () { cache = {}; });
	}

	conf.memoized.clearRef = function () {
		var id = conf.get(arguments);
		if (cache.hasOwnProperty(id)) {
			if (!--cache[id]) {
				conf.clear(id);
				return true;
			}
			return false;
		}
		return null;
	};
};

},{"../_base":51}],58:[function(require,module,exports){
// Normalize arguments before passing them to underlying function

'use strict';

var toArray    = require('es5-ext/lib/Array/from')
  , forEach    = require('es5-ext/lib/Object/for-each')
  , callable   = require('es5-ext/lib/Object/valid-callable')

  , slice = Array.prototype.slice

  , resolve;

resolve = function (args) {
	return this.map(function (r, i) {
		return r ? r(args[i]) : args[i];
	}).concat(slice.call(args, this.length));
};

require('../_base').ext.resolvers = function (resolvers, conf) {
	var resolver;

	resolver = toArray(resolvers);
	resolver.forEach(function (r) { (r == null) || callable(r); });
	resolver = resolve.bind(resolver);

	(function (fn) {
		conf.memoized = function () {
			var value;
			conf.memoized.args = arguments;
			value = fn.apply(this, resolver(arguments));
			delete conf.memoized.args;
			return value;
		};
		forEach(fn, function (value, name) {
			conf.memoized[name] = function () {
				return fn[name].apply(this, resolver(arguments));
			};
		});
	}(conf.memoized));
};

},{"../_base":51,"es5-ext/lib/Array/from":23,"es5-ext/lib/Object/for-each":38,"es5-ext/lib/Object/valid-callable":45}],59:[function(require,module,exports){
// Provides memoize with all options

'use strict';

var regular   = require('./regular')
  , primitive = require('./primitive')

  , call = Function.prototype.call;

// Order is significant!
require('./ext/dispose');
require('./ext/resolvers');
require('./ext/async');
require('./ext/ref-counter');
require('./ext/method');
require('./ext/max-age');
require('./ext/max');

module.exports = function (fn/* options */) {
	var options = Object(arguments[1]);
	return call.call(options.primitive ? primitive : regular, this, fn, options);
};

},{"./ext/async":52,"./ext/dispose":53,"./ext/max":55,"./ext/max-age":54,"./ext/method":56,"./ext/ref-counter":57,"./ext/resolvers":58,"./primitive":60,"./regular":61}],60:[function(require,module,exports){
// Memoize working in primitive mode

'use strict';

var CustomError  = require('es5-ext/lib/Error/custom')
  , hasListeners = require('event-emitter/lib/has-listeners')

  , getId0 = function () { return ''; }
  , getId1 = function (args) { return args[0]; }

  , apply = Function.prototype.apply, call = Function.prototype.call;

module.exports = require('./_base')(function (conf, length) {
	var get, cache = conf.cache = {}, fn
	  , hitListeners, initListeners, purgeListeners;

	if (length === 1) {
		get = conf.get = getId1;
	} else if (length === false) {
		get = conf.get = function (args) {
			var id = '', i, length = args.length;
			if (length) {
				id += args[i = 0];
				while (--length) {
					id += '\u0001' + args[++i];
				}
			} else {
				id = '\u0002';
			}
			return id;
		};
	} else if (length) {
		get = conf.get = function (args) {
			var id = String(args[0]), i = 0, l = length;
			while (--l) { id += '\u0001' + args[++i]; }
			return id;
		};
	} else {
		get = conf.get = getId0;
	}

	conf.memoized = (length === 1) ? function (id) {
		var value;
		if (cache.hasOwnProperty(id)) {
			hitListeners && conf.emit('hit', id, arguments, this);
			return cache[id];
		} else {
			if (arguments.length === 1) {
				value = call.call(fn, this, id);
			} else {
				value = apply.call(fn, this, arguments);
			}
			if (cache.hasOwnProperty(id)) {
				throw new CustomError("Circular invocation", 'CIRCULAR_INVOCATION');
			}
			cache[id] = value;
			initListeners && conf.emit('init', id);
			return value;
		}
	} : function () {
		var id = get(arguments), value;
		if (cache.hasOwnProperty(id)) {
			hitListeners && conf.emit('hit', id, arguments, this);
			return cache[id];
		} else {
			value = apply.call(conf.fn, this, arguments);
			if (cache.hasOwnProperty(id)) {
				throw new CustomError("Circular invocation", 'CIRCULAR_INVOCATION');
			}
			cache[id] = value;
			initListeners && conf.emit('init', id);
			return value;
		}
	};

	conf.clear = function (id) {
		if (cache.hasOwnProperty(id)) {
			purgeListeners && conf.emit('purge', id);
			delete cache[id];
		}
	};
	conf.clearAll = function () { cache = conf.cache = {}; };

	conf.once('ready', function () {
		fn = conf.fn;
		hitListeners = hasListeners(conf, 'hit');
		initListeners = hasListeners(conf, 'init');
		purgeListeners = hasListeners(conf, 'purge');
	});
});

},{"./_base":51,"es5-ext/lib/Error/custom":27,"event-emitter/lib/has-listeners":64}],61:[function(require,module,exports){
// Memoize working in object mode (supports any type of arguments)

'use strict';

var CustomError  = require('es5-ext/lib/Error/custom')
  , indexOf      = require('es5-ext/lib/Array/prototype/e-index-of')
  , hasListeners = require('event-emitter/lib/has-listeners')

  , apply = Function.prototype.apply;

// Results are saved internally within array matrix:
// [0] -> Result of calling function with no arguments
// [1] -> Matrix that keeps results when function is called with one argument
//        [1][0] -> Array of arguments with which
//                 function have been called
//        [1][1] -> Array of results that matches [1][0] array
// [2] -> Matrix that keeps results when function is called with two arguments
//        [2][0] -> Array of first (of two) arguments with which
//                function have been called
//        [2][1] -> Matrixes that keeps results for two arguments function calls
//                  Each matrix matches first argument found in [2][0]
//                  [2][1][x][0] -> Array of second arguments with which
//                                  function have been called.
//                  [2][1][x][1] -> Array of results that matches [2][1][x][0]
//                                   arguments array
// ...and so on
module.exports = require('./_base')(function (conf, length) {
	var map, map1, map2, get, set, clear, count, fn
	  , hitListeners, initListeners, purgeListeners
	  , cache = conf.cache = {}, argsCache;

	if (length === 0) {
		map = null;
		get = conf.get = function () { return map; };
		set = function () { return ((map = 1)); };
		clear = function () { map = null; };
		conf.clearAll = function () {
			map = null;
			cache = conf.cache = {};
		};
	} else {
		count = 0;
		if (length === 1) {
			map1 = [];
			map2 = [];
			get = conf.get = function (args) {
				var index = indexOf.call(map1, args[0]);
				return (index === -1) ? null : map2[index];
			};
			set = function (args) {
				map1.push(args[0]);
				map2.push(++count);
				return count;
			};
			clear = function (id) {
				var index = indexOf.call(map2, id);
				if (index !== -1) {
					map1.splice(index, 1);
					map2.splice(index, 1);
				}
			};
			conf.clearAll = function () {
				map1 = [];
				map2 = [];
				cache = conf.cache = {};
			};
		} else if (length === false) {
			map = [];
			argsCache = {};
			get = conf.get = function (args) {
				var index = 0, set = map, i, length = args.length;
				if (length === 0) {
					return set[length] || null;
				} else if ((set = set[length])) {
					while (index < (length - 1)) {
						i = indexOf.call(set[0], args[index]);
						if (i === -1) return null;
						set = set[1][i];
						++index;
					}
					i = indexOf.call(set[0], args[index]);
					if (i === -1) return null;
					return set[1][i] || null;
				}
				return null;
			};
			set = function (args) {
				var index = 0, set = map, i, length = args.length;
				if (length === 0) {
					set[length] = ++count;
				} else {
					if (!set[length]) {
						set[length] = [[], []];
					}
					set = set[length];
					while (index < (length - 1)) {
						i = indexOf.call(set[0], args[index]);
						if (i === -1) {
							i = set[0].push(args[index]) - 1;
							set[1].push([[], []]);
						}
						set = set[1][i];
						++index;
					}
					i = indexOf.call(set[0], args[index]);
					if (i === -1) {
						i = set[0].push(args[index]) - 1;
					}
					set[1][i] = ++count;
				}
				argsCache[count] = args;
				return count;
			};
			clear = function (id) {
				var index = 0, set = map, i, args = argsCache[id], length = args.length
				  , path = [];
				if (length === 0) {
					delete set[length];
				} else if ((set = set[length])) {
					while (index < (length - 1)) {
						i = indexOf.call(set[0], args[index]);
						if (i === -1) {
							return;
						}
						path.push(set, i);
						set = set[1][i];
						++index;
					}
					i = indexOf.call(set[0], args[index]);
					if (i === -1) {
						return;
					}
					id = set[1][i];
					set[0].splice(i, 1);
					set[1].splice(i, 1);
					while (!set[0].length && path.length) {
						i = path.pop();
						set = path.pop();
						set[0].splice(i, 1);
						set[1].splice(i, 1);
					}
				}
				delete argsCache[id];
			};
			conf.clearAll = function () {
				map = [];
				cache = conf.cache = {};
				argsCache = {};
			};
		} else {
			map = [[], []];
			argsCache = {};
			get = conf.get = function (args) {
				var index = 0, set = map, i;
				while (index < (length - 1)) {
					i = indexOf.call(set[0], args[index]);
					if (i === -1) return null;
					set = set[1][i];
					++index;
				}
				i = indexOf.call(set[0], args[index]);
				if (i === -1) return null;
				return set[1][i] || null;
			};
			set = function (args) {
				var index = 0, set = map, i;
				while (index < (length - 1)) {
					i = indexOf.call(set[0], args[index]);
					if (i === -1) {
						i = set[0].push(args[index]) - 1;
						set[1].push([[], []]);
					}
					set = set[1][i];
					++index;
				}
				i = indexOf.call(set[0], args[index]);
				if (i === -1) {
					i = set[0].push(args[index]) - 1;
				}
				set[1][i] = ++count;
				argsCache[count] = args;
				return count;
			};
			clear = function (id) {
				var index = 0, set = map, i, path = [], args = argsCache[id];
				while (index < (length - 1)) {
					i = indexOf.call(set[0], args[index]);
					if (i === -1) {
						return;
					}
					path.push(set, i);
					set = set[1][i];
					++index;
				}
				i = indexOf.call(set[0], args[index]);
				if (i === -1) {
					return;
				}
				id = set[1][i];
				set[0].splice(i, 1);
				set[1].splice(i, 1);
				while (!set[0].length && path.length) {
					i = path.pop();
					set = path.pop();
					set[0].splice(i, 1);
					set[1].splice(i, 1);
				}
				delete argsCache[id];
			};
			conf.clearAll = function () {
				map = [[], []];
				cache = conf.cache = {};
				argsCache = {};
			};
		}
	}
	conf.memoized = function () {
		var id = get(arguments), value;
		if (id != null) {
			hitListeners && conf.emit('hit', id, arguments, this);
			return cache[id];
		} else {
			value = apply.call(fn, this, arguments);
			id = get(arguments);
			if (id != null) {
				throw new CustomError("Circular invocation", 'CIRCULAR_INVOCATION');
			}
			id = set(arguments);
			cache[id] = value;
			initListeners && conf.emit('init', id);
			return value;
		}
	};
	conf.clear = function (id) {
		if (cache.hasOwnProperty(id)) {
			purgeListeners && conf.emit('purge', id);
			clear(id);
			delete cache[id];
		}
	};

	conf.once('ready', function () {
		fn = conf.fn;
		hitListeners = hasListeners(conf, 'hit');
		initListeners = hasListeners(conf, 'init');
		purgeListeners = hasListeners(conf, 'purge');
	});
});

},{"./_base":51,"es5-ext/lib/Array/prototype/e-index-of":24,"es5-ext/lib/Error/custom":27,"event-emitter/lib/has-listeners":64}],62:[function(require,module,exports){
'use strict';

module.exports = '_ee2_';

},{}],63:[function(require,module,exports){
'use strict';

var d        = require('es5-ext/lib/Object/descriptor')
  , callable = require('es5-ext/lib/Object/valid-callable')
  , id       = require('./_id')

  , apply = Function.prototype.apply, call = Function.prototype.call
  , create = Object.create, defineProperty = Object.defineProperty
  , defineProperties = Object.defineProperties
  , descriptor = { configurable: true, enumerable: false, writable: true }

  , on, once, off, emit
  , colId, methods, descriptors, base;

colId = id + 'l_';

on = function (type, listener) {
	var data;

	callable(listener);

	if (!this.hasOwnProperty(id)) {
		data = descriptor.value = {};
		defineProperty(this, id, descriptor);
		descriptor.value = null;
	} else {
		data = this[id];
	}
	if (!data.hasOwnProperty(type)) data[type] = listener;
	else if (data[type].hasOwnProperty(colId)) data[type].push(listener);
	else (data[type] = [data[type], listener])[colId] = true;

	return this;
};

once = function (type, listener) {
	var once, self;

	callable(listener);
	self = this;
	on.call(this, type, once = function () {
		off.call(self, type, once);
		apply.call(listener, this, arguments);
	});

	once._listener = listener;
	return this;
};

off = function (type, listener) {
	var data, listeners, candidate, i;

	callable(listener);

	if (!this.hasOwnProperty(id)) return this;
	data = this[id];
	if (!data.hasOwnProperty(type)) return this;
	listeners = data[type];

	if (listeners.hasOwnProperty(colId)) {
		for (i = 0; (candidate = listeners[i]); ++i) {
			if ((candidate === listener) || (candidate._listener === listener)) {
				if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
				else listeners.splice(i, 1);
			}
		}
	} else {
		if ((listeners === listener) || (listeners._listener === listener)) {
			delete data[type];
		}
	}

	return this;
};

emit = function (type) {
	var data, i, l, listener, listeners, args;

	if (!this.hasOwnProperty(id)) return;
	data = this[id];
	if (!data.hasOwnProperty(type)) return;
	listeners = data[type];

	if (listeners.hasOwnProperty(colId)) {
		l = arguments.length;
		args = new Array(l - 1);
		for (i = 1; i < l; ++i) {
			args[i - 1] = arguments[i];
		}

		listeners = listeners.slice();
		for (i = 0; (listener = listeners[i]); ++i) {
			apply.call(listener, this, args);
		}
	} else {
		switch (arguments.length) {
		case 1:
			call.call(listeners, this);
			break;
		case 2:
			call.call(listeners, this, arguments[1]);
			break;
		case 3:
			call.call(listeners, this, arguments[1], arguments[2]);
			break;
		default:
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) {
				args[i - 1] = arguments[i];
			}
			apply.call(listeners, this, args);
		}
	}
};

methods = {
	on: on,
	once: once,
	off: off,
	emit: emit
};

descriptors = {
	on: d(on),
	once: d(once),
	off: d(off),
	emit: d(emit)
};

base = defineProperties({}, descriptors);

module.exports = exports = function (o) {
	return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
};
exports.methods = methods;

},{"./_id":62,"es5-ext/lib/Object/descriptor":36,"es5-ext/lib/Object/valid-callable":45}],64:[function(require,module,exports){
'use strict';

var isEmpty = require('es5-ext/lib/Object/is-empty')
  , value   = require('es5-ext/lib/Object/valid-value')
  , id      = require('./_id');

module.exports = function (obj/*, type*/) {
	var type;
	value(obj);
	type = arguments[1];
	if (arguments.length > 1) {
		return obj.hasOwnProperty(id) && obj[id].hasOwnProperty(type);
	} else {
		return obj.hasOwnProperty(id) && !isEmpty(obj[id]);
	}
};

},{"./_id":62,"es5-ext/lib/Object/is-empty":40,"es5-ext/lib/Object/valid-value":46}],65:[function(require,module,exports){
'use strict';

if ((typeof process !== 'undefined') && process &&
		(typeof process.nextTick === 'function')) {

	// Node.js
	module.exports = process.nextTick;

} else if (typeof setImmediate === 'function') {

	// W3C Draft
	// https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html
	module.exports = function (cb) { setImmediate(cb); };

} else {

	// Wide available standard
	module.exports = function (cb) { setTimeout(cb, 0); };
}

},{}],66:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var attrMap, getNodeAtPath;
  attrMap = require('grasp-syntax-javascript').attrMap;
  getNodeAtPath = function(node, path){
    var i$, len$, prop, that;
    for (i$ = 0, len$ = path.length; i$ < len$; ++i$) {
      prop = path[i$];
      if ((that = node[attrMap[prop] || prop]) != null) {
        node = that;
      } else {
        return;
      }
    }
    return node;
  };
  module.exports = {
    getNodeAtPath: getNodeAtPath
  };
}).call(this);

},{"grasp-syntax-javascript":11}],67:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var parse, matchNode, VERSION, query, queryParsed;
  parse = require('./parse').parse;
  matchNode = require('./match').matchNode;
  VERSION = '0.1.0';
  query = function(selector, ast){
    return queryParsed(parse(selector), ast);
  };
  queryParsed = function(parsedSelector, ast){
    var results;
    results = [];
    matchNode(results, parsedSelector, ast);
    return results;
  };
  module.exports = {
    parse: parse,
    queryParsed: queryParsed,
    query: query,
    VERSION: VERSION
  };
}).call(this);

},{"./match":68,"./parse":69}],68:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var ref$, primitiveOnlyAttributes, eitherAttributes, all, tail, getNodeAtPath, toString$ = {}.toString, slice$ = [].slice;
  ref$ = require('grasp-syntax-javascript'), primitiveOnlyAttributes = ref$.primitiveOnlyAttributes, eitherAttributes = ref$.eitherAttributes;
  ref$ = require('prelude-ls'), all = ref$.all, tail = ref$.tail;
  getNodeAtPath = require('./common').getNodeAtPath;
  function matchNode(results, query, mainNode){
    var key, val, ref$;
    if (eq(mainNode, query)) {
      results.push(mainNode);
    }
    for (key in mainNode) {
      val = mainNode[key];
      if ((key !== 'loc' && key !== 'start' && key !== 'end' && key !== '_named') && ((ref$ = toString$.call(val).slice(8, -1)) === 'Object' || ref$ === 'Array')) {
        matchNode(results, query, val);
      }
    }
    function eq(targetNode, selectorNode){
      var selectorNodeType, prop;
      selectorNodeType = toString$.call(selectorNode).slice(8, -1);
      if (selectorNode === targetNode) {
        return true;
      } else if (selectorNodeType !== toString$.call(targetNode).slice(8, -1)) {
        return false;
      } else if (selectorNodeType === 'Object') {
        if (selectorNode.type === 'Grasp') {
          return matchSpecial(targetNode, selectorNode);
        } else {
          for (prop in targetNode) {
            if (prop !== 'loc' && prop !== 'start' && prop !== 'end' && prop !== '_named') {
              if (!eq(targetNode[prop], selectorNode[prop])) {
                return false;
              }
            }
          }
          return true;
        }
      } else if (selectorNodeType === 'Array') {
        return matchArray(selectorNode, targetNode);
      } else {
        return false;
      }
    }
    function matchArray(pattern, input){
      var patternLen, that, ref$, patternFirst, patternRest, inputFirst, inputRest, arrayWildcardName, wildcardName;
      patternLen = pattern.length;
      if (patternLen === 0) {
        return input.length === 0;
      } else if (patternLen === 1) {
        if (that = isArrayWildcard(pattern[0])) {
          if (that = that.name) {
            mainNode._named == null && (mainNode._named = {});
            (ref$ = mainNode._named)[that] == null && (ref$[that] = []);
            (ref$ = mainNode._named)[that] = ref$[that].concat(input);
          }
          return true;
        } else {
          return input.length === 1 && eq(input[0], pattern[0]);
        }
      } else if (input.length === 0) {
        return false;
      } else {
        patternFirst = pattern[0], patternRest = slice$.call(pattern, 1);
        inputFirst = input[0], inputRest = slice$.call(input, 1);
        if (that = isArrayWildcard(patternFirst)) {
          if (that = that.name) {
            arrayWildcardName = that;
            mainNode._named == null && (mainNode._named = {});
            (ref$ = mainNode._named)[arrayWildcardName] == null && (ref$[arrayWildcardName] = []);
          }
          if (that = eq(inputFirst, patternRest[0])) {
            wildcardName = that;
            if (matchArray(tail(patternRest), inputRest)) {
              return true;
            } else {
              if (toString$.call(wildcardName).slice(8, -1) === 'String') {
                delete mainNode._named[wildcardName];
              }
              return matchArray(pattern, inputRest);
            }
          } else {
            if (arrayWildcardName) {
              mainNode._named[arrayWildcardName].push(inputFirst);
            }
            return matchArray(pattern, inputRest);
          }
        } else {
          return eq(inputFirst, patternFirst) && matchArray(patternRest, inputRest);
        }
      }
    }
    function matchSpecial(targetNode, selectorNode){
      var named, name, that, identMatch, attrMatch;
      switch (selectorNode.graspType) {
      case 'wildcard':
        return true;
      case 'named-wildcard':
        mainNode._named == null && (mainNode._named = {});
        named = mainNode._named;
        name = selectorNode.name;
        if (that = named[name]) {
          if (eq(targetNode, that)) {
            return true;
          } else {
            return false;
          }
        } else {
          named[name] = targetNode;
          return name;
        }
        break;
      case 'node-type':
        return targetNode.type === selectorNode.value;
      case 'matches':
        return in$(targetNode.type, selectorNode.value);
      case 'literal':
        return targetNode.type === 'Literal' && toString$.call(targetNode.value).slice(8, -1) === selectorNode.value;
      case 'compound':
        identMatch = matchSpecial(targetNode, selectorNode.ident);
        attrMatch = all(matchAttr(targetNode), selectorNode.attrs);
        return identMatch && attrMatch;
      }
    }
    function isArrayWildcard(node){
      var cleanNode;
      cleanNode = node.type === 'ExpressionStatement' ? node.expression : node;
      return cleanNode.type === 'Grasp' && cleanNode.graspType === 'array-wildcard' && cleanNode;
    }
    function matchAttr(targetNode){
      return function(attr){
        var node, attrValue, lastPath, ref$;
        node = getNodeAtPath(targetNode, attr.path);
        if (node != null) {
          attrValue = attr.value;
          if (attrValue) {
            lastPath = (ref$ = attr.path)[ref$.length - 1];
            if (in$(lastPath, primitiveOnlyAttributes)) {
              return matchPrimitive(attr.op, node, attrValue);
            } else if (in$(lastPath, eitherAttributes)) {
              return matchEither(attr.op, node, attrValue);
            } else {
              return matchComplex(attr.op, node, attrValue);
            }
          } else {
            return true;
          }
        } else {
          return false;
        }
      };
    }
    function matchPrimitive(op, node, attrValue){
      if (op === '=') {
        return node === attrValue.value;
      } else {
        return node !== attrValue.value;
      }
    }
    function matchComplex(op, node, attrValue){
      if (op === '=') {
        return eq(node, attrValue);
      } else {
        return !eq(node, attrValue);
      }
    }
    function matchEither(op, node, attrValue){
      return matchPrimitive(op, node, attrValue) || matchComplex(op, node, attrValue);
    }
  }
  module.exports = {
    matchNode: matchNode
  };
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);

},{"./common":66,"grasp-syntax-javascript":11,"prelude-ls":91}],69:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var acorn, ref$, aliasMap, matchesMap, matchesAliasMap, literalMap, getNodeAtPath, toString$ = {}.toString;
  acorn = require('acorn');
  ref$ = require('grasp-syntax-javascript'), aliasMap = ref$.aliasMap, matchesMap = ref$.matchesMap, matchesAliasMap = ref$.matchesAliasMap, literalMap = ref$.literalMap;
  getNodeAtPath = require('./common').getNodeAtPath;
  function parse(selector){
    var attempts, i$, len$, attempt, code, parsedSelector, path, e, selectorBody, extractedSelector, finalSelector, root;
    attempts = [
      {
        code: selector,
        path: []
      }, {
        code: "function f(){ " + selector + "; }",
        path: ['body', 'body', 0]
      }, {
        code: "(" + selector + ")",
        path: []
      }, {
        code: "while (true) { " + selector + "; }",
        path: ['body', 'body', 0]
      }, {
        code: "switch (x) { " + selector + " }",
        path: ['cases', 0]
      }, {
        code: "try { } " + selector,
        path: ['handlers', 0]
      }
    ];
    for (i$ = 0, len$ = attempts.length; i$ < len$; ++i$) {
      attempt = attempts[i$], code = attempt.code;
      try {
        parsedSelector = acorn.parse(code);
        path = attempt.path;
        break;
      } catch (e$) {
        e = e$;
        continue;
      }
    }
    if (!parsedSelector) {
      throw new Error("Error processing selector '" + selector + "'.");
    }
    selectorBody = parsedSelector.body;
    if (selectorBody.length > 1) {
      throw new Error("Selector body can't be more than one statement");
    }
    extractedSelector = getNodeAtPath(selectorBody[0], path);
    finalSelector = extractedSelector.type === 'ExpressionStatement' && !/;\s*$/.test(selector) ? extractedSelector.expression : extractedSelector;
    root = {
      type: 'Root',
      value: finalSelector
    };
    processSelector(root);
    return root.value;
  }
  function processSelector(ast){
    var key, node, nodeType, i$, len$, i, n, that;
    delete ast.start;
    delete ast.end;
    for (key in ast) {
      node = ast[key];
      if (key !== 'type') {
        nodeType = toString$.call(node).slice(8, -1);
        if (nodeType === 'Array') {
          for (i$ = 0, len$ = node.length; i$ < len$; ++i$) {
            i = i$;
            n = node[i$];
            if (that = processNode(n)) {
              node[i] = that;
            } else {
              processSelector(n);
            }
          }
        } else if (nodeType === 'Object') {
          if (that = processNode(node)) {
            ast[key] = that;
          } else {
            processSelector(node);
          }
        }
      }
    }
  }
  function processNode(node){
    var name, that, ident, attrs, n, processedAttrs, i$, len$, attr, nodeKey, nodeValue;
    switch (node.type) {
    case 'Identifier':
      name = node.name;
      if (name === '_') {
        return null;
      } else if (name === '__') {
        return {
          type: 'Grasp',
          graspType: 'wildcard'
        };
      } else if (that = /^_\$(\w*)$/.exec(name)) {
        return {
          type: 'Grasp',
          graspType: 'array-wildcard',
          name: that[1]
        };
      } else if (that = /^\$(\w+)$/.exec(name)) {
        return {
          type: 'Grasp',
          graspType: 'named-wildcard',
          name: that[1]
        };
      } else if (that = /^_([_a-zA-Z]+)/.exec(name)) {
        ident = that[1].replace(/_/, '-');
        if (ident in matchesMap || ident in matchesAliasMap) {
          return {
            type: 'Grasp',
            graspType: 'matches',
            value: matchesMap[matchesAliasMap[ident] || ident]
          };
        } else if (ident in literalMap) {
          return {
            type: 'Grasp',
            graspType: 'literal',
            value: literalMap[ident]
          };
        } else {
          return {
            type: 'Grasp',
            graspType: 'node-type',
            value: aliasMap[ident] || ident
          };
        }
      }
      break;
    case 'MemberExpression':
      if (!node.computed) {
        return;
      }
      attrs = [];
      n = node;
      while (n.type === 'MemberExpression') {
        if (!n.computed) {
          return;
        }
        attrs.unshift(n.property);
        n = n.object;
      }
      if (n.type !== 'Identifier') {
        return;
      }
      ident = processNode(n);
      if (!ident) {
        return;
      }
      processedAttrs = [];
      for (i$ = 0, len$ = attrs.length; i$ < len$; ++i$) {
        attr = attrs[i$];
        if (that = processAttr(attr)) {
          processedAttrs.push(that);
        } else {
          return;
        }
      }
      return {
        type: 'Grasp',
        graspType: 'compound',
        ident: ident,
        attrs: processedAttrs
      };
    case 'ExpressionStatement':
      return processNode(node.expression);
    default:
      if (!(!node.type && node.key != null && node.value != null)) {
        return;
      }
      nodeKey = node.key, nodeValue = node.value;
      if (!(nodeKey.type === 'Identifier' && nodeValue.type === 'Identifier')) {
        return;
      }
      if (nodeKey.name === '_') {
        if (node.value.name === '_') {
          return {
            type: 'Grasp',
            graspType: 'wildcard'
          };
        } else if (/^\$/.test(nodeValue.name)) {
          return {
            type: 'Grasp',
            graspType: 'array-wildcard',
            name: /^\$(\w*)$/.exec(nodeValue.name)[1]
          };
        }
      } else if (nodeKey.name === '$') {
        return {
          type: 'Grasp',
          graspType: 'named-wildcard',
          name: nodeValue.name
        };
      }
    }
  }
  function processAttr(attr){
    var attrType, path, ref$;
    attrType = attr.type;
    if (attrType === 'Identifier') {
      return {
        path: [attr.name]
      };
    } else if (attrType === 'MemberExpression') {
      path = getMemberPath(attr);
      if (!path) {
        return;
      }
      return {
        path: path
      };
    } else if ((attrType === 'AssignmentExpression' || attrType === 'BinaryExpression') && ((ref$ = attr.operator) === '=' || ref$ === '!=')) {
      path = getMemberPath(attr.left);
      if (!path) {
        return;
      }
      return {
        path: path,
        op: attr.operator,
        value: attr.right
      };
    }
  }
  function getMemberPath(node){
    var path;
    path = [];
    while (node.type === 'MemberExpression') {
      if (node.computed) {
        return;
      }
      path.unshift(node.property.name);
      node = node.object;
    }
    path.unshift(node.name);
    return path;
  }
  module.exports = {
    parse: parse
  };
}).call(this);

},{"./common":66,"acorn":18,"grasp-syntax-javascript":11}],70:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var syntaxFlat, toString$ = {}.toString;
  syntaxFlat = require('grasp-syntax-javascript').syntaxFlat;
  function Cache(ast){
    var nodes, types;
    this.ast = ast;
    nodes = [];
    types = [];
    visitPre(ast, function(node){
      var type, i$, ref$, len$, property;
      type = node.type;
      if (type === 'ObjectExpression') {
        for (i$ = 0, len$ = (ref$ = node.properties).length; i$ < len$; ++i$) {
          property = ref$[i$];
          property.type = 'Property';
          property.start = property.key.start;
          property.end = property.value.end;
          if (property.key.loc) {
            property.loc = {
              start: property.key.loc.start,
              end: property.value.loc.end
            };
          }
        }
      }
      nodes.push(node);
      types[type] == null && (types[type] = []);
      types[type].push(node);
    });
    this.nodes = nodes;
    this.types = types;
  }
  function visitPre(ast, fn, path){
    var ref$, nodes, nodeArrays, i$, len$, nodeName, node, newPath, nodeArrayName, nodeArray, j$, len1$;
    fn(ast, path);
    ref$ = syntaxFlat[ast.type], nodes = ref$.nodes, nodeArrays = ref$.nodeArrays;
    if (nodes) {
      for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
        nodeName = nodes[i$];
        node = ast[nodeName];
        if (!node) {
          continue;
        }
        newPath = path ? path + "." + nodeName : nodeName;
        visitPre(node, fn, newPath);
      }
    }
    if (nodeArrays) {
      for (i$ = 0, len$ = nodeArrays.length; i$ < len$; ++i$) {
        nodeArrayName = nodeArrays[i$];
        nodeArray = ast[nodeArrayName];
        newPath = path ? path + "." + nodeArrayName : nodeArrayName;
        for (j$ = 0, len1$ = nodeArray.length; j$ < len1$; ++j$) {
          node = nodeArray[j$];
          visitPre(node, fn, newPath);
        }
      }
    }
  }
  function visitChildren(ast, fn){
    var ref$, nodes, nodeArrays, i$, len$, nodeName, nodeArrayName, j$, len1$, node;
    ref$ = syntaxFlat[ast.type], nodes = ref$.nodes, nodeArrays = ref$.nodeArrays;
    if (nodes) {
      for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
        nodeName = nodes[i$];
        fn(ast[nodeName]);
      }
    }
    if (nodeArrays) {
      for (i$ = 0, len$ = nodeArrays.length; i$ < len$; ++i$) {
        nodeArrayName = nodeArrays[i$];
        for (j$ = 0, len1$ = (ref$ = ast[nodeArrayName]).length; j$ < len1$; ++j$) {
          node = ref$[j$];
          fn(node);
        }
      }
    }
  }
  function getPath(obj, key){
    var value, i$, ref$, len$, k, newValue;
    value = obj;
    for (i$ = 0, len$ = (ref$ = key.split('.')).length; i$ < len$; ++i$) {
      k = ref$[i$];
      newValue = value[k];
      if (toString$.call(newValue).slice(8, -1) !== 'Undefined') {
        value = newValue;
      } else {
        return;
      }
    }
    return value;
  }
  module.exports = {
    Cache: Cache,
    visitPre: visitPre,
    visitChildren: visitChildren,
    getPath: getPath
  };
}).call(this);

},{"grasp-syntax-javascript":11}],71:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var VERSION, Cache, parse, ref$, finalMatches, matchAst, queryParsed, query;
  VERSION = '0.1.0';
  Cache = require('./common').Cache;
  parse = require('./parse').parse;
  ref$ = require('./match'), finalMatches = ref$.finalMatches, matchAst = ref$.matchAst;
  queryParsed = function(parsedSelector, ast, cache){
    return finalMatches(matchAst(ast, parsedSelector, cache || new Cache(ast)));
  };
  query = function(selector, ast, cache){
    return queryParsed(parse(selector), ast, cache);
  };
  module.exports = {
    parse: parse,
    queryParsed: queryParsed,
    query: query,
    Cache: Cache,
    VERSION: VERSION
  };
}).call(this);

},{"./common":70,"./match":72,"./parse":73}],72:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var ref$, map, any, all, literalMap, syntaxFlat, Cache, visitPre, visitChildren, getPath, toString$ = {}.toString, slice$ = [].slice;
  ref$ = require('prelude-ls'), map = ref$.map, any = ref$.any, all = ref$.all;
  ref$ = require('grasp-syntax-javascript'), literalMap = ref$.literalMap, syntaxFlat = ref$.syntaxFlat;
  ref$ = require('./common'), Cache = ref$.Cache, visitPre = ref$.visitPre, visitChildren = ref$.visitChildren, getPath = ref$.getPath;
  function finalMatches(results){
    var matches, i$, ref$, len$, subjects;
    matches = [];
    if (results.subject.length > 0) {
      for (i$ = 0, len$ = (ref$ = results.subject).length; i$ < len$; ++i$) {
        subjects = ref$[i$];
        matches = matches.concat(subjects);
      }
    } else {
      matches = results.matches;
    }
    return matches;
  }
  function matchAst(ast, selector, cache){
    var subject, matches, isSubject, i$, ref$, len$, node, selVal, name, op, value, valueType, sel, left, props, subjects, leftResults, leftSubject, result, subs, propsLen, hasMatch, previousNode, j$, len1$, i, prop, newNode, k$, len2$, p, nodeInfo, l$, len3$, field, res$, propValue, sub, matchesSelector, ref1$, rightResults, leftMatches, rightSubject, rightMatches, leftI, leftNode;
    subject = [];
    matches = [];
    if (!selector) {
      return {
        subject: subject,
        matches: matches
      };
    }
    isSubject = selector.subject;
    switch (selector.type) {
    case 'wildcard':
      for (i$ = 0, len$ = (ref$ = cache.nodes).length; i$ < len$; ++i$) {
        node = ref$[i$];
        matches.push(node);
        if (isSubject) {
          subject.push([node]);
        }
      }
      break;
    case 'root':
      matches.push(ast);
      if (isSubject) {
        subject.push([ast]);
      }
      break;
    case 'identifier':
      if (cache.types.hasOwnProperty(selector.value)) {
        for (i$ = 0, len$ = (ref$ = cache.types[selector.value]).length; i$ < len$; ++i$) {
          node = ref$[i$];
          matches.push(node);
          if (isSubject) {
            subject.push([node]);
          }
        }
      }
      break;
    case 'nth-child':
      visitPre(ast, function(node){
        var index, i$, val, len;
        index = selector.index.value;
        for (i$ in node) {
          val = node[i$];
          if (toString$.call(val).slice(8, -1) === 'Array') {
            len = val.length;
            if (0 <= index && index < len) {
              matches.push(val[index]);
              if (isSubject) {
                subject.push([val[index]]);
              }
            }
          }
        }
      });
      break;
    case 'nth-last-child':
      visitPre(ast, function(node){
        var index, i$, val, len, i;
        index = selector.index.value;
        for (i$ in node) {
          val = node[i$];
          if (toString$.call(val).slice(8, -1) === 'Array') {
            len = val.length;
            i = len - index - 1;
            if (0 <= i && i < len) {
              matches.push(val[i]);
              if (isSubject) {
                subject.push([val[i]]);
              }
            }
          }
        }
      });
      break;
    case 'attribute':
      selVal = selector.value;
      name = selector.name;
      if (selVal != null) {
        op = selector.operator;
        value = selVal.value;
        valueType = toString$.call(value).slice(8, -1);
        switch (selector.valType) {
        case 'primitive':
          switch (selVal.type) {
          case 'literal':
            visitPre(ast, function(node){
              if (isMatchPrimitiveLiteral(getPath(node, name), op, value, valueType)) {
                matches.push(node);
                if (isSubject) {
                  subject.push([node]);
                }
              }
            });
            break;
          case 'type':
            visitPre(ast, function(node){
              if (isMatchType(getPath(node, name), op, value)) {
                matches.push(node);
                if (isSubject) {
                  subject.push([node]);
                }
              }
            });
          }
          break;
        case 'either':
          sel = selVal.sel;
          visitPre(ast, function(node){
            var nodeValue;
            nodeValue = getPath(node, name);
            if ('object' === typeof nodeValue && isMatchComplex(nodeValue, op, value, sel) || isMatchPrimitiveLiteral(nodeValue, op, value, valueType)) {
              matches.push(node);
              if (isSubject) {
                subject.push([node]);
              }
            }
          });
          break;
        case 'complex':
          visitPre(ast, function(node){
            if (isMatchComplex(getPath(node, name), op, value, selVal)) {
              matches.push(node);
              if (isSubject) {
                subject.push([node]);
              }
            }
          });
        }
      } else {
        visitPre(ast, function(node){
          if (getPath(node, name) != null) {
            matches.push(node);
            if (isSubject) {
              subject.push([node]);
            }
          }
        });
      }
      break;
    case 'prop':
      left = selector.left, props = selector.props, subjects = selector.subjects;
      leftResults = finalMatches(matchAst(ast, left, cache));
      leftSubject = left.subject;
      for (i$ = 0, len$ = leftResults.length; i$ < len$; ++i$) {
        result = leftResults[i$];
        node = result;
        subs = [];
        propsLen = props.length;
        hasMatch = false;
        for (j$ = 0, len1$ = props.length; j$ < len1$; ++j$) {
          i = j$;
          prop = props[j$];
          previousNode = node;
          if (prop.type === 'wildcard') {
            if (toString$.call(node).slice(8, -1) === 'Array') {
              newNode = [];
              for (k$ = 0, len2$ = node.length; k$ < len2$; ++k$) {
                p = node[k$];
                nodeInfo = syntaxFlat[p.type];
                for (l$ = 0, len3$ = (ref$ = nodeInfo.nodes.concat(nodeInfo.nodeArrays)).length; l$ < len3$; ++l$) {
                  field = ref$[l$];
                  if (p[field] != null) {
                    newNode.push(p[field]);
                  }
                }
              }
              node = newNode;
            } else {
              nodeInfo = syntaxFlat[node.type];
              res$ = [];
              for (k$ = 0, len2$ = (ref$ = nodeInfo.nodes.concat(nodeInfo.nodeArrays)).length; k$ < len2$; ++k$) {
                field = ref$[k$];
                if (node[field] != null) {
                  res$.push(node[field]);
                }
              }
              node = res$;
            }
          } else if (prop.type === 'string') {
            propValue = prop.value;
            if (toString$.call(node).slice(8, -1) === 'Array') {
              res$ = [];
              for (k$ = 0, len2$ = node.length; k$ < len2$; ++k$) {
                p = node[k$];
                if (p[propValue] != null) {
                  res$.push(p[propValue]);
                }
              }
              node = res$;
            } else {
              node = node[propValue];
            }
          } else if (toString$.call(node).slice(8, -1) === 'Array') {
            switch (prop.type) {
            case 'first':
            case 'head':
              node = node[0];
              break;
            case 'tail':
              node = node.slice(1);
              break;
            case 'last':
              node = node[node.length - 1];
              break;
            case 'initial':
              node = node.slice(0, node.length - 1);
              break;
            case 'nth':
              node = node[prop.index.value];
              break;
            case 'nth-last':
              node = node[node.length - prop.index.value - 1];
              break;
            case 'slice':
              node = node.slice.apply(node, map(fn$, prop.indicies));
            }
          } else {
            break;
          }
          if (node == null) {
            break;
          }
          if (toString$.call(node).slice(8, -1) === 'String' && prop.value === 'operator') {
            node = {
              type: 'Operator',
              value: node,
              loc: {
                start: (ref$ = previousNode.left.loc) != null ? ref$.end : void 8,
                end: (ref$ = previousNode.right.loc) != null ? ref$.start : void 8
              },
              raw: node
            };
          }
          if (node.type != null) {
            if (subjects[i]) {
              subs.push(node);
            }
          } else if (toString$.call(node).slice(8, -1) === 'Array' && node.length) {
            if (subjects[i]) {
              subs = subs.concat(node);
            }
          } else {
            break;
          }
          if (i === propsLen - 1) {
            hasMatch = true;
          }
        }
        if (hasMatch) {
          if (toString$.call(node).slice(8, -1) === 'Array') {
            matches = matches.concat(node);
          } else {
            matches.push(node);
          }
          if (leftSubject) {
            subject.push([result]);
          }
          if (subs.length) {
            for (j$ = 0, len1$ = subs.length; j$ < len1$; ++j$) {
              sub = subs[j$];
              subject.push([sub]);
            }
          }
        }
      }
      break;
    case 'matches':
      for (i$ = 0, len$ = (ref$ = selector.selectors).length; i$ < len$; ++i$) {
        matchesSelector = ref$[i$];
        for (j$ = 0, len1$ = (ref1$ = finalMatches(matchAst(ast, matchesSelector, cache))).length; j$ < len1$; ++j$) {
          node = ref1$[j$];
          matches.push(node);
          if (isSubject) {
            subject.push([node]);
          }
        }
      }
      break;
    case 'not':
      rightResults = [];
      for (i$ = 0, len$ = (ref$ = selector.selectors).length; i$ < len$; ++i$) {
        sel = ref$[i$];
        rightResults = rightResults.concat(finalMatches(matchAst(ast, sel, cache)));
      }
      visitPre(ast, function(node){
        if (!in$(node, rightResults)) {
          matches.push(node);
          if (isSubject) {
            subject.push([node]);
          }
        }
      });
      break;
    case 'compound':
      res$ = [];
      for (i$ = 0, len$ = (ref$ = selector.selectors).length; i$ < len$; ++i$) {
        sel = ref$[i$];
        res$.push(finalMatches(matchAst(ast, sel, cache)));
      }
      rightResults = res$;
      isSubject = isSubject || any(function(it){
        return it.subject;
      }, selector.selectors);
      for (i$ = 0, len$ = (ref$ = rightResults[0]).length; i$ < len$; ++i$) {
        node = ref$[i$];
        if (all((fn1$), slice$.call(rightResults, 1))) {
          matches.push(node);
          if (isSubject) {
            subject.push([node]);
          }
        }
      }
      break;
    case 'descendant':
      ref$ = matchAst(ast, selector.left, cache), leftSubject = ref$.subject, leftMatches = ref$.matches;
      ref$ = matchAst(ast, selector.right, cache), rightSubject = ref$.subject, rightMatches = ref$.matches;
      for (i$ = 0, len$ = leftMatches.length; i$ < len$; ++i$) {
        leftI = i$;
        leftNode = leftMatches[i$];
        visitPre(leftNode, fn2$);
      }
      break;
    case 'child':
      ref$ = matchAst(ast, selector.left, cache), leftSubject = ref$.subject, leftMatches = ref$.matches;
      ref$ = matchAst(ast, selector.right, cache), rightSubject = ref$.subject, rightMatches = ref$.matches;
      for (i$ = 0, len$ = leftMatches.length; i$ < len$; ++i$) {
        leftI = i$;
        leftNode = leftMatches[i$];
        visitChildren(leftNode, fn3$);
      }
      break;
    case 'sibling':
      ref$ = matchAst(ast, selector.left, cache), leftSubject = ref$.subject, leftMatches = ref$.matches;
      ref$ = matchAst(ast, selector.right, cache), rightSubject = ref$.subject, rightMatches = ref$.matches;
      visitPre(ast, function(node, context){
        var key, val, i$, len$, i, x, leftI, j, rightI, newSubject, that;
        for (key in node) {
          val = node[key];
          if (toString$.call(val).slice(8, -1) === 'Array') {
            for (i$ = 0, len$ = val.length; i$ < len$; ++i$) {
              i = i$;
              x = val[i$];
              leftI = leftMatches.indexOf(x);
              if (leftI > -1) {
                j = i + 1;
                for (; j < val.length; j++) {
                  rightI = rightMatches.indexOf(val[j]);
                  if (rightI > -1) {
                    matches.push(val[j]);
                    newSubject = [];
                    if (that = leftSubject[leftI]) {
                      newSubject = that;
                    }
                    if (that = rightSubject[rightI]) {
                      newSubject = newSubject.concat(that);
                    }
                    if (newSubject.length > 0) {
                      subject.push(newSubject);
                    }
                  }
                }
              }
            }
          }
        }
      });
      break;
    case 'adjacent':
      ref$ = matchAst(ast, selector.left, cache), leftSubject = ref$.subject, leftMatches = ref$.matches;
      ref$ = matchAst(ast, selector.right, cache), rightSubject = ref$.subject, rightMatches = ref$.matches;
      visitPre(ast, function(node, context){
        var key, val, i$, len$, i, x, leftI, rightI, newSubject, that;
        for (key in node) {
          val = node[key];
          if (toString$.call(val).slice(8, -1) === 'Array') {
            for (i$ = 0, len$ = val.length; i$ < len$; ++i$) {
              i = i$;
              x = val[i$];
              leftI = leftMatches.indexOf(x);
              if (leftI > -1) {
                rightI = rightMatches.indexOf(val[i + 1]);
                if (rightI > -1) {
                  matches.push(val[i + 1]);
                  newSubject = [];
                  if (that = leftSubject[leftI]) {
                    newSubject = that;
                  }
                  if (that = rightSubject[rightI]) {
                    newSubject = newSubject.concat(that);
                  }
                  if (newSubject.length > 0) {
                    subject.push(newSubject);
                  }
                }
              }
            }
          }
        }
      });
    }
    return {
      subject: subject,
      matches: matches
    };
    function fn$(it){
      return it.value;
    }
    function fn1$(it){
      return in$(node, it);
    }
    function fn2$(rightNode){
      var rightI, newSubject, that;
      if (leftNode === rightNode) {
        return;
      }
      rightI = rightMatches.indexOf(rightNode);
      if (rightI > -1) {
        matches.push(rightNode);
        newSubject = [];
        if (that = leftSubject[leftI]) {
          newSubject = that;
        }
        if (that = rightSubject[rightI]) {
          newSubject = newSubject.concat(that);
        }
        if (newSubject.length > 0) {
          subject.push(newSubject);
        }
      }
    }
    function fn3$(child){
      var rightI, newSubject, that;
      rightI = rightMatches.indexOf(child);
      if (rightI > -1) {
        matches.push(child);
        newSubject = [];
        if (that = leftSubject[leftI]) {
          newSubject = that;
        }
        if (that = rightSubject[rightI]) {
          newSubject = newSubject.concat(that);
        }
        if (newSubject.length > 0) {
          subject.push(newSubject);
        }
      }
    }
  }
  function isMatchPrimitiveLiteral(nodeValue, op, value, valueType){
    var nodeType;
    nodeType = toString$.call(nodeValue).slice(8, -1);
    if (nodeType === 'Undefined' || nodeType === 'Object') {
      return false;
    }
    return op === '=' && (nodeValue === value || (nodeType === valueType && valueType === 'RegExp') && nodeValue.toString() === value.toString()) || op === '!=' && (nodeType !== 'RegExp' && nodeValue !== value || (nodeType === valueType && valueType === 'RegExp') && nodeValue.toString() !== value.toString()) || (op === '=~' || op === '~=') && value.test(nodeValue) || op === '<=' && nodeValue <= value || op === '>=' && nodeValue >= value || op === '<' && nodeValue < value || op === '>' && nodeValue > value;
  }
  function isMatchType(nodeValue, op, value){
    var test;
    test = (literalMap[value] || value).match(RegExp(toString$.call(nodeValue).slice(8, -1) + '', 'i'));
    return op === '=' && test || op === '!=' && !test;
  }
  function addSubjectToFirst(sel){
    var ref$;
    if ((ref$ = sel.type) === 'descendant' || ref$ === 'child' || ref$ === 'sibling' || ref$ === 'adjacent') {
      return addSubjectToFirst(sel.left);
    } else {
      return sel.subject = true;
    }
  }
  function isMatchComplex(nodeValue, op, value, selector){
    var cache, sel, subMatches, subMatchesLen;
    if ('Undefined' === toString$.call(nodeValue).slice(8, -1)) {
      return false;
    }
    cache = new Cache(nodeValue);
    addSubjectToFirst(selector);
    sel = {
      type: 'compound',
      selectors: [
        selector, {
          type: 'root'
        }
      ]
    };
    subMatches = finalMatches(matchAst(nodeValue, sel, cache));
    subMatchesLen = subMatches.length;
    return op === '=' && subMatchesLen || op === '!=' && !subMatchesLen;
  }
  module.exports = {
    finalMatches: finalMatches,
    matchAst: matchAst
  };
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);

},{"./common":70,"grasp-syntax-javascript":11,"prelude-ls":91}],73:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var ref$, map, last, lines, compact, join, aliasMap, matchesMap, matchesAliasMap, literalMap, complexTypeMap, attrMap, primitiveOnlyAttributes, eitherAttributes, tokenSplit, operatorMap, toString$ = {}.toString;
  ref$ = require('prelude-ls'), map = ref$.map, last = ref$.last, lines = ref$.lines, compact = ref$.compact, join = ref$.join;
  ref$ = require('grasp-syntax-javascript'), aliasMap = ref$.aliasMap, matchesMap = ref$.matchesMap, matchesAliasMap = ref$.matchesAliasMap, literalMap = ref$.literalMap, complexTypeMap = ref$.complexTypeMap, attrMap = ref$.attrMap, primitiveOnlyAttributes = ref$.primitiveOnlyAttributes, eitherAttributes = ref$.eitherAttributes;
  function parse(selector){
    return processTokens(tokenize(selector + ""));
  }
  tokenSplit = /\s*(\/(?:\\\/|[^\/])*\/[gimy]*)\s*|([-+]?[0-9]*\.?[0-9]+)|("(?:\\"|[^"])*")|('(?:\\'|[^'])*')|(type\([a-zA-Z]*\))|(\*|::?|\+\+|#)|\s*(!=|<=|>=|=~|~=)\s*|\s*(\]|\)|!|\.)|(\[&|\[)\s*|\s*(\,|~|<|>|=|\+|\||\(|\s)\s*/;
  function tokenize(selector){
    var cleanSelector, i$, ref$, len$, token, that, results$ = [];
    cleanSelector = join(',')(
    compact(
    map(function(it){
      return it.replace(/^\s*|\s*$/g, '');
    })(
    lines(
    selector))));
    for (i$ = 0, len$ = (ref$ = cleanSelector.split(tokenSplit)).length; i$ < len$; ++i$) {
      token = ref$[i$];
      if (token) {
        if (token === '*') {
          results$.push({
            type: 'wildcard',
            value: '*'
          });
        } else if (that = /^type\(([a-zA-Z]*)\)$/.exec(token)) {
          results$.push({
            type: 'type',
            value: that[1]
          });
        } else if (token === 'type' || token === 'root' || token === 'not' || token === 'matches' || token === 'first' || token === 'head' || token === 'tail' || token === 'last' || token === 'initial' || token === 'nth' || token === 'nth-last' || token === 'slice' || token === 'first-child' || token === 'nth-child' || token === 'nth-last-child' || token === 'last-child') {
          results$.push({
            type: 'keyword',
            value: token
          });
        } else if (token === 'true' || token === 'false') {
          results$.push({
            type: 'boolean',
            value: token === 'true'
          });
        } else if (token === 'null') {
          results$.push({
            type: 'null',
            value: null
          });
        } else if (that = /^['"](.*)['"]$/.exec(token)) {
          results$.push({
            type: 'string',
            value: that[1].replace(/\\"/, '"').replace(/\\'/, "'")
          });
        } else if (/^[-+]?[0-9]*.?[0-9]+$/.test(token)) {
          results$.push({
            type: 'number',
            value: parseFloat(token)
          });
        } else if (that = /^\/(.*)\/([gimy]*)$/.exec(token)) {
          results$.push({
            type: 'regexp',
            value: new RegExp(that[1], that[2])
          });
        } else if ((token === '!=' || token === '<=' || token === '>=' || token === '=~' || token === '~=' || token === '>' || token === '<' || token === ',' || token === '~' || token === '=' || token === '!' || token === '#' || token === '.' || token === ':' || token === '::' || token === '+' || token === '[&' || token === '[' || token === ']' || token === '(' || token === ')') || token.match(/\s/)) {
          results$.push({
            type: 'operator',
            value: token
          });
        } else {
          results$.push({
            type: 'identifier',
            value: token
          });
        }
      }
    }
    return results$;
  }
  function processTokens(tokens){
    if (!tokens.length) {
      return null;
    }
    tokens.unshift({
      type: 'operator',
      value: '('
    });
    tokens.push({
      type: 'operator',
      value: ')'
    });
    return consumeImplicitMatches(tokens);
  }
  function consumeImplicitMatches(tokens){
    var args;
    args = consumeComplexArgList(tokens);
    if (args.length > 1) {
      return {
        type: 'matches',
        selectors: args
      };
    } else {
      return args[0];
    }
  }
  function peekOp(tokens, opValue){
    if (tokens.length > 0 && peekType(tokens, 'operator') && (toString$.call(opValue).slice(8, -1) === 'RegExp' && opValue.test(tokens[0].value) || tokens[0].value === opValue)) {
      return tokens[0];
    }
  }
  function consumeOp(tokens, opValue){
    if (peekOp(tokens, opValue)) {
      return tokens.shift();
    } else {
      throw createError("Expected operator " + opValue + ", but found:", tokens[0], tokens);
    }
  }
  function peekType(tokens, type){
    if (tokens.length > 0 && (tokens[0].type === type || toString$.call(type).slice(8, -1) === 'Array' && in$(tokens[0].type, type))) {
      return tokens[0];
    }
  }
  function consumeType(tokens, type){
    if (peekType(tokens, type)) {
      return tokens.shift();
    } else {
      throw createError("Expected type " + type + ", but found:", tokens[0], tokens);
    }
  }
  operatorMap = {
    ' ': 'descendant',
    '>': 'child',
    '~': 'sibling',
    '+': 'adjacent'
  };
  function consumeComplexSelector(tokens){
    var ops, root, wildcard, result, op, opVal, selector;
    ops = /^[\s>~+]$/;
    root = {
      type: 'root'
    };
    wildcard = {
      type: 'wildcard'
    };
    result = peekOp(tokens, ops)
      ? root
      : consumeCompoundSelector(tokens);
    while (peekOp(tokens, ops)) {
      op = tokens.shift();
      opVal = op.value;
      selector = consumeCompoundSelector(tokens);
      result = {
        type: operatorMap[opVal],
        operator: opVal,
        left: result,
        right: selector || wildcard
      };
    }
    return result;
  }
  function consumeCompoundSelector(tokens){
    var result, selector;
    result = consumeSelector(tokens);
    while (tokens.length > 0) {
      selector = consumeSelector(tokens);
      if (selector) {
        if (result.type !== 'compound') {
          result = {
            type: 'compound',
            selectors: [result]
          };
        }
        result.selectors.push(selector);
      } else {
        break;
      }
    }
    return result || selector;
  }
  function mapSimpleSelector(value){
    return {
      type: 'identifier',
      value: aliasMap[value] || value
    };
  }
  function consumeIdentifier(tokens){
    var value, val;
    value = tokens.shift().value;
    if (value in literalMap) {
      return {
        type: 'compound',
        selectors: [
          {
            type: 'identifier',
            value: 'Literal'
          }, {
            type: 'attribute',
            name: 'value',
            operator: '=',
            valType: 'primitive',
            value: {
              type: 'type',
              value: literalMap[value]
            }
          }
        ]
      };
    } else if (value in matchesMap || value in matchesAliasMap) {
      return {
        type: 'matches',
        selectors: (function(){
          var i$, ref$, len$, results$ = [];
          for (i$ = 0, len$ = (ref$ = matchesMap[matchesAliasMap[value] || value]).length; i$ < len$; ++i$) {
            val = ref$[i$];
            results$.push({
              type: 'identifier',
              value: val
            });
          }
          return results$;
        }())
      };
    } else if (value in complexTypeMap) {
      switch (complexTypeMap[value]) {
      case 'ImmediatelyInvokedFunctionExpression':
        return {
          type: 'compound',
          selectors: [
            {
              type: 'identifier',
              value: 'CallExpression'
            }, {
              type: 'attribute',
              name: 'callee',
              operator: '=',
              valType: 'complex',
              value: {
                type: 'matches',
                selectors: [
                  {
                    type: 'identifier',
                    value: 'FunctionExpression'
                  }, {
                    type: 'compound',
                    selectors: [
                      {
                        type: 'identifier',
                        value: 'MemberExpression'
                      }, {
                        type: 'attribute',
                        name: 'object',
                        operator: '=',
                        valType: 'complex',
                        value: {
                          type: 'identifier',
                          value: 'FunctionExpression'
                        }
                      }, {
                        type: 'attribute',
                        name: 'property',
                        operator: '=',
                        valType: 'complex',
                        value: {
                          type: 'matches',
                          selectors: [
                            {
                              type: 'compound',
                              selectors: [
                                {
                                  type: 'identifier',
                                  value: 'Identifier'
                                }, {
                                  type: 'attribute',
                                  name: 'name',
                                  operator: '=',
                                  valType: 'primitive',
                                  value: {
                                    type: 'literal',
                                    value: 'call'
                                  }
                                }
                              ]
                            }, {
                              type: 'compound',
                              selectors: [
                                {
                                  type: 'identifier',
                                  value: 'Identifier'
                                }, {
                                  type: 'attribute',
                                  name: 'name',
                                  operator: '=',
                                  valType: 'primitive',
                                  value: {
                                    type: 'literal',
                                    value: 'apply'
                                  }
                                }
                              ]
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            }
          ]
        };
      }
    } else {
      return mapSimpleSelector(value);
    }
  }
  function consumeSelector(tokens){
    var selector, token, value, props, propSubjectIndices, i, ref$;
    selector = peekType(tokens, 'wildcard')
      ? tokens.shift()
      : peekOp(tokens, '::')
        ? (tokens.shift(), consumeIdentifier(tokens))
        : peekType(tokens, ['keyword', 'identifier'])
          ? consumeIdentifier(tokens)
          : peekType(tokens, ['number', 'string', 'regexp', 'boolean', 'null'])
            ? consumeLiteral(tokens)
            : peekOp(tokens, ':')
              ? consumePseudo(tokens)
              : peekOp(tokens, /\[&?/)
                ? consumeAttribute(tokens)
                : peekOp(tokens, '#')
                  ? (consumeOp(tokens, '#'), token = tokens.shift(), value = token.value, {
                    type: 'compound',
                    selectors: [
                      {
                        type: 'identifier',
                        value: 'Identifier'
                      }, {
                        type: 'attribute',
                        name: 'name',
                        operator: token.type === 'regexp' ? '=~' : '=',
                        valType: 'primitive',
                        value: {
                          type: 'literal',
                          value: value
                        }
                      }
                    ]
                  })
                  : peekOp(tokens, '(')
                    ? consumeImplicitMatches(tokens)
                    : peekOp(tokens, '.') ? {
                      type: 'root'
                    } : void 8;
    if (selector) {
      if (peekOp(tokens, '!')) {
        tokens.shift();
        selector.subject = true;
      }
      props = [];
      propSubjectIndices = {};
      i = 0;
      while (peekOp(tokens, '.') || peekOp(tokens, ':') && ((ref$ = tokens[1].value) === 'first' || ref$ === 'head' || ref$ === 'tail' || ref$ === 'last' || ref$ === 'initial' || ref$ === 'nth' || ref$ === 'nth-last' || ref$ === 'slice')) {
        props.push(peekOp(tokens, '.')
          ? consumeProp(tokens)
          : consumePseudo(tokens));
        if (peekOp(tokens, '!')) {
          consumeOp(tokens, '!');
          propSubjectIndices[i] = true;
        }
        i++;
      }
      if (props.length) {
        selector = {
          type: 'prop',
          left: selector,
          props: props,
          subjects: propSubjectIndices
        };
      }
    }
    return selector;
  }
  function consumeLiteral(tokens){
    var token, value;
    token = tokens.shift();
    value = token.value;
    return {
      type: 'compound',
      selectors: [
        {
          type: 'identifier',
          value: 'Literal'
        }, {
          type: 'attribute',
          name: 'value',
          operator: '=',
          valType: 'primitive',
          value: {
            type: 'literal',
            value: value
          }
        }
      ]
    };
  }
  function consumePseudo(tokens){
    var op, id, that;
    op = consumeOp(tokens, ':');
    id = consumeType(tokens, 'keyword');
    switch (that = id.value) {
    case 'root':
    case 'first':
    case 'head':
    case 'tail':
    case 'last':
    case 'initial':
      return {
        type: that
      };
    case 'nth':
    case 'nth-last':
    case 'nth-child':
    case 'nth-last-child':
      return {
        type: that,
        index: consumeArg(tokens)
      };
    case 'slice':
      return {
        type: that,
        indicies: consumeArgList(tokens)
      };
    case 'first-child':
      return {
        type: 'nth-child',
        index: {
          type: 'literal',
          value: 0
        }
      };
    case 'last-child':
      return {
        type: 'nth-last-child',
        index: {
          type: 'literal',
          value: 0
        }
      };
    case 'matches':
      return consumeImplicitMatches(tokens);
    case 'not':
      return {
        type: that,
        selectors: consumeComplexArgList(tokens)
      };
    default:
      throw createError('Unexpected keyword:', id, tokens);
    }
  }
  function consumeName(tokens){
    var name, val;
    name = '';
    while (!name || peekOp(tokens, '.')) {
      if (name) {
        consumeOp(tokens, '.');
        name += '.';
      }
      val = consumeType(tokens, ['keyword', 'identifier']).value;
      name += attrMap[val] || val;
    }
    return name;
  }
  function consumeAttribute(tokens){
    var op, name, lastName, nextOp, nextToken, val, ref$, valType, value, selector;
    op = consumeType(tokens, 'operator').value;
    name = consumeName(tokens);
    lastName = last(name.split('.'));
    nextOp = consumeType(tokens, 'operator').value;
    if (nextOp === ']') {
      return {
        type: 'attribute',
        name: name
      };
    } else {
      nextToken = tokens[0];
      ref$ = op === '[&' || nextToken.type === 'type' || in$(lastName, primitiveOnlyAttributes)
        ? ['primitive', consumeValue(tokens)]
        : in$(lastName, eitherAttributes)
          ? (val = consumeValue([tokens[0]]), [
            'either', {
              type: val.type,
              value: val.value,
              sel: consumeSelector(tokens)
            }
          ])
          : ['complex', consumeComplexSelector(tokens)], valType = ref$[0], value = ref$[1];
      selector = {
        type: 'attribute',
        name: name,
        operator: nextOp,
        valType: valType,
        value: value
      };
      consumeOp(tokens, ']');
      return selector;
    }
  }
  function consumeProp(tokens){
    var token, name;
    consumeOp(tokens, '.');
    if (peekType(tokens, ['identifier', 'number', 'null', 'boolean'])) {
      token = consumeType(tokens, ['identifier', 'number', 'null', 'boolean']);
      name = token.value;
      return {
        type: 'string',
        value: attrMap[name] || name
      };
    } else {
      return {
        type: 'wildcard'
      };
    }
  }
  function consumeComplexArgList(tokens){
    var result, arg;
    consumeOp(tokens, '(');
    result = [];
    while (tokens.length > 0) {
      arg = consumeComplexSelector(tokens);
      if (arg) {
        result.push(arg);
      } else {
        throw createError('Expected selector argument:', tokens[0], tokens);
      }
      if (peekOp(tokens, ',')) {
        consumeOp(tokens, ',');
      } else {
        break;
      }
    }
    consumeOp(tokens, ')');
    return result;
  }
  function consumeArgList(tokens){
    var result, arg;
    consumeOp(tokens, '(');
    result = [];
    while (tokens.length > 0) {
      arg = consumeValue(tokens);
      if (arg) {
        result.push(arg);
      } else {
        throw createError('Expected argument:', tokens[0], tokens);
      }
      if (peekOp(tokens, ',')) {
        consumeOp(tokens, ',');
      } else {
        break;
      }
    }
    consumeOp(tokens, ')');
    return result;
  }
  function consumeArg(tokens){
    var value;
    consumeOp(tokens, '(');
    value = consumeValue(tokens);
    consumeOp(tokens, ')');
    return value;
  }
  function consumeValue(tokens){
    var token, value, type;
    token = tokens.shift(), value = token.value, type = token.type;
    if (type === 'type') {
      if (!value) {
        throw createError("Expected argument for 'type'.", token, tokens);
      }
      return token;
    } else if (value !== ',' && value !== '(' && value !== ')' && value !== '[' && value !== ']' && value !== '[&') {
      return {
        type: 'literal',
        value: value
      };
    }
  }
  function createError(message, token, tokens){
    return new Error(message + " " + JSON.stringify(token) + "\nRemaining tokens: " + JSON.stringify(tokens, null, '  '));
  }
  module.exports = {
    parse: parse,
    tokenize: tokenize
  };
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);

},{"grasp-syntax-javascript":11,"prelude-ls":91}],74:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var ref$, id, find, sort, min, max, map, partition, unlines, nameToRaw, dasherize, wordwrap, getPreText, setHelpStyleDefaults, generateHelpForOption, generateHelp;
  ref$ = require('prelude-ls'), id = ref$.id, find = ref$.find, sort = ref$.sort, min = ref$.min, max = ref$.max, map = ref$.map, partition = ref$.partition, unlines = ref$.unlines;
  ref$ = require('./util'), nameToRaw = ref$.nameToRaw, dasherize = ref$.dasherize;
  wordwrap = require('wordwrap');
  getPreText = function(option, arg$, maxWidth){
    var mainName, aliases, ref$, type, description, aliasSeparator, typeSeparator, initialIndent, shortNames, longNames, names, namesString, namesStringLen, typeSeparatorString, typeSeparatorStringLen, typeString, that, wrap;
    mainName = option.option, aliases = (ref$ = option.aliases) != null
      ? ref$
      : [], type = option.type, description = option.description;
    aliasSeparator = arg$.aliasSeparator, typeSeparator = arg$.typeSeparator, initialIndent = arg$.initialIndent;
    ref$ = partition(function(it){
      return it.length === 1;
    }, aliases), shortNames = ref$[0], longNames = ref$[1];
    names = mainName.length === 1
      ? [mainName].concat(shortNames, longNames)
      : shortNames.concat([mainName], longNames);
    namesString = map(nameToRaw, names).join(aliasSeparator);
    namesStringLen = namesString.length;
    typeSeparatorString = mainName === 'NUM' ? '::' : typeSeparator;
    typeSeparatorStringLen = typeSeparatorString.length;
    typeString = (that = option['enum']) ? "One of: " + that.join(', ') : type;
    if (maxWidth != null && !option.boolean && initialIndent + namesStringLen + typeSeparatorStringLen + typeString.length > maxWidth) {
      wrap = wordwrap(initialIndent + namesStringLen + typeSeparatorStringLen, maxWidth);
      return namesString + "" + typeSeparatorString + wrap(typeString).replace(/^\s+/, '');
    } else {
      return namesString + "" + (option.boolean
        ? ''
        : typeSeparatorString + "" + typeString);
    }
  };
  setHelpStyleDefaults = function(helpStyle){
    helpStyle.aliasSeparator == null && (helpStyle.aliasSeparator = ', ');
    helpStyle.typeSeparator == null && (helpStyle.typeSeparator = ' ');
    helpStyle.descriptionSeparator == null && (helpStyle.descriptionSeparator = '  ');
    helpStyle.initialIndent == null && (helpStyle.initialIndent = 2);
    helpStyle.secondaryIndent == null && (helpStyle.secondaryIndent = 4);
    helpStyle.maxPadFactor == null && (helpStyle.maxPadFactor = 1.5);
  };
  generateHelpForOption = function(getOption, arg$){
    var stdout, helpStyle, ref$;
    stdout = arg$.stdout, helpStyle = (ref$ = arg$.helpStyle) != null
      ? ref$
      : {};
    setHelpStyleDefaults(helpStyle);
    return function(optionName){
      var maxWidth, wrap, option, e, pre, defaultString, restPositionalString, description, fullDescription, that, preDescription, descriptionString, exampleString, examples, seperator;
      maxWidth = stdout != null && stdout.isTTY ? stdout.columns - 1 : null;
      wrap = maxWidth ? wordwrap(maxWidth) : id;
      try {
        option = getOption(dasherize(optionName));
      } catch (e$) {
        e = e$;
        return e.message;
      }
      pre = getPreText(option, helpStyle);
      defaultString = option['default'] ? "\ndefault: " + option['default'] : '';
      restPositionalString = option.restPositional ? 'Everything after this option is considered a positional argument, even if it looks like an option.' : '';
      description = option.longDescription || option.description && sentencize(option.description);
      fullDescription = description && restPositionalString
        ? description + " " + restPositionalString
        : (that = description || restPositionalString) ? that : '';
      preDescription = 'description:';
      descriptionString = !fullDescription
        ? ''
        : maxWidth && fullDescription.length - 1 - preDescription.length > maxWidth
          ? "\n" + preDescription + "\n" + wrap(fullDescription)
          : "\n" + preDescription + " " + fullDescription;
      exampleString = (that = option.example) ? (examples = [].concat(that), examples.length > 1
        ? "\nexamples:\n" + unlines(examples)
        : "\nexample: " + examples[0]) : '';
      seperator = defaultString || descriptionString || exampleString ? "\n" + repeatString$('=', pre.length) : '';
      return pre + "" + seperator + defaultString + descriptionString + exampleString;
    };
  };
  generateHelp = function(arg$){
    var options, prepend, append, helpStyle, ref$, stdout, aliasSeparator, typeSeparator, descriptionSeparator, maxPadFactor, initialIndent, secondaryIndent;
    options = arg$.options, prepend = arg$.prepend, append = arg$.append, helpStyle = (ref$ = arg$.helpStyle) != null
      ? ref$
      : {}, stdout = arg$.stdout;
    setHelpStyleDefaults(helpStyle);
    aliasSeparator = helpStyle.aliasSeparator, typeSeparator = helpStyle.typeSeparator, descriptionSeparator = helpStyle.descriptionSeparator, maxPadFactor = helpStyle.maxPadFactor, initialIndent = helpStyle.initialIndent, secondaryIndent = helpStyle.secondaryIndent;
    return function(arg$){
      var showHidden, maxWidth, output, out, data, optionCount, totalPreLen, preLens, i$, ref$, len$, item, that, pre, desc, preLen, sortedPreLens, maxPreLen, preLenMean, x, padAmount, descSepLen, fullWrapCount, partialWrapCount, descLen, totalLen, initialSpace, wrapAllFull, i, wrap;
      showHidden = (arg$ != null
        ? arg$
        : {}).showHidden;
      maxWidth = stdout != null && stdout.isTTY ? stdout.columns - 1 : null;
      output = [];
      out = function(it){
        return output.push(it != null ? it : '');
      };
      if (prepend) {
        out(prepend);
        out();
      }
      data = [];
      optionCount = 0;
      totalPreLen = 0;
      preLens = [];
      for (i$ = 0, len$ = (ref$ = options).length; i$ < len$; ++i$) {
        item = ref$[i$];
        if (showHidden || !item.hidden) {
          if (that = item.heading) {
            data.push({
              type: 'heading',
              value: that
            });
          } else {
            pre = getPreText(item, helpStyle, maxWidth);
            desc = item['default']
              ? (that = item.description) != null
                ? that + " - default: " + item['default']
                : "default: " + item['default']
              : (that = item.description) != null ? that : '';
            data.push({
              type: 'option',
              pre: pre,
              desc: desc,
              descLen: desc.length
            });
            preLen = pre.length;
            optionCount++;
            totalPreLen += preLen;
            preLens.push(preLen);
          }
        }
      }
      sortedPreLens = sort(preLens);
      maxPreLen = sortedPreLens[sortedPreLens.length - 1];
      preLenMean = initialIndent + totalPreLen / optionCount;
      x = optionCount > 2 ? min(preLenMean * maxPadFactor, maxPreLen) : maxPreLen;
      for (i$ = sortedPreLens.length - 1; i$ >= 0; --i$) {
        preLen = sortedPreLens[i$];
        if (preLen <= x) {
          padAmount = preLen;
          break;
        }
      }
      descSepLen = descriptionSeparator.length;
      if (maxWidth != null) {
        fullWrapCount = 0;
        partialWrapCount = 0;
        for (i$ = 0, len$ = data.length; i$ < len$; ++i$) {
          item = data[i$];
          if (item.type === 'option') {
            pre = item.pre, desc = item.desc, descLen = item.descLen;
            if (descLen === 0) {
              item.wrap = 'none';
            } else {
              preLen = max(padAmount, pre.length) + initialIndent + descSepLen;
              totalLen = preLen + descLen;
              if (totalLen > maxWidth) {
                if (descLen / 2.5 > maxWidth - preLen) {
                  fullWrapCount++;
                  item.wrap = 'full';
                } else {
                  partialWrapCount++;
                  item.wrap = 'partial';
                }
              } else {
                item.wrap = 'none';
              }
            }
          }
        }
      }
      initialSpace = repeatString$(' ', initialIndent);
      wrapAllFull = optionCount > 1 && fullWrapCount + partialWrapCount * 0.5 > optionCount * 0.5;
      for (i$ = 0, len$ = data.length; i$ < len$; ++i$) {
        i = i$;
        item = data[i$];
        if (item.type === 'heading') {
          if (i !== 0) {
            out();
          }
          out(item.value + ":");
        } else {
          pre = item.pre, desc = item.desc, descLen = item.descLen, wrap = item.wrap;
          if (maxWidth != null) {
            if (wrapAllFull || wrap === 'full') {
              wrap = wordwrap(initialIndent + secondaryIndent, maxWidth);
              out(initialSpace + "" + pre + "\n" + wrap(desc));
              continue;
            } else if (wrap === 'partial') {
              wrap = wordwrap(initialIndent + descSepLen + max(padAmount, pre.length), maxWidth);
              out(initialSpace + "" + pad(pre, padAmount) + descriptionSeparator + wrap(desc).replace(/^\s+/, ''));
              continue;
            }
          }
          if (descLen === 0) {
            out(initialSpace + "" + pre);
          } else {
            out(initialSpace + "" + pad(pre, padAmount) + descriptionSeparator + desc);
          }
        }
      }
      if (append) {
        out();
        out(append);
      }
      return unlines(output);
    };
  };
  function pad(str, num){
    var len, padAmount;
    len = str.length;
    padAmount = num - len;
    return str + "" + repeatString$(' ', padAmount > 0 ? padAmount : 0);
  }
  function sentencize(str){
    var first, rest, period;
    first = str.charAt(0).toUpperCase();
    rest = str.slice(1);
    period = /[\.!\?]$/.test(str) ? '' : '.';
    return first + "" + rest + period;
  }
  module.exports = {
    generateHelp: generateHelp,
    generateHelpForOption: generateHelpForOption
  };
  function repeatString$(str, n){
    for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
    return r;
  }
}).call(this);

},{"./util":76,"prelude-ls":91,"wordwrap":85}],75:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var VERSION, ref$, id, map, compact, any, groupBy, chars, isItNaN, keys, Obj, deepIs, closestString, nameToRaw, camelize, dasherize, generateHelp, generateHelpForOption, parsedTypeCheck, parseType, parseLevn, camelizeKeys, parseString, main, toString$ = {}.toString;
  VERSION = '0.1.0';
  ref$ = require('prelude-ls'), id = ref$.id, map = ref$.map, compact = ref$.compact, any = ref$.any, groupBy = ref$.groupBy, chars = ref$.chars, isItNaN = ref$.isItNaN, keys = ref$.keys, Obj = ref$.Obj;
  deepIs = require('deep-is');
  ref$ = require('./util'), closestString = ref$.closestString, nameToRaw = ref$.nameToRaw, camelize = ref$.camelize, dasherize = ref$.dasherize;
  ref$ = require('./help'), generateHelp = ref$.generateHelp, generateHelpForOption = ref$.generateHelpForOption;
  ref$ = require('type-check'), parsedTypeCheck = ref$.parsedTypeCheck, parseType = ref$.parseType;
  parseLevn = require('levn').parsedTypeParse;
  camelizeKeys = function(obj){
    var key, value, results$ = {};
    for (key in obj) {
      value = obj[key];
      results$[camelize(key)] = value;
    }
    return results$;
  };
  parseString = function(string){
    var assignOpt, regex, replaceRegex, result;
    assignOpt = '--?[a-zA-Z][-a-z-A-Z0-9]*=';
    regex = RegExp('(?:' + assignOpt + ')?(?:\'(?:[^\']|\\\\\')+\'|"(?:[^"]|\\\\")+")|[^\'"\\s]+', 'g');
    replaceRegex = RegExp('^(' + assignOpt + ')?[\'"]([\\s\\S]*)[\'"]$');
    result = map(function(it){
      return it.replace(replaceRegex, '$1$2');
    }, string.match(regex) || []);
    return result;
  };
  main = function(libOptions){
    var opts, defaults, required, traverse, getOption, parse;
    opts = {};
    defaults = {};
    required = [];
    if (toString$.call(libOptions.stdout).slice(8, -1) === 'Undefined') {
      libOptions.stdout = process.stdout;
    }
    traverse = function(options){
      var i$, len$, option, name, e, parsedPossibilities, parsedType, j$, ref$, len1$, possibility, alias;
      if (toString$.call(options).slice(8, -1) !== 'Array') {
        throw new Error('No options defined.');
      }
      for (i$ = 0, len$ = options.length; i$ < len$; ++i$) {
        option = options[i$];
        if (option.heading == null) {
          name = option.option;
          if (opts[name] != null) {
            throw new Error("Option '" + name + "' already defined.");
          }
          if (option.type === 'Boolean') {
            option.boolean == null && (option.boolean = true);
          }
          if (option.parsedType == null) {
            if (!option.type) {
              throw new Error("No type defined for option '" + name + "'.");
            }
            try {
              option.parsedType = parseType(option.type);
            } catch (e$) {
              e = e$;
              throw new Error("Option '" + name + "': Error parsing type '" + option.type + "': " + e.message);
            }
          }
          if (option['default']) {
            try {
              defaults[name] = parseLevn(option.parsedType, option['default']);
            } catch (e$) {
              e = e$;
              throw new Error("Option '" + name + "': Error parsing default value '" + option['default'] + "' for type '" + option.type + "': " + e.message);
            }
          }
          if (option['enum'] && !option.parsedPossiblities) {
            parsedPossibilities = [];
            parsedType = option.parsedType;
            for (j$ = 0, len1$ = (ref$ = option['enum']).length; j$ < len1$; ++j$) {
              possibility = ref$[j$];
              try {
                parsedPossibilities.push(parseLevn(parsedType, possibility));
              } catch (e$) {
                e = e$;
                throw new Error("Option '" + name + "': Error parsing enum value '" + possibility + "' for type '" + option.type + "': " + e.message);
              }
            }
            option.parsedPossibilities = parsedPossibilities;
          }
          if (option.required) {
            required.push(name);
          }
          opts[name] = option;
          if (option.alias || option.aliases) {
            if (name === 'NUM') {
              throw new Error("-NUM option can't have aliases.");
            }
            if (option.alias) {
              option.aliases == null && (option.aliases = [].concat(option.alias));
            }
            for (j$ = 0, len1$ = (ref$ = option.aliases).length; j$ < len1$; ++j$) {
              alias = ref$[j$];
              if (opts[alias] != null) {
                throw new Error("Option '" + alias + "' already defined.");
              }
              opts[alias] = option;
            }
          }
        }
      }
    };
    traverse(libOptions.options);
    getOption = function(name){
      var opt, possiblyMeant;
      opt = opts[name];
      if (opt == null) {
        possiblyMeant = closestString(keys(opts), name);
        throw new Error("Invalid option '" + nameToRaw(name) + "'" + (possiblyMeant ? " - perhaps you meant '" + nameToRaw(possiblyMeant) + "'?" : '.'));
      }
      return opt;
    };
    parse = function(input, arg$){
      var slice, obj, positional, restPositional, prop, setValue, setDefaults, checkRequired, mutuallyExclusiveError, checkMutuallyExclusive, args, key, value, option, i$, len$, arg, that, result, short, argName, usingAssign, val, flags, len, j$, len1$, i, flag, opt, name, negated, noedName, valPrime;
      slice = (arg$ != null
        ? arg$
        : {}).slice;
      obj = {};
      positional = [];
      restPositional = false;
      prop = null;
      setValue = function(name, value){
        var opt, val, e;
        opt = getOption(name);
        if (opt.boolean) {
          val = value;
        } else {
          try {
            val = parseLevn(opt.parsedType, value);
          } catch (e$) {
            e = e$;
            throw new Error("Invalid value for option '" + name + "' - expected type " + opt.type + ", received value: " + value + ".");
          }
          if (opt['enum'] && !any(function(it){
            return deepIs(it, val);
          }, opt.parsedPossibilities)) {
            throw new Error("Option " + name + ": '" + val + "' not in [" + opt['enum'].join(', ') + "].");
          }
        }
        obj[name] = val;
        if (opt.restPositional) {
          restPositional = true;
        }
      };
      setDefaults = function(){
        var name, ref$, value;
        for (name in ref$ = defaults) {
          value = ref$[name];
          if (obj[name] == null) {
            obj[name] = value;
          }
        }
      };
      checkRequired = function(){
        var i$, ref$, len$, name;
        for (i$ = 0, len$ = (ref$ = required).length; i$ < len$; ++i$) {
          name = ref$[i$];
          if (!obj[name]) {
            throw new Error("Option " + nameToRaw(name) + " is required.");
          }
        }
      };
      mutuallyExclusiveError = function(first, second){
        throw new Error("The options " + nameToRaw(first) + " and " + nameToRaw(second) + " are mutually exclusive - you cannot use them at the same time.");
      };
      checkMutuallyExclusive = function(){
        var rules, i$, len$, rule, present, j$, len1$, element, k$, len2$, opt;
        rules = libOptions.mutuallyExclusive;
        if (!rules) {
          return;
        }
        for (i$ = 0, len$ = rules.length; i$ < len$; ++i$) {
          rule = rules[i$];
          present = null;
          for (j$ = 0, len1$ = rule.length; j$ < len1$; ++j$) {
            element = rule[j$];
            if (toString$.call(element).slice(8, -1) === 'Array') {
              for (k$ = 0, len2$ = element.length; k$ < len2$; ++k$) {
                opt = element[k$];
                if (opt in obj) {
                  if (present != null) {
                    mutuallyExclusiveError(present, opt);
                  } else {
                    present = opt;
                    break;
                  }
                }
              }
            } else {
              if (element in obj) {
                if (present != null) {
                  mutuallyExclusiveError(present, element);
                } else {
                  present = element;
                }
              }
            }
          }
        }
      };
      switch (toString$.call(input).slice(8, -1)) {
      case 'String':
        args = parseString(input.slice(slice != null ? slice : 0));
        break;
      case 'Array':
        args = input.slice(slice != null ? slice : 2);
        break;
      case 'Object':
        obj = {};
        for (key in input) {
          value = input[key];
          if (key !== '_') {
            option = getOption(dasherize(key));
            if (parsedTypeCheck(option.parsedType, value)) {
              obj[option.option] = value;
            } else {
              throw new Error("Option '" + option.option + "': Invalid type for '" + value + "' - expected type '" + option.type + "'.");
            }
          }
        }
        checkMutuallyExclusive();
        setDefaults();
        checkRequired();
        obj._ = input._ || [];
        return camelizeKeys(obj);
      default:
        throw new Error("Invalid argument to 'parse': " + input + ".");
      }
      for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
        arg = args[i$];
        if (arg === '--') {
          restPositional = true;
        } else if (restPositional) {
          positional.push(arg);
        } else {
          if (that = arg.match(/^(--?)([a-zA-Z][-a-zA-Z0-9]*)(=)?(.*)?$/)) {
            result = that;
            if (prop) {
              throw new Error("Value for '" + prop + "' of type '" + getOption(prop).type + "' required.");
            }
            short = result[1].length === 1;
            argName = result[2];
            usingAssign = result[3] != null;
            val = result[4];
            if (usingAssign && val == null) {
              throw new Error("No value for '" + argName + "' specified.");
            }
            if (short) {
              flags = chars(argName);
              len = flags.length;
              for (j$ = 0, len1$ = flags.length; j$ < len1$; ++j$) {
                i = j$;
                flag = flags[j$];
                opt = getOption(flag);
                name = opt.option;
                if (restPositional) {
                  positional.push(flag);
                } else if (opt.boolean) {
                  setValue(name, true);
                } else if (i === len - 1) {
                  if (usingAssign) {
                    setValue(name, val);
                  } else {
                    prop = name;
                  }
                } else {
                  throw new Error("Can't set argument '" + flag + "' when not last flag in a group of short flags.");
                }
              }
            } else {
              negated = false;
              if (that = argName.match(/^no-(.+)$/)) {
                negated = true;
                noedName = that[1];
                opt = getOption(noedName);
              } else {
                opt = getOption(argName);
              }
              name = opt.option;
              if (opt.boolean) {
                valPrime = usingAssign ? parseLevn([{
                  type: 'Boolean'
                }], val) : true;
                if (negated) {
                  setValue(name, !valPrime);
                } else {
                  setValue(name, valPrime);
                }
              } else {
                if (negated) {
                  throw new Error("Only use 'no-' prefix for Boolean options, not with '" + noedName + "'.");
                }
                if (usingAssign) {
                  setValue(name, val);
                } else {
                  prop = name;
                }
              }
            }
          } else if (that = arg.match(/^-([0-9]+(?:\.[0-9]+)?)$/)) {
            opt = opts.NUM;
            if (!opt) {
              throw new Error('No -NUM option defined.');
            }
            setValue(opt.option, that[1]);
          } else {
            if (prop) {
              setValue(prop, arg);
              prop = null;
            } else {
              positional.push(arg);
            }
          }
        }
      }
      checkMutuallyExclusive();
      setDefaults();
      checkRequired();
      obj._ = positional;
      return camelizeKeys(obj);
    };
    return {
      parse: parse,
      generateHelp: generateHelp(libOptions),
      generateHelpForOption: generateHelpForOption(getOption, libOptions)
    };
  };
  main.VERSION = VERSION;
  module.exports = main;
}).call(this);

},{"./help":74,"./util":76,"deep-is":77,"levn":80,"prelude-ls":91,"type-check":83}],76:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var ref$, map, sortBy, ld, closestString, nameToRaw, camelize, dasherize;
  ref$ = require('prelude-ls'), map = ref$.map, sortBy = ref$.sortBy;
  ld = require('levenshtein-damerau');
  closestString = function(possibilities, input){
    var distances, ref$, string, distance;
    if (!possibilities.length) {
      return;
    }
    distances = map(function(it){
      var ref$, longer, shorter;
      ref$ = input.length > it.length
        ? [input, it]
        : [it, input], longer = ref$[0], shorter = ref$[1];
      return {
        string: it,
        distance: ld(longer, shorter)
      };
    })(
    possibilities);
    ref$ = sortBy(function(it){
      return it.distance;
    }, distances)[0], string = ref$.string, distance = ref$.distance;
    return string;
  };
  nameToRaw = function(name){
    if (name.length === 1 || name === 'NUM') {
      return "-" + name;
    } else {
      return "--" + name;
    }
  };
  camelize = function(it){
    return it.replace(/-[a-z]/ig, function(it){
      return it.charAt(1).toUpperCase();
    });
  };
  dasherize = function(string){
    if (/^[A-Z]/.test(string)) {
      return string;
    } else {
      return string.replace(/[A-Z]{2,}/g, function(it){
        return "-" + it;
      }).replace(/([a-z])([A-Z])/g, function(arg$, lower, upper){
        return lower + "-" + upper.toLowerCase();
      });
    }
  };
  module.exports = {
    closestString: closestString,
    nameToRaw: nameToRaw,
    camelize: camelize,
    dasherize: dasherize
  };
}).call(this);

},{"levenshtein-damerau":78,"prelude-ls":91}],77:[function(require,module,exports){
var pSlice = Array.prototype.slice;
var Object_keys = typeof Object.keys === 'function'
    ? Object.keys
    : function (obj) {
        var keys = [];
        for (var key in obj) keys.push(key);
        return keys;
    }
;

var deepEqual = module.exports = function (actual, expected) {
  // enforce Object.is +0 !== -0
  if (actual === 0 && expected === 0) {
    return areZerosEqual(actual, expected);

  // 7.1. All identical values are equivalent, as determined by ===.
  } else if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  } else if (isNumberNaN(actual)) {
    return isNumberNaN(expected);

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
};

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function isNumberNaN(value) {
  // NaN === NaN -> false
  return typeof value == 'number' && value !== value;
}

function areZerosEqual(zeroA, zeroB) {
  // (1 / +0|0) -> Infinity, but (1 / -0) -> -Infinity and (Infinity !== -Infinity)
  return (1 / zeroA) === (1 / zeroB);
}

function objEquiv(a, b) {
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;

  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b);
  }
  try {
    var ka = Object_keys(a),
        kb = Object_keys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key])) return false;
  }
  return true;
}

},{}],78:[function(require,module,exports){
var ld = function(src,tgt,debug){
  debug = debug ? debug : false;
  if(src.length == 0){
    return tgt.length;
  }else if(tgt.length == 0){
    return src.length;
  }
  var score = [];
  var sdump = function(){
    if(!debug){ return; }
    if(typeof debug === "function"){
      debug(score);
      return;
    }
    var buffer = "\t\t";
    for(var q in src){
      buffer += src[q] + "\t";
    };
    console.log(buffer);
    buffer = "\t";
    for(var j in score[0]){ buffer += score[0][j] + "\t"; }
    console.log(buffer);
    for(var q in tgt){
      buffer = tgt[q] + "\t";
      for(var u in score[parseInt(q)+1]){
        buffer += score[parseInt(q)+1][u] + "\t";
      }
      console.log(buffer);
    }
    buffer = "\t";
    for(var j in score[tgt.length+1]){ buffer += score[tgt.length+1][j] + "\t"; }
    console.log(buffer);
  };
  for(var j = 0; j < src.length + 2; j++){
    score.push(new Array(tgt.length+2));
  }
  var INF = tgt.length + src.length;
  var sd = {};
  score[0][0] = INF;
  sdump();
  for(var i = 0; i <= src.length; i++){ 
    score[i+1][1] = i;
    score[i+1][0] = INF;
    if(src.length > i){
      sd[src[i]] = 0;
    }
  }
  for(var i = 0; i <= src.length; i++){ 
    score[1][i+1] = i;
    score[0][i+1] = INF;
    if(tgt.length > i){
      sd[tgt[i]] = 0;
    }
  }
  sdump();
  for(var i = 1; i <= src.length; i++){
    var db = 0;
    for(var j = 1; j <= tgt.length; j++){
      var i1 = sd[tgt[j-1]];
      var j1 = db;
      if(src[i-1] == tgt[j-1]){
        score[i+1][j+1] = score[i][j];
        db = j;
      }else{
        score[i+1][j+1] = Math.min(score[i][j],Math.min(score[i+1][j],score[i][j+1])) + 1;
      }
      score[i+1][j+1] = Math.min(score[i+1][j+1],score[i1][j1] + (i - i1 - 1) + 1 + (j - j1 - 1));
    }
    sd[src[i-1]] = i;
    sdump();
  }
  return score[src.length+1][tgt.length+1];
};

module.exports = ld;

},{}],79:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var parsedTypeCheck, types, toString$ = {}.toString;
  parsedTypeCheck = require('type-check').parsedTypeCheck;
  types = {
    '*': function(value, options){
      switch (toString$.call(value).slice(8, -1)) {
      case 'Array':
        return typeCast(value, {
          type: 'Array'
        }, options);
      case 'Object':
        return typeCast(value, {
          type: 'Object'
        }, options);
      default:
        return {
          type: 'Just',
          value: typesCast(value, [
            {
              type: 'Undefined'
            }, {
              type: 'Null'
            }, {
              type: 'NaN'
            }, {
              type: 'Boolean'
            }, {
              type: 'Number'
            }, {
              type: 'Date'
            }, {
              type: 'RegExp'
            }, {
              type: 'Array'
            }, {
              type: 'Object'
            }, {
              type: 'String'
            }
          ], (options.explicit = true, options))
        };
      }
    },
    Undefined: function(it){
      if (it === 'undefined' || it === void 8) {
        return {
          type: 'Just',
          value: void 8
        };
      } else {
        return {
          type: 'Nothing'
        };
      }
    },
    Null: function(it){
      if (it === 'null') {
        return {
          type: 'Just',
          value: null
        };
      } else {
        return {
          type: 'Nothing'
        };
      }
    },
    NaN: function(it){
      if (it === 'NaN') {
        return {
          type: 'Just',
          value: NaN
        };
      } else {
        return {
          type: 'Nothing'
        };
      }
    },
    Boolean: function(it){
      if (it === 'true') {
        return {
          type: 'Just',
          value: true
        };
      } else if (it === 'false') {
        return {
          type: 'Just',
          value: false
        };
      } else {
        return {
          type: 'Nothing'
        };
      }
    },
    Number: function(it){
      return {
        type: 'Just',
        value: +it
      };
    },
    Int: function(it){
      return {
        type: 'Just',
        value: parseInt(it)
      };
    },
    Float: function(it){
      return {
        type: 'Just',
        value: parseFloat(it)
      };
    },
    Date: function(value, options){
      var that;
      if (that = /^\#([\s\S]*)\#$/.exec(value)) {
        return {
          type: 'Just',
          value: new Date(+that[1] || that[1])
        };
      } else if (options.explicit) {
        return {
          type: 'Nothing'
        };
      } else {
        return {
          type: 'Just',
          value: new Date(+value || value)
        };
      }
    },
    RegExp: function(value, options){
      var that;
      if (that = /^\/([\s\S]*)\/([gimy]*)$/.exec(value)) {
        return {
          type: 'Just',
          value: new RegExp(that[1], that[2])
        };
      } else if (options.explicit) {
        return {
          type: 'Nothing'
        };
      } else {
        return {
          type: 'Just',
          value: new RegExp(value)
        };
      }
    },
    Array: function(value, options){
      return castArray(value, {
        of: [{
          type: '*'
        }]
      }, options);
    },
    Object: function(value, options){
      return castFields(value, {
        of: {}
      }, options);
    },
    String: function(it){
      var that;
      if (toString$.call(it).slice(8, -1) !== 'String') {
        return {
          type: 'Nothing'
        };
      }
      if (that = it.match(/^'([\s\S]*)'$/)) {
        return {
          type: 'Just',
          value: that[1].replace("\\'", "'")
        };
      } else if (that = it.match(/^"([\s\S]*)"$/)) {
        return {
          type: 'Just',
          value: that[1].replace('\\"', '"')
        };
      } else {
        return {
          type: 'Just',
          value: it
        };
      }
    }
  };
  function castArray(node, type, options){
    var typeOf, element;
    if (toString$.call(node).slice(8, -1) !== 'Array') {
      return {
        type: 'Nothing'
      };
    }
    typeOf = type.of;
    return {
      type: 'Just',
      value: (function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = node).length; i$ < len$; ++i$) {
          element = ref$[i$];
          results$.push(typesCast(element, typeOf, options));
        }
        return results$;
      }())
    };
  }
  function castTuple(node, type, options){
    var result, i, i$, ref$, len$, types, cast;
    if (toString$.call(node).slice(8, -1) !== 'Array') {
      return {
        type: 'Nothing'
      };
    }
    result = [];
    i = 0;
    for (i$ = 0, len$ = (ref$ = type.of).length; i$ < len$; ++i$) {
      types = ref$[i$];
      cast = typesCast(node[i], types, options);
      if (toString$.call(cast).slice(8, -1) !== 'Undefined') {
        result.push(cast);
      }
      i++;
    }
    if (node.length <= i) {
      return {
        type: 'Just',
        value: result
      };
    } else {
      return {
        type: 'Nothing'
      };
    }
  }
  function castFields(node, type, options){
    var typeOf, key, value;
    if (toString$.call(node).slice(8, -1) !== 'Object') {
      return {
        type: 'Nothing'
      };
    }
    typeOf = type.of;
    return {
      type: 'Just',
      value: (function(){
        var ref$, results$ = {};
        for (key in ref$ = node) {
          value = ref$[key];
          results$[key] = typesCast(value, typeOf[key] || [{
            type: '*'
          }], options);
        }
        return results$;
      }())
    };
  }
  function typeCast(node, typeObj, options){
    var type, structure, castFunc, ref$;
    type = typeObj.type, structure = typeObj.structure;
    if (type) {
      castFunc = ((ref$ = options.customTypes[type]) != null ? ref$.cast : void 8) || types[type];
      if (!castFunc) {
        throw new Error("Type not defined: " + type + ".");
      }
      return castFunc(node, options, typesCast);
    } else {
      switch (structure) {
      case 'array':
        return castArray(node, typeObj, options);
      case 'tuple':
        return castTuple(node, typeObj, options);
      case 'fields':
        return castFields(node, typeObj, options);
      }
    }
  }
  function typesCast(node, types, options){
    var i$, len$, type, ref$, valueType, value;
    for (i$ = 0, len$ = types.length; i$ < len$; ++i$) {
      type = types[i$];
      ref$ = typeCast(node, type, options), valueType = ref$.type, value = ref$.value;
      if (valueType === 'Nothing') {
        continue;
      }
      if (parsedTypeCheck([type], value, {
        customTypes: options.customTypes
      })) {
        return value;
      }
    }
    throw new Error("Value " + JSON.stringify(node) + " does not type check against " + JSON.stringify(types) + ".");
  }
  module.exports = typesCast;
}).call(this);

},{"type-check":83}],80:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var parseString, cast, parseType, VERSION, parsedTypeParse, parse;
  parseString = require('./parse-string');
  cast = require('./cast');
  parseType = require('type-check').parseType;
  VERSION = '0.1.0';
  parsedTypeParse = function(parsedType, string, options){
    options == null && (options = {});
    options.explicit == null && (options.explicit = false);
    options.customTypes == null && (options.customTypes = {});
    return cast(parseString(parsedType, string, options), parsedType, options);
  };
  parse = function(type, string, options){
    return parsedTypeParse(parseType(type), string, options);
  };
  module.exports = {
    VERSION: VERSION,
    parse: parse,
    parsedTypeParse: parsedTypeParse
  };
}).call(this);

},{"./cast":79,"./parse-string":81,"type-check":83}],81:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var reject, special, tokenRegex;
  reject = require('prelude-ls').reject;
  function consumeOp(tokens, op){
    if (tokens[0] === op) {
      return tokens.shift();
    } else {
      throw new Error("Expected '" + op + "', but got '" + tokens[0] + "' instead in " + JSON.stringify(tokens) + ".");
    }
  }
  function maybeConsumeOp(tokens, op){
    if (tokens[0] === op) {
      return tokens.shift();
    }
  }
  function consumeList(tokens, arg$, hasDelimiters){
    var open, close, result;
    open = arg$[0], close = arg$[1];
    if (hasDelimiters) {
      consumeOp(tokens, open);
    }
    result = [];
    while (tokens.length && tokens[0] !== close) {
      result.push(consumeElement(tokens));
      maybeConsumeOp(tokens, ',');
    }
    if (hasDelimiters) {
      consumeOp(tokens, close);
    }
    return result;
  }
  function consumeArray(tokens, hasDelimiters){
    return consumeList(tokens, ['[', ']'], hasDelimiters);
  }
  function consumeTuple(tokens, hasDelimiters){
    return consumeList(tokens, ['(', ')'], hasDelimiters);
  }
  function consumeFields(tokens, hasDelimiters){
    var result, key;
    if (hasDelimiters) {
      consumeOp(tokens, '{');
    }
    result = {};
    while (tokens.length && (!hasDelimiters || tokens[0] !== '}')) {
      key = tokens.shift();
      consumeOp(tokens, ':');
      result[key] = consumeElement(tokens);
      maybeConsumeOp(tokens, ',');
    }
    if (hasDelimiters) {
      consumeOp(tokens, '}');
    }
    return result;
  }
  function consumeElement(tokens){
    switch (tokens[0]) {
    case '[':
      return consumeArray(tokens, true);
    case '(':
      return consumeTuple(tokens, true);
    case '{':
      return consumeFields(tokens, true);
    default:
      return tokens.shift();
    }
  }
  function consumeTopLevel(tokens, types, options){
    var ref$, type, structure, origTokens, result, finalResult, x$, y$;
    ref$ = types[0], type = ref$.type, structure = ref$.structure;
    origTokens = tokens.concat();
    if (!options.explicit && types.length === 1 && ((!type && structure) || (type === 'Array' || type === 'Object'))) {
      result = structure === 'array' || type === 'Array'
        ? consumeArray(tokens, tokens[0] === '[')
        : structure === 'tuple'
          ? consumeTuple(tokens, tokens[0] === '(')
          : consumeFields(tokens, tokens[0] === '{');
      finalResult = tokens.length ? consumeElement(structure === 'array' || type === 'Array'
        ? (x$ = origTokens, x$.unshift('['), x$.push(']'), x$)
        : (y$ = origTokens, y$.unshift('('), y$.push(')'), y$)) : result;
    } else {
      finalResult = consumeElement(tokens);
    }
    if (tokens.length && origTokens.length) {
      throw new Error("Unable to parse " + JSON.stringify(origTokens) + " of type " + JSON.stringify(types) + ".");
    } else {
      return finalResult;
    }
  }
  special = /\[\]\(\)}{:,/.source;
  tokenRegex = RegExp('("(?:[^"]|\\\\")*")|(\'(?:[^\']|\\\\\')*\')|(#.*#)|(/(?:\\\\/|[^/])*/[gimy]*)|([' + special + '])|([^\\s' + special + '](?:\\s*[^\\s' + special + ']+)*)|\\s*');
  module.exports = function(types, string, options){
    var tokens, node;
    options == null && (options = {});
    if (!options.explicit && types.length === 1 && types[0].type === 'String') {
      return "'" + string.replace(/\\'/, "\\\\'") + "'";
    }
    tokens = reject(function(it){
      return !it || /^\s+$/.test(it);
    }, string.split(tokenRegex));
    node = consumeTopLevel(tokens, types, options);
    if (!node) {
      throw new Error("Error parsing '" + string + "'.");
    }
    return node;
  };
}).call(this);

},{"prelude-ls":91}],82:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var ref$, any, all, isItNaN, types, defaultType, customTypes, toString$ = {}.toString;
  ref$ = require('prelude-ls'), any = ref$.any, all = ref$.all, isItNaN = ref$.isItNaN;
  types = {
    Number: {
      typeOf: 'Number',
      validate: function(it){
        return !isItNaN(it);
      }
    },
    NaN: {
      typeOf: 'Number',
      validate: isItNaN
    },
    Int: {
      typeOf: 'Number',
      validate: function(it){
        return !isItNaN(it) && it % 1 === 0;
      }
    },
    Float: {
      typeOf: 'Number',
      validate: function(it){
        return !isItNaN(it);
      }
    },
    Date: {
      typeOf: 'Date',
      validate: function(it){
        return !isItNaN(it.getTime());
      }
    }
  };
  defaultType = {
    array: 'Array',
    tuple: 'Array'
  };
  function checkArray(input, type){
    return all(function(it){
      return checkMultiple(it, type.of);
    }, input);
  }
  function checkTuple(input, type){
    var i, i$, ref$, len$, types;
    i = 0;
    for (i$ = 0, len$ = (ref$ = type.of).length; i$ < len$; ++i$) {
      types = ref$[i$];
      if (!checkMultiple(input[i], types)) {
        return false;
      }
      i++;
    }
    return input.length <= i;
  }
  function checkFields(input, type){
    var inputKeys, numInputKeys, k, numOfKeys, key, ref$, types;
    inputKeys = {};
    numInputKeys = 0;
    for (k in input) {
      inputKeys[k] = true;
      numInputKeys++;
    }
    numOfKeys = 0;
    for (key in ref$ = type.of) {
      types = ref$[key];
      if (!checkMultiple(input[key], types)) {
        return false;
      }
      if (inputKeys[key]) {
        numOfKeys++;
      }
    }
    return type.subset || numInputKeys === numOfKeys;
  }
  function checkStructure(input, type){
    if (!(input instanceof Object)) {
      return false;
    }
    switch (type.structure) {
    case 'fields':
      return checkFields(input, type);
    case 'array':
      return checkArray(input, type);
    case 'tuple':
      return checkTuple(input, type);
    }
  }
  function check(input, typeObj){
    var type, structure, setting, that;
    type = typeObj.type, structure = typeObj.structure;
    if (type) {
      if (type === '*') {
        return true;
      }
      setting = customTypes[type] || types[type];
      if (setting) {
        return setting.typeOf === toString$.call(input).slice(8, -1) && setting.validate(input);
      } else {
        return type === toString$.call(input).slice(8, -1) && (!structure || checkStructure(input, typeObj));
      }
    } else if (structure) {
      if (that = defaultType[structure]) {
        if (that !== toString$.call(input).slice(8, -1)) {
          return false;
        }
      }
      return checkStructure(input, typeObj);
    } else {
      throw new Error("No type defined. Input: " + input + ".");
    }
  }
  function checkMultiple(input, types){
    if (toString$.call(types).slice(8, -1) !== 'Array') {
      throw new Error("Types must be in an array. Input: " + input + ".");
    }
    return any(function(it){
      return check(input, it);
    }, types);
  }
  module.exports = function(parsedType, input, options){
    options == null && (options = {});
    customTypes = options.customTypes || {};
    return checkMultiple(input, parsedType);
  };
}).call(this);

},{"prelude-ls":91}],83:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var VERSION, parseType, parsedTypeCheck, typeCheck;
  VERSION = '0.3.0';
  parseType = require('./parse-type');
  parsedTypeCheck = require('./check');
  typeCheck = function(type, input, options){
    return parsedTypeCheck(parseType(type), input, options);
  };
  module.exports = {
    VERSION: VERSION,
    typeCheck: typeCheck,
    parsedTypeCheck: parsedTypeCheck,
    parseType: parseType
  };
}).call(this);

},{"./check":82,"./parse-type":84}],84:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var identifierRegex, tokenRegex;
  identifierRegex = /[\$\w]+/;
  function peek(tokens){
    var token;
    token = tokens[0];
    if (token == null) {
      throw new Error('Unexpected end of input.');
    }
    return token;
  }
  function consumeIdent(tokens){
    var token;
    token = peek(tokens);
    if (!identifierRegex.test(token)) {
      throw new Error("Expected text, got '" + token + "' instead.");
    }
    return tokens.shift();
  }
  function consumeOp(tokens, op){
    var token;
    token = peek(tokens);
    if (token !== op) {
      throw new Error("Expected '" + op + "', got '" + token + "' instead.");
    }
    return tokens.shift();
  }
  function maybeConsumeOp(tokens, op){
    var token;
    token = tokens[0];
    if (token === op) {
      return tokens.shift();
    } else {
      return null;
    }
  }
  function consumeArray(tokens){
    var types;
    consumeOp(tokens, '[');
    if (peek(tokens) === ']') {
      throw new Error("Must specify type of Array - eg. [Type], got [] instead.");
    }
    types = consumeTypes(tokens);
    consumeOp(tokens, ']');
    return {
      structure: 'array',
      of: types
    };
  }
  function consumeTuple(tokens){
    var components;
    components = [];
    consumeOp(tokens, '(');
    if (peek(tokens) === ')') {
      throw new Error("Tuple must be of at least length 1 - eg. (Type), got () instead.");
    }
    for (;;) {
      components.push(consumeTypes(tokens));
      maybeConsumeOp(tokens, ',');
      if (')' === peek(tokens)) {
        break;
      }
    }
    consumeOp(tokens, ')');
    return {
      structure: 'tuple',
      of: components
    };
  }
  function consumeFields(tokens){
    var fields, subset, ref$, key, types;
    fields = {};
    consumeOp(tokens, '{');
    subset = false;
    for (;;) {
      if (maybeConsumeOp(tokens, '...')) {
        subset = true;
        break;
      }
      ref$ = consumeField(tokens), key = ref$[0], types = ref$[1];
      fields[key] = types;
      maybeConsumeOp(tokens, ',');
      if ('}' === peek(tokens)) {
        break;
      }
    }
    consumeOp(tokens, '}');
    return {
      structure: 'fields',
      of: fields,
      subset: subset
    };
  }
  function consumeField(tokens){
    var key, types;
    key = consumeIdent(tokens);
    consumeOp(tokens, ':');
    types = consumeTypes(tokens);
    return [key, types];
  }
  function maybeConsumeStructure(tokens){
    switch (tokens[0]) {
    case '[':
      return consumeArray(tokens);
    case '(':
      return consumeTuple(tokens);
    case '{':
      return consumeFields(tokens);
    }
  }
  function consumeType(tokens){
    var token, wildcard, type, structure;
    token = peek(tokens);
    wildcard = token === '*';
    if (wildcard || identifierRegex.test(token)) {
      type = wildcard
        ? consumeOp(tokens, '*')
        : consumeIdent(tokens);
      structure = maybeConsumeStructure(tokens);
      if (structure) {
        return structure.type = type, structure;
      } else {
        return {
          type: type
        };
      }
    } else {
      structure = maybeConsumeStructure(tokens);
      if (!structure) {
        throw new Error("Unexpected character: " + token);
      }
      return structure;
    }
  }
  function consumeTypes(tokens){
    var lookahead, types, typesSoFar, typeObj, type;
    if ('::' === peek(tokens)) {
      throw new Error("No comment before comment separator '::' found.");
    }
    lookahead = tokens[1];
    if (lookahead != null && lookahead === '::') {
      tokens.shift();
      tokens.shift();
    }
    types = [];
    typesSoFar = {};
    if ('Maybe' === peek(tokens)) {
      tokens.shift();
      types = [
        {
          type: 'Undefined'
        }, {
          type: 'Null'
        }
      ];
      typesSoFar = {
        Undefined: true,
        Null: true
      };
    }
    for (;;) {
      typeObj = consumeType(tokens), type = typeObj.type;
      if (!typesSoFar[type]) {
        types.push(typeObj);
      }
      typesSoFar[type] = true;
      if (!maybeConsumeOp(tokens, '|')) {
        break;
      }
    }
    return types;
  }
  tokenRegex = RegExp('\\.\\.\\.|::|->|' + identifierRegex.source + '|\\S', 'g');
  module.exports = function(input){
    var tokens, e;
    if (!input.length) {
      throw new Error('No type specified.');
    }
    tokens = input.match(tokenRegex) || [];
    if (in$('->', tokens)) {
      throw new Error("Function types are not supported.\ To validate that something is a function, you may use 'Function'.");
    }
    try {
      return consumeTypes(tokens);
    } catch (e$) {
      e = e$;
      throw new Error(e.message + " - Remaining tokens: " + JSON.stringify(tokens) + " - Initial input: '" + input + "'");
    }
  };
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);

},{}],85:[function(require,module,exports){
var wordwrap = module.exports = function (start, stop, params) {
    if (typeof start === 'object') {
        params = start;
        start = params.start;
        stop = params.stop;
    }
    
    if (typeof stop === 'object') {
        params = stop;
        start = start || params.start;
        stop = undefined;
    }
    
    if (!stop) {
        stop = start;
        start = 0;
    }
    
    if (!params) params = {};
    var mode = params.mode || 'soft';
    var re = mode === 'hard' ? /\b/ : /(\S+\s+)/;
    
    return function (text) {
        var chunks = text.toString()
            .split(re)
            .reduce(function (acc, x) {
                if (mode === 'hard') {
                    for (var i = 0; i < x.length; i += stop - start) {
                        acc.push(x.slice(i, i + stop - start));
                    }
                }
                else acc.push(x)
                return acc;
            }, [])
        ;
        
        return chunks.reduce(function (lines, rawChunk) {
            if (rawChunk === '') return lines;
            
            var chunk = rawChunk.replace(/\t/g, '    ');
            
            var i = lines.length - 1;
            if (lines[i].length + chunk.length > stop) {
                lines[i] = lines[i].replace(/\s+$/, '');
                
                chunk.split(/\n/).forEach(function (c) {
                    lines.push(
                        new Array(start + 1).join(' ')
                        + c.replace(/^\s+/, '')
                    );
                });
            }
            else if (chunk.match(/\n/)) {
                var xs = chunk.split(/\n/);
                lines[i] += xs.shift();
                xs.forEach(function (c) {
                    lines.push(
                        new Array(start + 1).join(' ')
                        + c.replace(/^\s+/, '')
                    );
                });
            }
            else {
                lines[i] += chunk;
            }
            
            return lines;
        }, [ new Array(start + 1).join(' ') ]).join('\n');
    };
};

wordwrap.soft = wordwrap;

wordwrap.hard = function (start, stop) {
    return wordwrap(start, stop, { mode : 'hard' });
};

},{}],86:[function(require,module,exports){
var curry, flip, fix, apply;
curry = function(f){
  return curry$(f);
};
flip = curry$(function(f, x, y){
  return f(y, x);
});
fix = function(f){
  return function(g, x){
    return function(){
      return f(g(g)).apply(null, arguments);
    };
  }(function(g, x){
    return function(){
      return f(g(g)).apply(null, arguments);
    };
  });
};
apply = curry$(function(f, list){
  return f.apply(null, list);
});
module.exports = {
  curry: curry,
  flip: flip,
  fix: fix,
  apply: apply
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}

},{}],87:[function(require,module,exports){
var each, map, compact, filter, reject, partition, find, head, first, tail, last, initial, empty, reverse, unique, fold, foldl, fold1, foldl1, foldr, foldr1, unfoldr, concat, concatMap, flatten, difference, intersection, union, countBy, groupBy, andList, orList, any, all, sort, sortWith, sortBy, sum, product, mean, average, maximum, minimum, scan, scanl, scan1, scanl1, scanr, scanr1, slice, take, drop, splitAt, takeWhile, dropWhile, span, breakList, zip, zipWith, zipAll, zipAllWith, toString$ = {}.toString, slice$ = [].slice;
each = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    f(x);
  }
  return xs;
});
map = curry$(function(f, xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    results$.push(f(x));
  }
  return results$;
});
compact = curry$(function(xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (x) {
      results$.push(x);
    }
  }
  return results$;
});
filter = curry$(function(f, xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      results$.push(x);
    }
  }
  return results$;
});
reject = curry$(function(f, xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!f(x)) {
      results$.push(x);
    }
  }
  return results$;
});
partition = curry$(function(f, xs){
  var passed, failed, i$, len$, x;
  passed = [];
  failed = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    (f(x) ? passed : failed).push(x);
  }
  return [passed, failed];
});
find = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      return x;
    }
  }
});
head = first = function(xs){
  if (!xs.length) {
    return;
  }
  return xs[0];
};
tail = function(xs){
  if (!xs.length) {
    return;
  }
  return xs.slice(1);
};
last = function(xs){
  if (!xs.length) {
    return;
  }
  return xs[xs.length - 1];
};
initial = function(xs){
  var len;
  len = xs.length;
  if (!len) {
    return;
  }
  return xs.slice(0, len - 1);
};
empty = function(xs){
  return !xs.length;
};
reverse = function(xs){
  return xs.concat().reverse();
};
unique = function(xs){
  var result, i$, len$, x;
  result = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!in$(x, result)) {
      result.push(x);
    }
  }
  return result;
};
fold = foldl = curry$(function(f, memo, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    memo = f(memo, x);
  }
  return memo;
});
fold1 = foldl1 = curry$(function(f, xs){
  return fold(f, xs[0], xs.slice(1));
});
foldr = curry$(function(f, memo, xs){
  return fold(f, memo, xs.concat().reverse());
});
foldr1 = curry$(function(f, xs){
  var ys;
  ys = xs.concat().reverse();
  return fold(f, ys[0], ys.slice(1));
});
unfoldr = curry$(function(f, b){
  var result, x, that;
  result = [];
  x = b;
  while ((that = f(x)) != null) {
    result.push(that[0]);
    x = that[1];
  }
  return result;
});
concat = function(xss){
  return [].concat.apply([], xss);
};
concatMap = curry$(function(f, xs){
  var x;
  return [].concat.apply([], (function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      results$.push(f(x));
    }
    return results$;
  }()));
});
flatten = curry$(function(xs){
  var x;
  return [].concat.apply([], (function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      if (toString$.call(x).slice(8, -1) === 'Array') {
        results$.push(flatten(x));
      } else {
        results$.push(x);
      }
    }
    return results$;
  }()));
});
difference = function(xs){
  var yss, results, i$, len$, x, j$, len1$, ys;
  yss = slice$.call(arguments, 1);
  results = [];
  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
      ys = yss[j$];
      if (in$(x, ys)) {
        continue outer;
      }
    }
    results.push(x);
  }
  return results;
};
intersection = function(xs){
  var yss, results, i$, len$, x, j$, len1$, ys;
  yss = slice$.call(arguments, 1);
  results = [];
  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
      ys = yss[j$];
      if (!in$(x, ys)) {
        continue outer;
      }
    }
    results.push(x);
  }
  return results;
};
union = function(){
  var xss, results, i$, len$, xs, j$, len1$, x;
  xss = slice$.call(arguments);
  results = [];
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    for (j$ = 0, len1$ = xs.length; j$ < len1$; ++j$) {
      x = xs[j$];
      if (!in$(x, results)) {
        results.push(x);
      }
    }
  }
  return results;
};
countBy = curry$(function(f, xs){
  var results, i$, len$, x, key;
  results = {};
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    key = f(x);
    if (key in results) {
      results[key] += 1;
    } else {
      results[key] = 1;
    }
  }
  return results;
});
groupBy = curry$(function(f, xs){
  var results, i$, len$, x, key;
  results = {};
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    key = f(x);
    if (key in results) {
      results[key].push(x);
    } else {
      results[key] = [x];
    }
  }
  return results;
});
andList = function(xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!x) {
      return false;
    }
  }
  return true;
};
orList = function(xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (x) {
      return true;
    }
  }
  return false;
};
any = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      return true;
    }
  }
  return false;
});
all = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!f(x)) {
      return false;
    }
  }
  return true;
});
sort = function(xs){
  return xs.concat().sort(function(x, y){
    if (x > y) {
      return 1;
    } else if (x < y) {
      return -1;
    } else {
      return 0;
    }
  });
};
sortWith = curry$(function(f, xs){
  if (!xs.length) {
    return [];
  }
  return xs.concat().sort(f);
});
sortBy = curry$(function(f, xs){
  if (!xs.length) {
    return [];
  }
  return xs.concat().sort(function(x, y){
    if (f(x) > f(y)) {
      return 1;
    } else if (f(x) < f(y)) {
      return -1;
    } else {
      return 0;
    }
  });
});
sum = function(xs){
  var result, i$, len$, x;
  result = 0;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    result += x;
  }
  return result;
};
product = function(xs){
  var result, i$, len$, x;
  result = 1;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    result *= x;
  }
  return result;
};
mean = average = function(xs){
  var sum, len, i$, i;
  sum = 0;
  len = xs.length;
  for (i$ = 0; i$ < len; ++i$) {
    i = i$;
    sum += xs[i];
  }
  return sum / len;
};
maximum = function(xs){
  var max, i$, ref$, len$, x;
  max = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (x > max) {
      max = x;
    }
  }
  return max;
};
minimum = function(xs){
  var min, i$, ref$, len$, x;
  min = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (x < min) {
      min = x;
    }
  }
  return min;
};
scan = scanl = curry$(function(f, memo, xs){
  var last, x;
  last = memo;
  return [memo].concat((function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      results$.push(last = f(last, x));
    }
    return results$;
  }()));
});
scan1 = scanl1 = curry$(function(f, xs){
  if (!xs.length) {
    return;
  }
  return scan(f, xs[0], xs.slice(1));
});
scanr = curry$(function(f, memo, xs){
  xs = xs.concat().reverse();
  return scan(f, memo, xs).reverse();
});
scanr1 = curry$(function(f, xs){
  if (!xs.length) {
    return;
  }
  xs = xs.concat().reverse();
  return scan(f, xs[0], xs.slice(1)).reverse();
});
slice = curry$(function(x, y, xs){
  return xs.slice(x, y);
});
take = curry$(function(n, xs){
  if (n <= 0) {
    return xs.slice(0, 0);
  } else if (!xs.length) {
    return xs;
  } else {
    return xs.slice(0, n);
  }
});
drop = curry$(function(n, xs){
  if (n <= 0 || !xs.length) {
    return xs;
  } else {
    return xs.slice(n);
  }
});
splitAt = curry$(function(n, xs){
  return [take(n, xs), drop(n, xs)];
});
takeWhile = curry$(function(p, xs){
  var len, i;
  len = xs.length;
  if (!len) {
    return xs;
  }
  i = 0;
  while (i < len && p(xs[i])) {
    i += 1;
  }
  return xs.slice(0, i);
});
dropWhile = curry$(function(p, xs){
  var len, i;
  len = xs.length;
  if (!len) {
    return xs;
  }
  i = 0;
  while (i < len && p(xs[i])) {
    i += 1;
  }
  return xs.slice(i);
});
span = curry$(function(p, xs){
  return [takeWhile(p, xs), dropWhile(p, xs)];
});
breakList = curry$(function(p, xs){
  return span(compose$([not$, p]), xs);
});
zip = curry$(function(xs, ys){
  var result, len, i$, len$, i, x;
  result = [];
  len = ys.length;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (i === len) {
      break;
    }
    result.push([x, ys[i]]);
  }
  return result;
});
zipWith = curry$(function(f, xs, ys){
  var result, len, i$, len$, i, x;
  result = [];
  len = ys.length;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (i === len) {
      break;
    }
    result.push(f(x, ys[i]));
  }
  return result;
});
zipAll = function(){
  var xss, minLength, i$, len$, xs, ref$, i, lresult$, j$, results$ = [];
  xss = slice$.call(arguments);
  minLength = 9e9;
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    minLength <= (ref$ = xs.length) || (minLength = ref$);
  }
  for (i$ = 0; i$ < minLength; ++i$) {
    i = i$;
    lresult$ = [];
    for (j$ = 0, len$ = xss.length; j$ < len$; ++j$) {
      xs = xss[j$];
      lresult$.push(xs[i]);
    }
    results$.push(lresult$);
  }
  return results$;
};
zipAllWith = function(f){
  var xss, minLength, i$, len$, xs, ref$, i, results$ = [];
  xss = slice$.call(arguments, 1);
  minLength = 9e9;
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    minLength <= (ref$ = xs.length) || (minLength = ref$);
  }
  for (i$ = 0; i$ < minLength; ++i$) {
    i = i$;
    results$.push(f.apply(null, (fn$())));
  }
  return results$;
  function fn$(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xss).length; i$ < len$; ++i$) {
      xs = ref$[i$];
      results$.push(xs[i]);
    }
    return results$;
  }
};
module.exports = {
  each: each,
  map: map,
  filter: filter,
  compact: compact,
  reject: reject,
  partition: partition,
  find: find,
  head: head,
  first: first,
  tail: tail,
  last: last,
  initial: initial,
  empty: empty,
  reverse: reverse,
  difference: difference,
  intersection: intersection,
  union: union,
  countBy: countBy,
  groupBy: groupBy,
  fold: fold,
  fold1: fold1,
  foldl: foldl,
  foldl1: foldl1,
  foldr: foldr,
  foldr1: foldr1,
  unfoldr: unfoldr,
  andList: andList,
  orList: orList,
  any: any,
  all: all,
  unique: unique,
  sort: sort,
  sortWith: sortWith,
  sortBy: sortBy,
  sum: sum,
  product: product,
  mean: mean,
  average: average,
  concat: concat,
  concatMap: concatMap,
  flatten: flatten,
  maximum: maximum,
  minimum: minimum,
  scan: scan,
  scan1: scan1,
  scanl: scanl,
  scanl1: scanl1,
  scanr: scanr,
  scanr1: scanr1,
  slice: slice,
  take: take,
  drop: drop,
  splitAt: splitAt,
  takeWhile: takeWhile,
  dropWhile: dropWhile,
  span: span,
  breakList: breakList,
  zip: zip,
  zipWith: zipWith,
  zipAll: zipAll,
  zipAllWith: zipAllWith
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
function in$(x, arr){
  var i = -1, l = arr.length >>> 0;
  while (++i < l) if (x === arr[i] && i in arr) return true;
  return false;
}
function compose$(fs){
  return function(){
    var i, args = arguments;
    for (i = fs.length; i > 0; --i) { args = [fs[i-1].apply(this, args)]; }
    return args[0];
  };
}
function not$(x){ return !x; }

},{}],88:[function(require,module,exports){
var max, min, negate, abs, signum, quot, rem, div, mod, recip, pi, tau, exp, sqrt, ln, pow, sin, tan, cos, asin, acos, atan, atan2, truncate, round, ceiling, floor, isItNaN, even, odd, gcd, lcm;
max = curry$(function(x$, y$){
  return x$ > y$ ? x$ : y$;
});
min = curry$(function(x$, y$){
  return x$ < y$ ? x$ : y$;
});
negate = function(x){
  return -x;
};
abs = Math.abs;
signum = function(x){
  if (x < 0) {
    return -1;
  } else if (x > 0) {
    return 1;
  } else {
    return 0;
  }
};
quot = curry$(function(x, y){
  return ~~(x / y);
});
rem = curry$(function(x$, y$){
  return x$ % y$;
});
div = curry$(function(x, y){
  return Math.floor(x / y);
});
mod = curry$(function(x$, y$){
  var ref$;
  return ((x$) % (ref$ = y$) + ref$) % ref$;
});
recip = (function(it){
  return 1 / it;
});
pi = Math.PI;
tau = pi * 2;
exp = Math.exp;
sqrt = Math.sqrt;
ln = Math.log;
pow = curry$(function(x$, y$){
  return Math.pow(x$, y$);
});
sin = Math.sin;
tan = Math.tan;
cos = Math.cos;
asin = Math.asin;
acos = Math.acos;
atan = Math.atan;
atan2 = curry$(function(x, y){
  return Math.atan2(x, y);
});
truncate = function(x){
  return ~~x;
};
round = Math.round;
ceiling = Math.ceil;
floor = Math.floor;
isItNaN = function(x){
  return x !== x;
};
even = function(x){
  return x % 2 === 0;
};
odd = function(x){
  return x % 2 !== 0;
};
gcd = curry$(function(x, y){
  var z;
  x = Math.abs(x);
  y = Math.abs(y);
  while (y !== 0) {
    z = x % y;
    x = y;
    y = z;
  }
  return x;
});
lcm = curry$(function(x, y){
  return Math.abs(Math.floor(x / gcd(x, y) * y));
});
module.exports = {
  max: max,
  min: min,
  negate: negate,
  abs: abs,
  signum: signum,
  quot: quot,
  rem: rem,
  div: div,
  mod: mod,
  recip: recip,
  pi: pi,
  tau: tau,
  exp: exp,
  sqrt: sqrt,
  ln: ln,
  pow: pow,
  sin: sin,
  tan: tan,
  cos: cos,
  acos: acos,
  asin: asin,
  atan: atan,
  atan2: atan2,
  truncate: truncate,
  round: round,
  ceiling: ceiling,
  floor: floor,
  isItNaN: isItNaN,
  even: even,
  odd: odd,
  gcd: gcd,
  lcm: lcm
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}

},{}],89:[function(require,module,exports){
var values, keys, pairsToObj, objToPairs, listsToObj, objToLists, empty, each, map, compact, filter, reject, partition, find;
values = function(object){
  var i$, x, results$ = [];
  for (i$ in object) {
    x = object[i$];
    results$.push(x);
  }
  return results$;
};
keys = function(object){
  var x, results$ = [];
  for (x in object) {
    results$.push(x);
  }
  return results$;
};
pairsToObj = function(object){
  var i$, len$, x, results$ = {};
  for (i$ = 0, len$ = object.length; i$ < len$; ++i$) {
    x = object[i$];
    results$[x[0]] = x[1];
  }
  return results$;
};
objToPairs = function(object){
  var key, value, results$ = [];
  for (key in object) {
    value = object[key];
    results$.push([key, value]);
  }
  return results$;
};
listsToObj = curry$(function(keys, values){
  var i$, len$, i, key, results$ = {};
  for (i$ = 0, len$ = keys.length; i$ < len$; ++i$) {
    i = i$;
    key = keys[i$];
    results$[key] = values[i];
  }
  return results$;
});
objToLists = function(objectect){
  var keys, values, key, value;
  keys = [];
  values = [];
  for (key in objectect) {
    value = objectect[key];
    keys.push(key);
    values.push(value);
  }
  return [keys, values];
};
empty = function(object){
  var x;
  for (x in object) {
    return false;
  }
  return true;
};
each = curry$(function(f, object){
  var i$, x;
  for (i$ in object) {
    x = object[i$];
    f(x);
  }
  return object;
});
map = curry$(function(f, object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
    results$[k] = f(x);
  }
  return results$;
});
compact = curry$(function(object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
if (x) {
      results$[k] = x;
    }
  }
  return results$;
});
filter = curry$(function(f, object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
if (f(x)) {
      results$[k] = x;
    }
  }
  return results$;
});
reject = curry$(function(f, object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
if (!f(x)) {
      results$[k] = x;
    }
  }
  return results$;
});
partition = curry$(function(f, object){
  var passed, failed, k, x;
  passed = {};
  failed = {};
  for (k in object) {
    x = object[k];
    (f(x) ? passed : failed)[k] = x;
  }
  return [passed, failed];
});
find = curry$(function(f, object){
  var i$, x;
  for (i$ in object) {
    x = object[i$];
    if (f(x)) {
      return x;
    }
  }
});
module.exports = {
  values: values,
  keys: keys,
  pairsToObj: pairsToObj,
  objToPairs: objToPairs,
  listsToObj: listsToObj,
  objToLists: objToLists,
  empty: empty,
  each: each,
  map: map,
  filter: filter,
  compact: compact,
  reject: reject,
  partition: partition,
  find: find
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}

},{}],90:[function(require,module,exports){
var split, join, lines, unlines, words, unwords, chars, unchars, reverse, repeat;
split = curry$(function(sep, str){
  return str.split(sep);
});
join = curry$(function(sep, xs){
  return xs.join(sep);
});
lines = function(str){
  if (!str.length) {
    return [];
  }
  return str.split('\n');
};
unlines = function(it){
  return it.join('\n');
};
words = function(str){
  if (!str.length) {
    return [];
  }
  return str.split(/[ ]+/);
};
unwords = function(it){
  return it.join(' ');
};
chars = function(it){
  return it.split('');
};
unchars = function(it){
  return it.join('');
};
reverse = function(str){
  return str.split('').reverse().join('');
};
repeat = curry$(function(n, str){
  var out, res$, i$;
  res$ = [];
  for (i$ = 0; i$ < n; ++i$) {
    res$.push(str);
  }
  out = res$;
  return out.join('');
});
module.exports = {
  split: split,
  join: join,
  lines: lines,
  unlines: unlines,
  words: words,
  unwords: unwords,
  chars: chars,
  unchars: unchars,
  reverse: reverse,
  repeat: repeat
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}

},{}],91:[function(require,module,exports){
var Func, List, Obj, Str, Num, id, isType, replicate, prelude, toString$ = {}.toString;
Func = require('./Func.js');
List = require('./List.js');
Obj = require('./Obj.js');
Str = require('./Str.js');
Num = require('./Num.js');
id = function(x){
  return x;
};
isType = curry$(function(type, x){
  return toString$.call(x).slice(8, -1) === type;
});
replicate = curry$(function(n, x){
  var i$, results$ = [];
  for (i$ = 0; i$ < n; ++i$) {
    results$.push(x);
  }
  return results$;
});
Str.empty = List.empty;
Str.slice = List.slice;
Str.take = List.take;
Str.drop = List.drop;
Str.splitAt = List.splitAt;
Str.takeWhile = List.takeWhile;
Str.dropWhile = List.dropWhile;
Str.span = List.span;
Str.breakStr = List.breakList;
prelude = {
  Func: Func,
  List: List,
  Obj: Obj,
  Str: Str,
  Num: Num,
  id: id,
  isType: isType,
  replicate: replicate
};
prelude.each = List.each;
prelude.map = List.map;
prelude.filter = List.filter;
prelude.compact = List.compact;
prelude.reject = List.reject;
prelude.partition = List.partition;
prelude.find = List.find;
prelude.head = List.head;
prelude.first = List.first;
prelude.tail = List.tail;
prelude.last = List.last;
prelude.initial = List.initial;
prelude.empty = List.empty;
prelude.reverse = List.reverse;
prelude.difference = List.difference;
prelude.intersection = List.intersection;
prelude.union = List.union;
prelude.countBy = List.countBy;
prelude.groupBy = List.groupBy;
prelude.fold = List.fold;
prelude.foldl = List.foldl;
prelude.fold1 = List.fold1;
prelude.foldl1 = List.foldl1;
prelude.foldr = List.foldr;
prelude.foldr1 = List.foldr1;
prelude.unfoldr = List.unfoldr;
prelude.andList = List.andList;
prelude.orList = List.orList;
prelude.any = List.any;
prelude.all = List.all;
prelude.unique = List.unique;
prelude.sort = List.sort;
prelude.sortWith = List.sortWith;
prelude.sortBy = List.sortBy;
prelude.sum = List.sum;
prelude.product = List.product;
prelude.mean = List.mean;
prelude.average = List.average;
prelude.concat = List.concat;
prelude.concatMap = List.concatMap;
prelude.flatten = List.flatten;
prelude.maximum = List.maximum;
prelude.minimum = List.minimum;
prelude.scan = List.scan;
prelude.scanl = List.scanl;
prelude.scan1 = List.scan1;
prelude.scanl1 = List.scanl1;
prelude.scanr = List.scanr;
prelude.scanr1 = List.scanr1;
prelude.slice = List.slice;
prelude.take = List.take;
prelude.drop = List.drop;
prelude.splitAt = List.splitAt;
prelude.takeWhile = List.takeWhile;
prelude.dropWhile = List.dropWhile;
prelude.span = List.span;
prelude.breakList = List.breakList;
prelude.zip = List.zip;
prelude.zipWith = List.zipWith;
prelude.zipAll = List.zipAll;
prelude.zipAllWith = List.zipAllWith;
prelude.apply = Func.apply;
prelude.curry = Func.curry;
prelude.flip = Func.flip;
prelude.fix = Func.fix;
prelude.split = Str.split;
prelude.join = Str.join;
prelude.lines = Str.lines;
prelude.unlines = Str.unlines;
prelude.words = Str.words;
prelude.unwords = Str.unwords;
prelude.chars = Str.chars;
prelude.unchars = Str.unchars;
prelude.values = Obj.values;
prelude.keys = Obj.keys;
prelude.pairsToObj = Obj.pairsToObj;
prelude.objToPairs = Obj.objToPairs;
prelude.listsToObj = Obj.listsToObj;
prelude.objToLists = Obj.objToLists;
prelude.max = Num.max;
prelude.min = Num.min;
prelude.negate = Num.negate;
prelude.abs = Num.abs;
prelude.signum = Num.signum;
prelude.quot = Num.quot;
prelude.rem = Num.rem;
prelude.div = Num.div;
prelude.mod = Num.mod;
prelude.recip = Num.recip;
prelude.pi = Num.pi;
prelude.tau = Num.tau;
prelude.exp = Num.exp;
prelude.sqrt = Num.sqrt;
prelude.ln = Num.ln;
prelude.pow = Num.pow;
prelude.sin = Num.sin;
prelude.tan = Num.tan;
prelude.cos = Num.cos;
prelude.acos = Num.acos;
prelude.asin = Num.asin;
prelude.atan = Num.atan;
prelude.atan2 = Num.atan2;
prelude.truncate = Num.truncate;
prelude.round = Num.round;
prelude.ceiling = Num.ceiling;
prelude.floor = Num.floor;
prelude.isItNaN = Num.isItNaN;
prelude.even = Num.even;
prelude.odd = Num.odd;
prelude.gcd = Num.gcd;
prelude.lcm = Num.lcm;
prelude.VERSION = '1.0.3';
module.exports = prelude;
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}

},{"./Func.js":86,"./List.js":87,"./Num.js":88,"./Obj.js":89,"./Str.js":90}]},{},[2])
;